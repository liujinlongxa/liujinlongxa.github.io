<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liujinlongxa的技术博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujinlongxa.com/"/>
  <updated>2018-09-03T16:22:46.695Z</updated>
  <id>http://liujinlongxa.com/</id>
  
  <author>
    <name>liujinlongxa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python学习笔记(2)</title>
    <link href="http://liujinlongxa.com/2018/09/03/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/"/>
    <id>http://liujinlongxa.com/2018/09/03/Python学习笔记-2/</id>
    <published>2018-09-03T15:03:40.000Z</published>
    <updated>2018-09-03T16:22:46.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的特点"><a href="#函数的特点" class="headerlink" title="函数的特点"></a>函数的特点</h3><ul><li>功能性：一个函数要有明确的功能</li><li>隐藏细节：调用者不需要关注函数的细节</li><li>函数的目的：减少重复代码</li></ul><h3 id="Python-中函数的定义"><a href="#Python-中函数的定义" class="headerlink" title="Python 中函数的定义"></a>Python 中函数的定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funcname</span><span class="params">(parameter_list)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 与Python内置的max函数重名了，会覆盖内置的max函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> a &gt; b:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(max(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(func())  <span class="comment"># None，无返回值则默认返回None</span></span><br></pre></td></tr></table></figure><ul><li>参数列表可有可无</li><li>函数内可以<code>return value</code>，如果没有 return，则默认返回 None</li><li>函数必须先定义才能使用</li><li>函数名不能与 Python 内置的函数名重名，否则会覆盖内置函数</li></ul><p>Python 中关于递归函数：</p><ul><li>Python 默认的递归次数是有限的</li><li>可以通过<code>sys.setrecursionlimit(10000)</code>方法来修改递归次数</li></ul><p>关于 print 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br><span class="line">print(a, b, c) <span class="comment"># 分别打印a, b, c</span></span><br></pre></td></tr></table></figure><h3 id="Python-中函数可以返回多个值"><a href="#Python-中函数可以返回多个值" class="headerlink" title="Python 中函数可以返回多个值"></a>Python 中函数可以返回多个值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(num)</span>:</span></span><br><span class="line">    a = num * <span class="number">2</span></span><br><span class="line">    b = num * <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> a, b</span><br><span class="line"></span><br><span class="line">ret = func(<span class="number">10</span>)  <span class="comment"># ret是一个元组</span></span><br><span class="line">print(ret)</span><br><span class="line">a, b = func(<span class="number">10</span>)  <span class="comment"># 推荐的做法，序列解包，不要使用元组[序号]</span></span><br><span class="line">print(a, b)</span><br></pre></td></tr></table></figure><h3 id="Python-中的序列解包和链式赋值"><a href="#Python-中的序列解包和链式赋值" class="headerlink" title="Python 中的序列解包和链式赋值"></a>Python 中的序列解包和链式赋值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">d = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment"># a是一个元组</span></span><br><span class="line">a, b, c = d  <span class="comment"># 序列解包</span></span><br><span class="line">a = b = c = <span class="number">1</span> <span class="comment"># 链式赋值</span></span><br></pre></td></tr></table></figure><h3 id="必须参数和关键字参数"><a href="#必须参数和关键字参数" class="headerlink" title="必须参数和关键字参数"></a>必须参数和关键字参数</h3><ul><li>必须参数：函数参数列表中定义的，必须传递的参数，如果不传则会编译错误</li><li>关键字参数：明确指定参数的值，可以无视参数的顺序</li><li>如果参数列表中既有必须参数，又有关键字参数，则关键字参数必须位于必须参数之后</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(num1, num2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = add(<span class="number">12</span>, <span class="number">13</span>)  <span class="comment"># 以必须参数的形式调用</span></span><br><span class="line">print(ret)</span><br><span class="line">ret1 = add(num2=<span class="number">13</span>, num1=<span class="number">14</span>)  <span class="comment"># 以关键字参数的形式调用</span></span><br><span class="line">print(ret1)</span><br><span class="line">ret2 = add(<span class="number">14</span>, num2=<span class="number">15</span>)  <span class="comment"># Ok, 关键字参数可以在必须参数之后</span></span><br><span class="line">print(ret2)</span><br><span class="line">ret3 = add(num1=<span class="number">14</span>, <span class="number">15</span>)  <span class="comment"># error，关键字参数不能在必须参数前</span></span><br><span class="line">print(ret3)</span><br></pre></td></tr></table></figure><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><ul><li>默认参数必须位于参数列表的最后</li><li>默认参数既可以使用关键字参数，也可以使用必须参数，也可以不传</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(num1, num2, num3=<span class="number">3</span>, num4=<span class="number">4</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> num1 + num2 + num3 + num4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(add(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>))</span><br><span class="line">print(add(<span class="number">10</span>, <span class="number">20</span>, num4=<span class="number">40</span>, num3=<span class="number">30</span>))</span><br><span class="line">print(add(<span class="number">10</span>, <span class="number">20</span>, num4=<span class="number">40</span>))</span><br><span class="line">print(add(<span class="number">10</span>, <span class="number">20</span>, num3=<span class="number">30</span>))</span><br><span class="line">print(add(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>))</span><br><span class="line">print(add(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line">print(add(num1=<span class="number">10</span>, num2=<span class="number">20</span>))</span><br><span class="line">print(add(num2=<span class="number">20</span>, num1=<span class="number">10</span>))</span><br></pre></td></tr></table></figure><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul><li>可变参数，给参数名前加一个星号<code>*</code></li><li>传递参数是，可以传一个元组或列表，前面要加一个星号<code>*</code></li><li>可变参数之后可以有关键字参数，但不能有必须参数，必须参数必须位于可变参数之前，默认参数也要使用关键字参数的形式进行调用</li><li>可以参数也可以什么都不传，相当于传一个空的元组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(*param)</span>:</span></span><br><span class="line">    print(param)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">fun(*a)  <span class="comment"># *相当于展开元组内的元素</span></span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">fun(*b)  <span class="comment"># 同上</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">(num1, *param)</span>:</span></span><br><span class="line">    print(param)</span><br><span class="line">    print(num1)</span><br><span class="line"></span><br><span class="line">fun1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment"># (2, 3, 4), 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可变参数后有关键字参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">(num1, *param, num2, num3=<span class="number">3</span>)</span>:</span></span><br><span class="line">    print(param)</span><br><span class="line">    print(num1)</span><br><span class="line">    print(num2)</span><br><span class="line">    print(num3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, num2=<span class="number">13</span>) <span class="comment"># 1, (2, 3, 4), 13, 3</span></span><br><span class="line">fun1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, num2=<span class="number">13</span>, num3=<span class="number">14</span>) <span class="comment"># 1, (2, 3, 4), 13, 14</span></span><br><span class="line">fun1(<span class="number">1</span>, num2 = <span class="number">13</span>, num3 = <span class="number">14</span>) <span class="comment"># 1, (), 13, 14 可变参数为空元组</span></span><br></pre></td></tr></table></figure><h3 id="关键字可变参数"><a href="#关键字可变参数" class="headerlink" title="关键字可变参数"></a>关键字可变参数</h3><ul><li>参数前加两个星号<code>**</code></li><li>传递参数时需要传一个字典或使用关键字参数进行调用</li><li>可以参数也可以什么都不传，相当于传一个空的字典</li><li>关键字可变参数必须位于参数列表的最后</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(**param)</span>:</span></span><br><span class="line">    print(param)  <span class="comment"># param是一个字典</span></span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> param.items():</span><br><span class="line">        print(<span class="string">'key:'</span> + key + <span class="string">', value: '</span> + str(value))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun(num1=<span class="number">1</span>, num2=<span class="number">2</span>, num3=<span class="number">3</span>)</span><br><span class="line">a = &#123;<span class="string">'aa'</span>: <span class="number">1</span>, <span class="string">'bb'</span>: <span class="number">2</span>&#125;</span><br><span class="line">fun(**a)  <span class="comment"># 相当于解包a</span></span><br><span class="line">fun()  <span class="comment"># &#123;&#125; , 可变参数也可以什么都不传，相当于传一个空字典</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(num1, **param)</span>:</span></span><br><span class="line">    print(param)  <span class="comment"># param是一个字典</span></span><br><span class="line">    print(num1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br><span class="line">fun(<span class="number">1</span>, **a)</span><br></pre></td></tr></table></figure><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="number">50</span> <span class="comment"># 全局变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    c = a + b  <span class="comment"># c 相当于一个新的局部变量，覆盖了外部的变量</span></span><br><span class="line">    print(c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># 3</span></span><br><span class="line">print(c)  <span class="comment"># 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">9</span>):</span><br><span class="line">    a = <span class="number">12</span></span><br><span class="line">    print(i)</span><br><span class="line">print(a)  <span class="comment"># 循环外部可以引用循环内部的变量，Python没有块级作用域</span></span><br></pre></td></tr></table></figure><h3 id="global-关键字"><a href="#global-关键字" class="headerlink" title="global 关键字"></a>global 关键字</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a  <span class="comment"># 将a提升为全局作用域，a可以通过import导入其他模块</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">fun()</span><br><span class="line">print(a) <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">12</span> <span class="comment"># 全局作用域</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> b</span><br><span class="line">    b = b + num  <span class="comment"># 修改全局作用域的变量b</span></span><br><span class="line"></span><br><span class="line">fun1(<span class="number">11</span>)</span><br><span class="line">print(b) <span class="comment"># 23</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;h3 id=&quot;函数的特点&quot;&gt;&lt;a href=&quot;#函数的特点&quot; class=&quot;headerlink&quot; title=&quot;函数的特点&quot;&gt;&lt;/a&gt;函数的特
      
    
    </summary>
    
      <category term="Python" scheme="http://liujinlongxa.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://liujinlongxa.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记(1)</title>
    <link href="http://liujinlongxa.com/2018/09/01/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://liujinlongxa.com/2018/09/01/Python学习笔记-1/</id>
    <published>2018-09-01T00:26:31.000Z</published>
    <updated>2018-09-01T05:37:43.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="除，整除"><a href="#除，整除" class="headerlink" title="除，整除"></a>除，整除</h3><p>与其他语言不通，<code>/</code>是除法，得到的 float 类型，要得到整型需要用<code>//</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type(<span class="number">2</span>/<span class="number">2</span>) <span class="comment"># float</span></span><br><span class="line">type(<span class="number">2</span>//<span class="number">2</span>) <span class="comment"># int</span></span><br><span class="line"><span class="number">1</span>//<span class="number">2</span> <span class="comment"># 0</span></span><br><span class="line"><span class="number">1</span>/<span class="number">2</span> <span class="comment"># 0.5</span></span><br></pre></td></tr></table></figure><h3 id="二进制，八进制，十六进制"><a href="#二进制，八进制，十六进制" class="headerlink" title="二进制，八进制，十六进制"></a>二进制，八进制，十六进制</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b10</span> <span class="comment"># 2进制</span></span><br><span class="line"><span class="number">0o10</span> <span class="comment"># 8进制</span></span><br><span class="line"><span class="number">0x10</span> <span class="comment"># 16进制</span></span><br><span class="line"><span class="comment"># 将一个数转为二进制</span></span><br><span class="line">bin(<span class="number">12</span>)</span><br><span class="line"><span class="comment"># 将一个数转为10进制</span></span><br><span class="line">int(<span class="number">0x12</span>)</span><br><span class="line"><span class="comment"># 将一个数转为16进制</span></span><br><span class="line">hex(<span class="number">12131</span>)</span><br><span class="line"><span class="comment"># 将一个数转为8进制</span></span><br><span class="line">oct(<span class="number">0x1231</span>)</span><br></pre></td></tr></table></figure><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔类型有两个值，<code>True</code>与<code>False</code></p><ul><li>对于整数来说，非 0 可以转为<code>True</code>，0 可以转为<code>False</code></li><li>对于字符串来说，空字符串可以转为<code>False</code>，其他字符串可以转为<code>True</code></li><li>对于列表和元组等序列来说，空序列可以转为<code>False</code>，序列中有元素可以转为<code>True</code></li><li>对集合和字典来说，空字典，空集合可以转为<code>False</code>，字典或序列中有元素可以转为<code>True</code></li><li>None 也可以转为<code>False</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">num1 = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> num1:</span><br><span class="line">    print(<span class="string">'YES'</span>)  <span class="comment"># YES</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'NO'</span>)</span><br><span class="line"></span><br><span class="line">num2 = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> num2:</span><br><span class="line">    print(<span class="string">'YES'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'NO'</span>)  <span class="comment"># NO</span></span><br><span class="line"></span><br><span class="line">list1 = []</span><br><span class="line">list2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> list1:</span><br><span class="line">    print(<span class="string">'YES'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'NO'</span>)  <span class="comment"># NO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> list2:</span><br><span class="line">    print(<span class="string">'YES'</span>)  <span class="comment"># YES</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'NO'</span>)</span><br><span class="line"></span><br><span class="line">dict1 = &#123;&#125;</span><br><span class="line">dict2 = &#123;<span class="number">1</span>: <span class="string">'A'</span>, <span class="number">2</span>: <span class="string">'B'</span>&#125;</span><br><span class="line"><span class="keyword">if</span> dict1:</span><br><span class="line">    print(<span class="string">'YES'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'NO'</span>)  <span class="comment"># NO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> dict2:</span><br><span class="line">    print(<span class="string">'YES'</span>)  <span class="comment"># YES</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'NO'</span>)</span><br></pre></td></tr></table></figure><h3 id="单引号和双引号"><a href="#单引号和双引号" class="headerlink" title="单引号和双引号"></a>单引号和双引号</h3><ul><li>单引号：单引号可以包含双引号，例如：<code>&#39;My name is &quot;ljl&quot;&#39;</code></li><li>双引号：双引号也可以包含单引号，例如：<code>&quot;Let&#39;s go&quot;</code></li></ul><h3 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h3><p>多行文本可以用三个双引号表示，也可以用三个单引号表示，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Hello!</span></span><br><span class="line"><span class="string">My name is Liuijinlong.</span></span><br><span class="line"><span class="string">What is your name?</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Hello!</span></span><br><span class="line"><span class="string">My name is Liuijinlong.</span></span><br><span class="line"><span class="string">What is your name?</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><ul><li>要显示字符串的格式要使用<code>print</code>函数</li><li>idle 会把字符串中的格式变为转义字符，如下：</li></ul><p><img src="http://pecqz8zqd.bkt.clouddn.com/094e3ce9743b9dafadb426041996058b.png" alt="1"></p><h3 id="原始字符"><a href="#原始字符" class="headerlink" title="原始字符"></a>原始字符</h3><p>在字符串前加一个 r，字符串中的转义字符不会被解析</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">r'aaa \n aaa'</span>) <span class="comment"># aaa \n aaa</span></span><br></pre></td></tr></table></figure><h3 id="字符串的操作"><a href="#字符串的操作" class="headerlink" title="字符串的操作"></a>字符串的操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">"Hello"</span></span><br><span class="line">s2 = <span class="string">"World"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接</span></span><br><span class="line">s = s1 + s2</span><br><span class="line">print(s)  <span class="comment"># HelloWorld</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取，切片操作</span></span><br><span class="line">print(s[<span class="number">2</span>])  <span class="comment"># l</span></span><br><span class="line">print(s[<span class="number">2</span>: <span class="number">5</span>])  <span class="comment"># llo</span></span><br><span class="line">print(s[<span class="number">2</span>: <span class="number">-3</span>])  <span class="comment"># lloWo</span></span><br><span class="line"></span><br><span class="line">print(s1 * <span class="number">2</span>)  <span class="comment"># 重复字符串：HelloHello</span></span><br><span class="line">print(len(s1))  <span class="comment"># 字符串长度：5</span></span><br><span class="line">print(s1.count(<span class="string">'l'</span>))  <span class="comment"># l在字符串中出现的次数</span></span><br><span class="line">print(s1.find(<span class="string">'ell'</span>))  <span class="comment"># 查找字符串，返回第一次出现的位置，返回-1表示未找到</span></span><br><span class="line">print(s1.index(<span class="string">'ell'</span>))  <span class="comment"># 返回首次出现的位置，与find方法类似，如果未找到会返回错误</span></span><br><span class="line">print(s1.endswith(<span class="string">'lo'</span>))  <span class="comment"># 是否以lo结尾</span></span><br><span class="line">print(s1.startswith(<span class="string">'he'</span>))  <span class="comment"># 是否以he开头</span></span><br><span class="line">print(s1.isalnum())  <span class="comment"># 返回是否至少有一个字符并且都是是字母或数字</span></span><br><span class="line">print(s1.isalpha())  <span class="comment"># 返回是否至少有一个字符并且都是字母</span></span><br><span class="line">print(s1.isdigit())  <span class="comment"># 返回是否至少有一个字符并且都是数字</span></span><br><span class="line">print(s1.islower())  <span class="comment"># 返回是否至少有一个字符并且都是小写字母</span></span><br><span class="line">print(s1.isupper())  <span class="comment"># 返回是否至少有一个字符并且都是大写字母</span></span><br><span class="line">print(<span class="string">' '</span>.join([s1, s2]))  <span class="comment"># 合并s1, s2，已空格分割</span></span><br><span class="line">print((s1 + <span class="string">' '</span> + s2).split(<span class="string">' '</span>))  <span class="comment"># 按指定分隔符分割字符串</span></span><br><span class="line">print(s1.title())  <span class="comment"># 返回首字母大写的字符串</span></span><br></pre></td></tr></table></figure><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"Liujinlong"</span></span><br><span class="line">print(<span class="string">"My name is %s"</span> % name)</span><br><span class="line">pi = <span class="number">3.14</span></span><br><span class="line">print(<span class="string">"Pi is %.2f"</span> % pi)</span><br><span class="line"></span><br><span class="line">str1 = <span class="string">"Hello"</span></span><br><span class="line">str2 = <span class="string">"World"</span></span><br><span class="line">print(<span class="string">"%s %s"</span> % (str1, str2))</span><br><span class="line"></span><br><span class="line">msg = &#123;<span class="string">"action"</span>: str1, <span class="string">"name"</span>: str2&#125;</span><br><span class="line">print(<span class="string">"%(action)s %(name)s"</span> % msg)</span><br><span class="line">print(<span class="string">"&#123;0&#125; &#123;1&#125;"</span>.format(str1, str2))</span><br><span class="line">print(<span class="string">"&#123;action&#125; &#123;name&#125;"</span>.format(**msg)) <span class="comment"># 双星号相当于解包字典</span></span><br></pre></td></tr></table></figure><h2 id="Python-中的列表"><a href="#Python-中的列表" class="headerlink" title="Python 中的列表"></a>Python 中的列表</h2><h3 id="列表的定义"><a href="#列表的定义" class="headerlink" title="列表的定义"></a>列表的定义</h3><ul><li>列表中元素的类型是任意的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="string">"ljl"</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="keyword">True</span>]</span><br></pre></td></tr></table></figure><h3 id="列表的操作"><a href="#列表的操作" class="headerlink" title="列表的操作"></a>列表的操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">l2 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line">print(l1 + l2)  <span class="comment"># 合并</span></span><br><span class="line">print(l1 * <span class="number">2</span>)  <span class="comment"># 重复</span></span><br><span class="line">print(l1[<span class="number">2</span>])  <span class="comment"># 获取</span></span><br><span class="line">print(l1[<span class="number">2</span>: <span class="number">4</span>])  <span class="comment"># 切片操作</span></span><br><span class="line">l1.append(<span class="number">3</span>)  <span class="comment"># 添加元素</span></span><br><span class="line">print(l1.count(<span class="number">3</span>))  <span class="comment"># 列表中某个元素的个数</span></span><br><span class="line">print(len(l1))  <span class="comment"># 列表长度</span></span><br><span class="line">print(l1.index(<span class="number">3</span>))  <span class="comment"># 某个元素在列表中的位置，未找到返回错误</span></span><br><span class="line">l1.extend(l2)  <span class="comment"># 将l2的所有元素添加到l1中</span></span><br><span class="line">print(l1)</span><br><span class="line">l1.insert(<span class="number">11</span>, <span class="number">2</span>)  <span class="comment"># 在指定位置添加元素</span></span><br><span class="line">print(l1)</span><br><span class="line">l1.pop()  <span class="comment"># 删除列表末尾元素</span></span><br><span class="line">print(l1)</span><br><span class="line">l1.remove(<span class="string">'a'</span>)  <span class="comment"># 删除指定元素</span></span><br><span class="line">print(l1)</span><br><span class="line">l1.reverse()  <span class="comment"># 逆序列表</span></span><br><span class="line">print(l1)</span><br><span class="line">l1 = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>]</span><br><span class="line">l1.sort()  <span class="comment"># 列表排序</span></span><br><span class="line">print(l1)</span><br></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><ul><li>列表与元组的区别<ul><li>列表时可变的，元组不可变</li><li>元组可以作为字典的 key，但是列表不行</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="keyword">True</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)[<span class="number">1</span>]</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)[<span class="number">0</span>:<span class="number">3</span>] <span class="comment"># 得到一个元素</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) + (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>) <span class="comment"># (1, 2, 3, 3, 3, 3)</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) * <span class="number">3</span> <span class="comment"># (1, 2, 3, 1, 2, 3, 1, 2, 3)</span></span><br><span class="line">type((<span class="number">1</span>)) <span class="comment"># int，这是因为内层括被解析成了数学运算的括号</span></span><br><span class="line">type((<span class="number">1</span>,)) <span class="comment"># tuple</span></span><br><span class="line">(,) <span class="comment"># 空元组</span></span><br></pre></td></tr></table></figure><h3 id="序列的总结"><a href="#序列的总结" class="headerlink" title="序列的总结"></a>序列的总结</h3><ul><li>str list tuple 都属于序列</li><li>每个元素都会分配一个序号</li><li>都支持切片操作</li><li>支持包含操作：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'or'</span> <span class="keyword">in</span> <span class="string">'Hello world'</span>)  <span class="comment"># True</span></span><br><span class="line">print(<span class="number">1</span> <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># True</span></span><br><span class="line">print(<span class="string">'a'</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="number">12</span>))  <span class="comment"># False</span></span><br></pre></td></tr></table></figure><ul><li>长度：<code>len([1, 2, 3])</code></li><li>最大最小：<code>max([1, 2, 3]), min([1, 2, 3])</code></li></ul><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul><li>集合 Set 的特点<ul><li>元素是无序的</li><li>元素是不重复的</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">len(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;) <span class="comment"># 3</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment"># True</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment"># True</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; - &#123;<span class="number">3</span>, <span class="number">4</span>&#125; <span class="comment"># 求两个集合的差集</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; &amp; &#123;<span class="number">3</span>, <span class="number">4</span>&#125; <span class="comment"># 求两个集合的交集</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; | &#123;<span class="number">3</span>, <span class="number">4</span>&#125; <span class="comment"># 求两个集合的并集</span></span><br><span class="line">set() <span class="comment"># 空集合</span></span><br></pre></td></tr></table></figure><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul><li>Key 不能重复</li><li>Key 必须是不可变的类型<ul><li>列表是可变的，所以不能作为字典的 key</li><li>int，元组，bool 都是不可变的</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict1 = &#123;key1: value1, kye2: value2&#125;</span><br><span class="line">dict() <span class="comment"># 空字典</span></span><br></pre></td></tr></table></figure><h2 id="变量和运算符"><a href="#变量和运算符" class="headerlink" title="变量和运算符"></a>变量和运算符</h2><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><ul><li>Python 中的变量就是一个值的别名</li><li>原则：变量名要有意义</li></ul><h3 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h3><ul><li>变量名的首字符不能是数字</li><li>只能包含字母，数字，下划线</li><li>系统的关键字不能用作变量名，非系统保留关键字，但是标准库函数的，也不要使用，例如：type</li><li>变量区分大小写</li></ul><h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><ul><li>值类型：int, str, tuple</li><li>引用类型：list, set, dict</li><li><code>id()</code>: 显示变量内存地址</li></ul><h3 id="list-与-tuple"><a href="#list-与-tuple" class="headerlink" title="list 与 tuple"></a>list 与 tuple</h3><ul><li>list 是可改变的</li><li>tuple 是不可改变的</li><li>使用原则：能用元组尽量用元组，因为元组不可改变，更为安全</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">11</span> <span class="comment"># OK</span></span><br><span class="line">b = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">11</span> <span class="comment"># error</span></span><br></pre></td></tr></table></figure><h3 id="运算符号"><a href="#运算符号" class="headerlink" title="运算符号"></a>运算符号</h3><ul><li>数学运算符：<code>+-*/</code></li><li>整除：<code>//</code></li><li>余数：<code>%</code></li><li>乘方：<code>**</code> 例如，<code>2**2 = 4</code></li><li>赋值运算符：<code>=, +=, -=, *=, /=, %=, **=, //=</code></li><li>比较运算符：<code>==, !=, &gt;=, &gt;, &lt;=, &lt;</code><ul><li>字符串，bool 都可以比较，字符串转为 ascii 码进行比较，bool 则是 True 转为 1，False 转为 0</li><li>比较返回一个 bool 值</li><li>列表，元组都可以比较，比较的规则是一个一个元素进行比较，直到比较出结果</li></ul></li><li>逻辑运算符：<code>and, or, not</code><ul><li>非 Bool 类型也可以进行逻辑运算，规则是将非 Bool 类型先转为 Bool 类型再进行计算</li><li>int, float 转为 bool，0 为 False，非 0 为 True</li><li>字符串转为 bool，空字符串为 False，非空字符串为 True</li><li>列表转为 bool，空列表为 False，非空列表为 True</li><li>元组，set，dict 与列表一样</li><li>举例：<ul><li><code>2 and 1 # 1</code></li><li><code>1 and 2 # 2</code></li><li><code>1 or 2 # 1</code></li><li><code>0 or 1 # 1</code></li><li>返回的值符合就近原则，例如<code>2 and 1</code>，更具左边的元素 2 无法判断出结果，读取 1 后，可以判断出结构，所有返回 1，<code>1 or 2</code>根据左边的元素 1 就直接可以判断出表达式的值，所以直接返回 1</li></ul></li></ul></li><li>成员运算符：<code>in, not in</code><ul><li>一个元素是否在另外的一组元素中</li><li>返回 bool 类型</li><li>可以作用于：列表，字符串，元组，set，dict</li><li>字典判断的是 key</li></ul></li><li>身份运算符：is, not is<ul><li>比较的是两个变量的内存地址是否相等</li><li>对象的三个特征：值，类型，身份</li><li>判断类型 type(a): <code>type(a) == int</code></li><li>推荐使用 isinstance()方法进行类型判断，例如：<code>isinstance(a, int), isinstance(a, (int, float, str))</code></li></ul></li><li>位运算符：&amp;, |, ^, ~, &lt;&lt;, &gt;&gt;</li></ul><p>特殊的地方：</p><ul><li>Python 没有自增，自减操作</li></ul><h2 id="分支，循环，条件，枚举"><a href="#分支，循环，条件，枚举" class="headerlink" title="分支，循环，条件，枚举"></a>分支，循环，条件，枚举</h2><h3 id="什么是表达式"><a href="#什么是表达式" class="headerlink" title="什么是表达式"></a>什么是表达式</h3><ul><li>表达式是运算符和操作数所构成的序列</li></ul><h3 id="表达式优先级"><a href="#表达式优先级" class="headerlink" title="表达式优先级"></a>表达式优先级</h3><ul><li>and 的优先级大于 or，not &gt; and &gt; or</li><li>解析表达式的顺序：<ul><li>相同优先级从左向右，左结合</li><li>使用括号改变优先级</li><li>赋值运算符是右结合</li></ul></li></ul><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><ul><li>if, if-else</li><li>pass 空语句</li><li>while 语句， while-else（循环退出时，执行 else）</li><li>for: 遍历集合，序列，字典，for-else(遍历完成，执行 else)</li><li>break：跳出循环，从 break 退出循环，不会执行 else 语句</li><li>continue: 跳过本次循环</li><li>range 函数，第一个参数为起始位置，第二个参数为序列元素个数，第三个参数为步长</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> a &lt; <span class="number">10</span>:</span><br><span class="line">    print(a)</span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Over'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">    print(i)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Over'</span>)  <span class="comment"># Over不会打印，因为循环break了</span></span><br></pre></td></tr></table></figure><h2 id="包，模块，类，函数与变量"><a href="#包，模块，类，函数与变量" class="headerlink" title="包，模块，类，函数与变量"></a>包，模块，类，函数与变量</h2><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><ul><li>一个文件夹就是一个包，包名就是文件名</li><li>子包：文件夹里还有一个文件夹</li><li>文件夹里必须有一个<code>__init__.py</code>文件</li></ul><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul><li>一个文件就是一个模块，模块名就是文件名</li><li>不同包的相同模块在引用是使用：<code>包名.模块名</code></li><li><code>__init__.py</code>文件也是一个模块</li></ul><h3 id="导入另外一个模块"><a href="#导入另外一个模块" class="headerlink" title="导入另外一个模块"></a>导入另外一个模块</h3><p>导入一个模块有两种方法，import 和 from-import</p><h4 id="import-导入"><a href="#import-导入" class="headerlink" title="import 导入"></a>import 导入</h4><ul><li>语法：<code>import package1</code></li><li>import 导入的是一个模块，使用模块里的变量名时需要带上模块名，例如<code>package1.a</code></li><li>可以使用 as 关键字给模块起一个别名</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test</span><br><span class="line">print(test.a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> package.modual <span class="keyword">as</span> p1</span><br><span class="line">print(p1.a)</span><br></pre></td></tr></table></figure><h4 id="from-import-导入"><a href="#from-import-导入" class="headerlink" title="from-import 导入"></a>from-import 导入</h4><ul><li>语法：<code>from module import a</code></li><li>from-input 可以直接导入变量，例如<code>from package.module import a</code></li><li>from-input 可以导入模块<code>from package import module</code></li><li>使用<em>引入所有变量：`from test import </em>`</li><li>指定使用*时模块可导出的变量：使用内置变量<code>__all__</code></li><li>引入多个变量：<code>from test import a, b, c</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> a</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> *</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">'a'</span>, <span class="string">'c'</span>] <span class="comment"># 指定使用*导入是，只导入a和c两个变量</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line">c = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> *</span><br><span class="line">print(a)</span><br><span class="line">print(c)</span><br><span class="line">print(b) <span class="comment"># ERROR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> b</span><br><span class="line">print(b) <span class="comment"># OK</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入多个变量换行</span></span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> a, b, c, d,\</span><br><span class="line">e, f, g</span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> (a, b, c, d,</span><br><span class="line">e, f, g)</span><br></pre></td></tr></table></figure><h3 id="input-py文件"><a href="#input-py文件" class="headerlink" title="__input__.py文件"></a><code>__input__.py</code>文件</h3><ul><li>导入包或者包内的某个模块时，<code>__init__.py</code>会被自动执行，可以做一些初始化的工作</li><li><code>__init__.py</code> 的应用场景：<ul><li>决定哪些模块可以被导出</li><li>批量导入某些模块，在使用包是不需要再次导入</li><li>做一些包的初始化工作</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __init__.py 包名：t</span></span><br><span class="line">__all__ = [<span class="string">'module1'</span>, <span class="string">'module3'</span>] <span class="comment"># 只有module1和module2两个模块可以被导出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量导入</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="comment"># other.py</span></span><br><span class="line"><span class="keyword">import</span> t</span><br><span class="line">print(t.sys.path)</span><br></pre></td></tr></table></figure><h3 id="包和模块的几个常见问题"><a href="#包和模块的几个常见问题" class="headerlink" title="包和模块的几个常见问题"></a>包和模块的几个常见问题</h3><ul><li>包和模块是不会重复导入的</li><li>避免循环导入，即 A 模块导入 B 模块，B 模块又导入 A 模块，这样编译器会报错</li><li>导入模块时就会执行模块里的代码，但只会执行一次</li></ul><h3 id="模块里的变量"><a href="#模块里的变量" class="headerlink" title="模块里的变量"></a>模块里的变量</h3><p>可以使用 dir()可以打印出模块里的所有变量，<code>dic(module)</code>打印模块中所有的变量</p><ul><li><code>__name__</code>: 模块的完整名称，包括包名<code>package.module</code></li><li><code>__package__</code>: 模块所属的包名</li><li><code>__file__</code>: 模块文件的完整路径</li><li><code>__doc__</code>: 模块的注释</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># module1</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">This is doc</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">print(__name__)</span><br><span class="line">print(__file__)</span><br><span class="line">print(__package__)</span><br><span class="line">print(__doc__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment">#package.module</span></span><br><span class="line"><span class="comment">#/Users/liujinlong/Documents/Study/Python/package/module.py</span></span><br><span class="line"><span class="comment">#package</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#This is doc</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><p>如果一个模块被当成应用程序执行的入口(直接通过<code>pyton xxx.py</code>执行)，则上面的几个变量就会变。</p><ul><li><code>__name__</code>变为<code>__main__</code></li><li><code>__package__</code>为空</li><li><code>__file__</code>为是执行路径与模块文件名的相对路径，与执行路径有关</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"__name__ :"</span> + (__name__ <span class="keyword">or</span> <span class="string">"None"</span>))</span><br><span class="line">print(<span class="string">"__package__:"</span> + (__package__ <span class="keyword">or</span> <span class="string">"None"</span>))</span><br><span class="line">print(<span class="string">'__doc__:'</span> + __doc__)</span><br><span class="line">print(<span class="string">'__file__: '</span> + __file__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="comment">#__name__ :__main__</span></span><br><span class="line"><span class="comment">#__package__:None</span></span><br><span class="line"><span class="comment">#__doc__:</span></span><br><span class="line"><span class="comment">#this is doc</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#__file__: test2.py</span></span><br></pre></td></tr></table></figure><h3 id="name-的应用"><a href="#name-的应用" class="headerlink" title="__name__的应用"></a><code>__name__</code>的应用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>上面的语句是标明的 Python 文件既可以作为模块，也可以作为 app 的入口文件</p><h3 id="相对导入和绝对导入"><a href="#相对导入和绝对导入" class="headerlink" title="相对导入和绝对导入"></a>相对导入和绝对导入</h3><ul><li>顶级包和入口文件有关，入口文件所在的文件夹并不是顶级包</li><li>绝对导入：从顶级包开始导入 <code>import package1.package2.module</code>或<code>from package1.package2 import module1</code></li><li>相对导入：<code>from .m3 import *</code>，相对导入只能用于<code>from-import</code><ul><li>入口文件不能用相对导入，因为<code>__main__</code>这个模块是不存在的，除非使用<code>python -m</code></li><li>.当前文件夹</li><li>..上一层文件夹</li><li>…上上层文件夹</li></ul></li><li>注意事项：与入口文件同级目录下不要再有其他模块</li></ul><p>示例，如下图目录结构：</p><p><img src="http://pecqz8zqd.bkt.clouddn.com/fb3913861d028acf0475d26ce685031e.png" alt="2"></p><p>要在<code>main.py</code>中引入其他模块，不能使用相对导入，只能使用绝对导入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">import</span> package1.module1_1</span><br><span class="line"><span class="keyword">import</span> package1.package1_1.module1_1_1 <span class="keyword">as</span> m1_1_1</span><br><span class="line"><span class="keyword">from</span> package2.package2_1 <span class="keyword">import</span> module2_1_1</span><br><span class="line"></span><br><span class="line">m1_1_1.test() <span class="comment"># test是定义在module1_1_1中的一个方法</span></span><br></pre></td></tr></table></figure><p>在<code>module1_1_2.py</code>中导入其他模块可以使用相对导入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> module1_1_1</span><br><span class="line"><span class="keyword">from</span> ..module1_1 <span class="keyword">import</span> test1_1</span><br><span class="line"><span class="keyword">from</span> ..package1_2 <span class="keyword">import</span> module1_2_1</span><br><span class="line"><span class="keyword">import</span> package2.package2_1.module2_1_1 <span class="keyword">as</span> m211  <span class="comment"># 这里只能用绝对导入</span></span><br><span class="line"></span><br><span class="line">test1_1()  <span class="comment"># test1_1是module1_1.py里的一个方法</span></span><br><span class="line">module1_2_1.test1_2_1()  <span class="comment"># test1_2_1是module1_2_1.py里的一个方法</span></span><br><span class="line">m211.test2_1_1()  <span class="comment"># test2_1_1是module2_1_1.py里的一个方法</span></span><br></pre></td></tr></table></figure><p>上面要注意的一点是，<code>package1</code>中的模块引用<code>package2</code>中的模块时，只能用绝对导入，因为<code>package1</code>和<code>package2</code>都是和入口文件<code>main.py</code>同级的</p><p>未完待续！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;&lt;h3 id=&quot;除，整除&quot;&gt;&lt;a href=&quot;#除，整除&quot; class=&quot;headerlink&quot; title=&quot;除，整除&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Python" scheme="http://liujinlongxa.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://liujinlongxa.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>通过XCode查看APP的沙盒内容</title>
    <link href="http://liujinlongxa.com/2017/06/12/%E9%80%9A%E8%BF%87XCode%E6%9F%A5%E7%9C%8BAPP%E7%9A%84%E6%B2%99%E7%9B%92%E5%86%85%E5%AE%B9/"/>
    <id>http://liujinlongxa.com/2017/06/12/通过XCode查看APP的沙盒内容/</id>
    <published>2017-06-12T03:24:36.000Z</published>
    <updated>2017-06-12T03:42:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时我们在开发APP过程中可能需要查看沙盒的内容，对于模拟器来说已经有一个很好用的工具<a href="https://simpholders.com/" target="_blank" rel="noopener">Simpholders</a>，如果是真机该如何查看沙盒的内容呢？</p><p>其实XCode已经自带了这个功能，下面就介绍一下通过XCode查看APP沙盒内容的方法。</p><p>首先，打开XCode，然后连接真机，依次点击Window-&gt;Devices（快捷键Shift+Cmd+2)，出现如下界面，在”Installed App”列表里就会出现你调试过的APP，如下图：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/03a71dd7225206a6f3546fbdb09208b8.png" alt="1"></p><p>然后选中你要查看沙盒的APP，然后点击下发的齿轮按钮，选择”Download Container…”</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/16142a7b444769ef7137725fe12203df.png" alt="2"></p><p>然后选择一个文件夹保存下载的文件。下载完成后就会有一个以xcappdata为后缀的文件，然后右键点击”查看包内容”就可以看到APP沙盒里的内容了。</p><p>以上就是通过XCode查看APP沙盒内容的方法，这个方法只能查看你通过XCode运行安装的APP的沙盒，其他的APP是不能查看的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时我们在开发APP过程中可能需要查看沙盒的内容，对于模拟器来说已经有一个很好用的工具&lt;a href=&quot;https://simpholders.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Simpholders&lt;/a&gt;，如果是真机该如何查看沙盒
      
    
    </summary>
    
      <category term="iOS Tips" scheme="http://liujinlongxa.com/categories/iOS-Tips/"/>
    
    
      <category term="沙盒" scheme="http://liujinlongxa.com/tags/%E6%B2%99%E7%9B%92/"/>
    
  </entry>
  
  <entry>
    <title>修改模态界面的转场动画</title>
    <link href="http://liujinlongxa.com/2017/05/27/%E4%BF%AE%E6%94%B9%E6%A8%A1%E6%80%81%E7%95%8C%E9%9D%A2%E7%9A%84%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/"/>
    <id>http://liujinlongxa.com/2017/05/27/修改模态界面的转场动画/</id>
    <published>2017-05-27T01:21:38.000Z</published>
    <updated>2017-05-27T02:14:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>模态（Modal）界面弹出动画一般是从下往上推出，如果要修改转场动画，可以设置modalTransitionStyle属性，代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ViewController *vc = [[ViewController alloc] init];</span><br><span class="line">vc.modalTransitionStyle = <span class="built_in">UIModalTransitionStyleFlipHorizontal</span>;</span><br><span class="line">[<span class="keyword">self</span> presentViewController:vc animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>modalTransitionStyle是一个枚举，有以下四个值，分别代表四种不同的转场效果，</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIModalTransitionStyleCoverVertical</span> = <span class="number">0</span>,</span><br><span class="line"><span class="built_in">UIModalTransitionStyleFlipHorizontal</span>,</span><br><span class="line"><span class="built_in">UIModalTransitionStyleCrossDissolve</span>,</span><br><span class="line"><span class="built_in">UIModalTransitionStylePartialCurl</span></span><br></pre></td></tr></table></figure><p>如果上面四种效果都不能满足你的需求，还可以使用CATransition进一步定制你的转场动画，代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ViewController *vc = [[ViewController alloc] init];</span><br><span class="line"><span class="built_in">CATransition</span> *transition = [<span class="built_in">CATransition</span> animation];</span><br><span class="line">transition.type = kCATransitionMoveIn;</span><br><span class="line">transition.subtype = kCATransitionFromLeft;</span><br><span class="line">transition.duration = <span class="number">3.0</span>;</span><br><span class="line">transition.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseIn];</span><br><span class="line">[<span class="keyword">self</span>.view.window.layer addAnimation:transition forKey:<span class="string">@"tran"</span>];</span><br><span class="line">[<span class="keyword">self</span> presentViewController:vc animated:<span class="literal">NO</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>使用CATransition的type和subtype两个属性可以定制16中转场动画，同时CATransition还可以设置转场持续的时间（duration）以及动画速度控制函数（timingFunction）等属性。注意，一定要把动画加载控制器view的window上。</p><p>完成代码，包括present和dismiss</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ViewController *vc = [[ViewController alloc] init];</span><br><span class="line"><span class="built_in">CATransition</span> *presentTransition = [<span class="built_in">CATransition</span> animation];</span><br><span class="line">presentTransition.type = kCATransitionMoveIn;</span><br><span class="line">presentTransition.subtype = kCATransitionFromLeft;</span><br><span class="line">presentTransition.duration = <span class="number">3.0</span>;</span><br><span class="line">presentTransition.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseIn];</span><br><span class="line">[<span class="keyword">self</span>.view.window.layer addAnimation:presentTransition forKey:<span class="string">@"presentTransition"</span>];</span><br><span class="line">[<span class="keyword">self</span> presentViewController:vc animated:<span class="literal">NO</span> completion:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">CATransition</span> *dismissTransition = [<span class="built_in">CATransition</span> animation];</span><br><span class="line">dismissTransition.type = kCATransitionMoveIn;</span><br><span class="line">dismissTransition.subtype = kCATransitionFromRight;</span><br><span class="line">dismissTransition.duration = <span class="number">3.0</span>;</span><br><span class="line">dismissTransition.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseIn];</span><br><span class="line">[<span class="keyword">self</span>.view.window.layer addAnimation:dismissTransition forKey:<span class="string">@"dismissTransition"</span>];</span><br><span class="line">[<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">NO</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>如果CATransition的16种转场动画还不能满足你的需求，iOS7之后，可以使用UIViewControllerAnimatedTransitioning协议完全自定义转场动画，还能实现手势控制转动画。具体代码可以参考我写的这个<a href="https://github.com/liujinlongxa/AnimationTransition" target="_blank" rel="noopener">Demo</a>。</p><p>以上就是我对模态界面转场动画的一个总结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;模态（Modal）界面弹出动画一般是从下往上推出，如果要修改转场动画，可以设置modalTransitionStyle属性，代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
      <category term="iOS开发" scheme="http://liujinlongxa.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="转场动画" scheme="http://liujinlongxa.com/tags/%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/"/>
    
      <category term="CATransition" scheme="http://liujinlongxa.com/tags/CATransition/"/>
    
  </entry>
  
  <entry>
    <title>如何获取分享h5页面时的缩略图</title>
    <link href="http://liujinlongxa.com/2017/03/27/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%88%86%E4%BA%ABh5%E9%A1%B5%E9%9D%A2%E6%97%B6%E7%9A%84%E7%BC%A9%E7%95%A5%E5%9B%BE/"/>
    <id>http://liujinlongxa.com/2017/03/27/如何获取分享h5页面时的缩略图/</id>
    <published>2017-03-27T08:37:13.000Z</published>
    <updated>2017-03-27T09:04:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近产品提了一个需求，在分享应用内h5页面时，不能像以前一样，使用应用的图标作为分享的缩略图，要使用H5页面内的一张图片作为缩略图进行分享。</p><p>我调查了一下市面上一些常见应用的做法，基本上可以总结出三种做法：</p><h3 id="第一种方法：H5页面内指定分享图片地址"><a href="#第一种方法：H5页面内指定分享图片地址" class="headerlink" title="第一种方法：H5页面内指定分享图片地址"></a>第一种方法：H5页面内指定分享图片地址</h3><p>比较常见的做法是，在h5页面内定义一个JS的全局变量或者json，指定分享用的图片地址，APP内，通过JavaScriptCore获取全局变量，然后用于分享。</p><p>具体这样做的应用有：Keep，哔哩哔哩（部分页面），京东（部分页面）</p><p>还有一种是把分享的信息定义在页面头部(head标签里)，QQ音乐就是这样做的。</p><h3 id="第二种做法：固定分享页面内第一张符合条件的图片"><a href="#第二种做法：固定分享页面内第一张符合条件的图片" class="headerlink" title="第二种做法：固定分享页面内第一张符合条件的图片"></a>第二种做法：固定分享页面内第一张符合条件的图片</h3><p>如果H5页面是第三方提供，就不能通过第一种方法去指定分享内容了。这种情况下，大多数应用的做法就是取页面内第一张符合大小的图片作为分享图片。</p><p>这里我写了一个JS函数，只要把这个函数注入到H5页面中，APP就可以通过调用这个方法来获取到第一张符合大小的图片。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getImage</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> images = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; images.length; index++) &#123;</span><br><span class="line">        <span class="keyword">var</span> img = images[index];</span><br><span class="line">        <span class="keyword">var</span> imgData = <span class="keyword">new</span> Image();</span><br><span class="line">        imgData.src = img.src;</span><br><span class="line">        <span class="keyword">if</span> (imgData.width &gt; width &amp;&amp; imgData.height &gt; height) &#123;</span><br><span class="line">            <span class="keyword">return</span> imgData.src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体这样做的应用有：微信，今日头条</p><h3 id="第三种做法：对页面进行截图，使用截图进行分享"><a href="#第三种做法：对页面进行截图，使用截图进行分享" class="headerlink" title="第三种做法：对页面进行截图，使用截图进行分享"></a>第三种做法：对页面进行截图，使用截图进行分享</h3><p>有些应用在分享时会对H5页面进行截图，然后把截图作为分享的内容。</p><p>具体这样做的应用有：微博，UC浏览器</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是三种获取H5页面内分享缩略图的三种策略，我们最终选择的是第一种和第二种相结合的方式，如果页面内指定了分享图片，则使用，否则获取页面内第一张符合条件的图片进行分享。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近产品提了一个需求，在分享应用内h5页面时，不能像以前一样，使用应用的图标作为分享的缩略图，要使用H5页面内的一张图片作为缩略图进行分享。&lt;/p&gt;
&lt;p&gt;我调查了一下市面上一些常见应用的做法，基本上可以总结出三种做法：&lt;/p&gt;
&lt;h3 id=&quot;第一种方法：H5页面内指定分
      
    
    </summary>
    
      <category term="iOS开发" scheme="http://liujinlongxa.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="分享" scheme="http://liujinlongxa.com/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>深入理解git merge和git rebase（续）</title>
    <link href="http://liujinlongxa.com/2017/03/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3git-merge%E5%92%8Cgit-rebase%EF%BC%88%E7%BB%AD%EF%BC%89/"/>
    <id>http://liujinlongxa.com/2017/03/06/深入理解git-merge和git-rebase（续）/</id>
    <published>2017-03-06T01:34:43.000Z</published>
    <updated>2017-03-06T03:50:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文接上一篇，主要讲解一下git rebase的用法和使用中注意的事项。</p><h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>git rebase，也叫做变基，也是Git种一种合并代码的手段，与git merge不同的是，rebase是直接将一个分支从他们的共同父节点开始后的所有Commit依次合并到另外一个分支上。如下图：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/e3bdbc7fff28676ccefdcb16f4d43095.png" alt="1"></p><p>两个分支develop和master，如果通过命令<code>git merge</code>将develop分支合并到master分支，Git会将‘C’，‘3’以及两个分支的共同父节点‘B’进行三路合并，合并完成后生成一个新节点，如下图：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/ce919bb1921ee5c302baafbb0f45785f.png" alt="2"></p><p>如果<code>git rebase</code>将develop分支变基到master分支上，Git会将develop分支上的所有commit(1,2,3)依次合并到master，每一次合并都会生成一个新的提交(如下图1’,2’,3’)，合并完成后，如下图：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/0478f567c5748186a200cd4da8b5ddd8.png" alt="3"></p><p>可以明显的看到，使用<code>git rebase</code>，分支线依然保持为一条，分支线看起来也没有那么乱，这也是<code>git rebase</code>相对于<code>git merge</code>的一个优点，但是另一方面，<code>git rebase</code>在合并每一个提交并生成一个新的提交时，会改写原来提交的提交时间（不会改写提交人），而且<code>git rebase</code>也没有留下合并的痕迹，可追溯性没那么强。</p><h3 id="为什么那么多冲突"><a href="#为什么那么多冲突" class="headerlink" title="为什么那么多冲突"></a>为什么那么多冲突</h3><p>在使用<code>git rebase</code>的过程中经常会遇到这种情况，在执行的<code>git rebase</code>操作后，遇到了一个冲突，修改冲突后执行<code>git rebase --continue</code>，然后又来一个冲突，冲突一个接一个，而且有时候同一个冲突会出现好几次。</p><p>其实，这是由rebase的原理造成的，Git在合并每一个Commit时都会判断是否有冲突，如下图：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/90ff7dd4f79dddc65656820254dba48b.png" alt="4"></p><p>两个分支develop和master以及他们各自的文件内容，现在要将develop变基到master上，Git会先将develop的第一个commit和master分支的最新提交合并，合并后如下：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/31c92a8c54e271fb69053a22c984c6dd.png" alt="5"></p><p>会报一个冲突，解决完冲突后，执行<code>git rebase --continue</code>，根据冲突不同的解决方案，可能会与不同的结果，如下图：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/74efc09f8e231d078914a36f5223e289.png" alt="6"></p><p>上图中的两种冲突解决方案，在执行<code>git rebase --continue</code>后，依然再会报一个冲突，应为在合并develop的第二个提交时，依然有冲突。下面的解决方案则不会造成再次冲突，因为这种解决方案是完全用develop分支覆盖了master分支，如下图：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/510fa8570fd012eb1723d6c521eb5cc6.png" alt="7"></p><p>以上就是造成<code>git rebase</code>冲突太多的具体原因。</p><h3 id="有那么点用的rerere"><a href="#有那么点用的rerere" class="headerlink" title="有那么点用的rerere"></a>有那么点用的rerere</h3><p>冲突太多怎么办，Git提供了一个辅助工具<code>git rerere</code>命令，具体用法可以参考<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-Rerere" target="_blank" rel="noopener">git rerere</a>。rerere命令能够记住解决一个冲突的方法，这样在下一次看到相同冲突时，Git 可以为你自动地解决它。</p><p>那么rerere能够避免<code>git rebase</code>带来的冲突吗，答案是否定的。因为rerere在判断两个冲突是否为相同冲突是根据冲突体的两部分是否完全一样来进行的，就上面的例子而言，不管是哪种冲突解决方案，第一次和第二次冲突的冲突体都不完全一样，因此rerere都不会自动帮我们修复。</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/b80ef2ec61407d7a737a0997da6c960d.png" alt="8"></p><p>而且，rerere命令也会记住错误的冲突解决方案，下次遇到相同的冲突时会直接应用错误的方案。不过你可以使用<code>git rerere forget &lt;pathspec&gt;</code>命令来删除Git记住的冲突解决方案。</p><p>说了这么多，那rerere命令到底有什么用呢？</p><p><code>git rerere</code>命令为我们提供了一种减少冲突的方案：当你要保证一个长期分支会干净地合并，但是又不想要一串中间的合并提交。 将rerere功能打开后偶尔合并，解决冲突，然后返回到合并前。 如果你持续这样做，那么最终的合并会很容易，因为rerere可以为你自动做所有的事情。<code>git rerere</code>也可以将冲突的解决方案共享给项目组的其他成员。</p><p>所以说rerere命令还有一点用的，不过他并不能彻底解决冲突多的问题，减少冲突还是需要我们在平时使用时规范git的使用方法，使用统一的git工作流。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本来打算写一篇的，但是因为太长了，所以分为两篇来写。由于写的比较仓促，文中如果有什么纰漏，欢迎指出。</p><p>参考资料：<br><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Pro Git</a><br><a href="http://stackoverflow.com/questions/13825079/why-do-i-have-to-resolve-the-same-conflict-over-and-over" target="_blank" rel="noopener">Why do I have to resolve the same conflict over and over?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文接上一篇，主要讲解一下git rebase的用法和使用中注意的事项。&lt;/p&gt;
&lt;h2 id=&quot;git-rebase&quot;&gt;&lt;a href=&quot;#git-rebase&quot; class=&quot;headerlink&quot; title=&quot;git rebase&quot;&gt;&lt;/a&gt;git rebase&lt;/
      
    
    </summary>
    
      <category term="Git" scheme="http://liujinlongxa.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://liujinlongxa.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>深入理解git merge和git rebase</title>
    <link href="http://liujinlongxa.com/2017/03/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3git-merge%E5%92%8Cgit-rebase/"/>
    <id>http://liujinlongxa.com/2017/03/01/深入理解git-merge和git-rebase/</id>
    <published>2017-03-01T07:08:21.000Z</published>
    <updated>2017-03-06T02:37:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>git merge</code>和<code>git rebase</code>是我们平时在使用Git过程中用到比较多的两个命令。本文将主要介绍这个两个命令的基本用法以及使用中应该注意的事项。</p><h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><h3 id="不同的合并方式"><a href="#不同的合并方式" class="headerlink" title="不同的合并方式"></a>不同的合并方式</h3><p>顾名思义，<code>git merge</code>是用来将一个分支的代码合并到另一个分支。如下图，将develop分支上的代码合并到master分支上。</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/dafea7a6a7e2ce161b7b941ad4474186.png" alt="1"></p><p>上图中有一个<code>Fast-forward</code>字样，这是Git的一种合并方式。</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/31c51a26b1165b47797425e5d34a04a4.png" alt="2"></p><p>如上图，在master分支的B点时牵出一个develop分支，develop分支又有了3个新的提交1，2，3，而master分支此时没有新的提交，这是如果合并的话，develop分支不用动，master只用把分支的头指针指向develop的最新的一个提交3即可。合并后的结果如下图：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/44379a35e3a385da59d1d996efd017bb.png" alt="3"></p><p>这个合并方式看似把两个分支合并了，实际上并没有真正进行合并操作，也没有留下合并的操作。默认<code>git merge</code>是采用<code>Fast-forward</code>方式进行合并的，如果不想采用这种方式，可以在命令后面加入<code>--no-ff</code>选项，如下：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/161174b53c54146aa465eacf41140787.png" alt="4"></p><p>不使用<code>Fast-forward</code>的方式进行合并，Git会为合并生成一个新的提交，合并后的结果如下图：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/091081cb40b5eedbc5dc4ab2c8e4e13e.png" alt="5"></p><p>Commit C即是Git自动生成的合并提交。一般情况下我们在合并代码时都会加上<code>--no-ff</code>，这样可以更清晰的看见合并操作。</p><h3 id="一个不大不小的坑"><a href="#一个不大不小的坑" class="headerlink" title="一个不大不小的坑"></a>一个不大不小的坑</h3><p>如下图：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/e92aed55a7593922b525c2723894b202.png" alt="6"></p><p> 在牵出develop分支后，master分支又有了新的提交C，这时候如果把develop分支合并到master，就不能简单的通过移动master分支头指针来进行了，这时候默认执行的是<strong>recursive</strong>(递归)的策略进行合并的，这种策略下，Git会对两个分支的头结点（C与3）以及他们的共同父节点（B）进行三路合并，这种情况下就可能出现代码冲突。</p><p> 而且Git在合并两个分支时，并不会根据Commit的提交时间来判断哪个分支的代码更新，这就可能造成一个隐藏的问题：</p><p> 想象一下这种场景，一个团队内分为两个小组分别开发A和B两个功能版本，A版本的开发人员修改了某个文件（假定是file1），B版本的的开发人员发现他也要对file1做同样的修改才能继续开发，于是他对file1做了同样的修改（或者使用cherry-pick把A版本的相应的commit拉过来）。过了一段时间，A版本的开发人员发现他以前对file1的修改有问题，于是又把file1改了回去，而这时候B版本的开发人员并没有做同样的修改。这样，将来A版本和B版本合并到主干分支后，B版本的代码就会覆盖A的修改，于是错误的代码又被合并到了主干分支上。下面就是这个过程的示意图：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/51b92d9f3934ffa53a1f2c9770a9895f.png" alt="7"></p><p>如图，序号1，2，3表示的是Commit的提交顺序，FeatureA分支在commit 2上把文件内容改为了<code>bbb111</code>, FeatureB分支把文件内容改为了<code>bbb222</code>，在commit 6上FeatureA有吧内容改回了<code>AAA</code>，而B分支没有做同样的修改，当把FeatureA合并到主干时，由于FeatureA相对于共通父节点Commit 1来说没有变化，因此就会使用FeatureB的内容作为最终的内容，而且这种情况下不会报任何冲突。这就极有可能造成错误的代码又被合并到了主干分支上，而且这种问题极难被察觉，就好像莫名其妙的发现代码丢失了一样。</p><p>要避免这种情况的发生，只能从流程上来规范git的操作。如果一个修改要应用到多个分支上，应该单独为这个修改建立一个临时分支，修改完成后，每一个需要用到这个修改的分支都合并这个临时分支。将来如果这个临时分支又有了新的提交，依然是每个分支都要合并。这样就可以避免出现上面的情况。</p><p>未完待续。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;git merge&lt;/code&gt;和&lt;code&gt;git rebase&lt;/code&gt;是我们平时在使用Git过程中用到比较多的两个命令。本文将主要介绍这个两个命令的基本用法以及使用中应该注意的事项。&lt;/p&gt;
&lt;h2 id=&quot;git-merge&quot;&gt;&lt;a href=&quot;#g
      
    
    </summary>
    
      <category term="Git" scheme="http://liujinlongxa.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://liujinlongxa.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发适配HTTPS总结</title>
    <link href="http://liujinlongxa.com/2017/02/07/iOS%E5%BC%80%E5%8F%91%E9%80%82%E9%85%8DHTTPS%E6%80%BB%E7%BB%93/"/>
    <id>http://liujinlongxa.com/2017/02/07/iOS开发适配HTTPS总结/</id>
    <published>2017-02-07T01:46:33.000Z</published>
    <updated>2017-03-01T06:42:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>年前给公司的项目适配了HTTPS，本来年前就该写这篇博客的，一直拖到现在才写。</p><p>本文的主要内容就是对整个适配过程做一个总结。网上有很多详细的教程，具体的适配过程本文就不再赘述了，这里主要总结一下我在适配过程中越到的问题以及一些经验。</p><h2 id="测试自建证书"><a href="#测试自建证书" class="headerlink" title="测试自建证书"></a>测试自建证书</h2><p>适配完成后可以使用自建证书进行测试，关于如何创建自建证书，网上有很多教程，可以自行百度。如果你使用的是AFNetworking框架，使用自建证书也非常简单，首先见证书(abc.cer)导入项目，然后加入代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.sessionManager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</span><br><span class="line"></span><br><span class="line">AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];</span><br><span class="line">securityPolicy.allowInvalidCertificates = <span class="literal">YES</span>;</span><br><span class="line">securityPolicy.validatesDomainName = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *path = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"abc.cer"</span> ofType:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSData</span> *certData = [<span class="built_in">NSData</span> dataWithContentsOfFile:path];</span><br><span class="line"><span class="built_in">NSSet</span> *set = [<span class="built_in">NSSet</span> setWithObjects:certData, <span class="literal">nil</span>];</span><br><span class="line"><span class="keyword">if</span> (certData) &#123;</span><br><span class="line">    securityPolicy.pinnedCertificates = set;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">self</span>.sessionManager.securityPolicy = securityPolicy;</span><br></pre></td></tr></table></figure><p>当然，正式环境还是需要使用CA机构颁发的证书，使用CA机构颁发的证书不需要导入证书，只需要加入以下代码即可：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.sessionManager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</span><br><span class="line"></span><br><span class="line">AFSecurityPolicy *policy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone];</span><br><span class="line"><span class="keyword">self</span>.sessionManager.securityPolicy = securityPolicy;</span><br></pre></td></tr></table></figure><h2 id="配置NSExceptionDomains"><a href="#配置NSExceptionDomains" class="headerlink" title="配置NSExceptionDomains"></a>配置NSExceptionDomains</h2><p>项目中一些不能使用HTTPS协议的请求，需要配置NSExceptionDomains。很多第三方服务的请求还没有支持HTTPS，这就需要我们把这些请求添加到NSExceptionDomains中。可以使用Charles抓包看有哪些第三方请求需要添加到NSExceptionDomains中。</p><p>另外，为了防止域名劫持，项目中可能会直接使用IP进行请求，我再测试过程中发现，即使不添加NSExceptionDomains，直接使用IP也可以正常请求。</p><p>对于WebView里的请求，可以NSAllowsArbitraryLoadsInWebContent字段来声明绕过ATS。</p><p>对于多媒体播放请求（使用AVFoundation），可以使用NSAllowsArbitraryLoadsInMedia字段来声明绕过ATS。</p><h2 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h2><p>一般公司服务器都会有多个环境（测试环境，正式环境等），证书一般只配置在正式环境上，这就要求我们在测试环境下需要关闭ATS。如果每次都手动修改Info.plist文件来关闭ATS，不但麻烦，也可能导致配置的信息丢失。一种比较好做法是创建多个Info.plist，根据不同的环境，自动切换使用不同的Info.plist。</p><p>如下，创建多个Info.plist</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/0c578284b3e0e8649ec145e1413f3d7a.png" alt="2"></p><p>然后在Build Setting中配置不同的环境使用不同的Info.plist</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/190482fe4f86763e6184834be9cff0bf.png" alt="3"></p><p>这样做有一个不好的地方是如果修改了Info.plist文件，需要同时修改两个。但这也比每次切换环境修改Info.plist要好，因为毕竟修改Info.plist的情况还是比较少的。</p><p>以上就是我在适配HTTPS过程中遇到的一些问题，希望对大家有所帮助。</p><p>参考资料：</p><p><a href="http://www.2cto.com/kf/201611/570823.html" target="_blank" rel="noopener">iOS开发适配HTTPS详细教程</a><br><a href="https://onevcat.com/2016/06/ios-10-ats/" target="_blank" rel="noopener">关于iOS10中ATS的问题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;年前给公司的项目适配了HTTPS，本来年前就该写这篇博客的，一直拖到现在才写。&lt;/p&gt;
&lt;p&gt;本文的主要内容就是对整个适配过程做一个总结。网上有很多详细的教程，具体的适配过程本文就不再赘述了，这里主要总结一下我在适配过程中越到的问题以及一些经验。&lt;/p&gt;
&lt;h2 id=&quot;测
      
    
    </summary>
    
      <category term="iOS开发" scheme="http://liujinlongxa.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="HTTPS" scheme="http://liujinlongxa.com/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>使用NSURLProtocol时要注意的一些问题</title>
    <link href="http://liujinlongxa.com/2016/12/20/%E4%BD%BF%E7%94%A8NSURLProtocol%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://liujinlongxa.com/2016/12/20/使用NSURLProtocol注意的一些问题/</id>
    <published>2016-12-20T15:34:03.000Z</published>
    <updated>2017-03-01T06:42:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>项目中使用到了NSURLProtocol，用于拦截所有发出的请求并做一些处理。具体用法可以参考<a href="http://nshipster.cn/nsurlprotocol/" target="_blank" rel="noopener">这篇文章</a>，我还专门写了一个<a href="https://github.com/liujinlongxa/NSURLProtocolDemo" target="_blank" rel="noopener">Demo</a>。最近在使用过程中遇到了一些问题，记录如下。</p><h2 id="拦截到的POST请求的HTTPBody为空"><a href="#拦截到的POST请求的HTTPBody为空" class="headerlink" title="拦截到的POST请求的HTTPBody为空"></a>拦截到的POST请求的HTTPBody为空</h2><p>最近由于升级了AFNetworking，在使用NSURLProtocol过程中发现了一个问题，就是在拦截到POST请求后，HTTPBody是空的。以前使用旧版本的AFNetworking时是没有这问题的。分析了一下，新版的AFNetworking使用的是NSURLSession，旧版使用的是NSURLConnection，可能是由于这个原因导致的。网上查了一下，还真有这个问题，具体可以看<a href="http://stackoverflow.com/questions/36555018/why-is-the-httpbody-of-a-request-inside-an-nsurlprotocol-subclass-always-nil" target="_blank" rel="noopener">这个问题</a>以及<a href="https://bugs.webkit.org/show_bug.cgi?id=137299" target="_blank" rel="noopener">这里的讨论</a>。</p><p>网上有人提出了一种解决方案，就是不要使用HTTPBody，而使用HTTPBodyStream。具体实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableURLRequest</span> * request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url];</span><br><span class="line">request.allHTTPHeaderFields = <span class="keyword">self</span>.request.allHTTPHeaderFields;</span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.request.HTTPMethod isEqualToString:<span class="string">@"POST"</span>]) &#123;</span><br><span class="line">    request.HTTPMethod = <span class="string">@"POST"</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.request.HTTPBody) &#123;</span><br><span class="line">        uint8_t d[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">NSInputStream</span> *stream = <span class="keyword">self</span>.request.HTTPBodyStream;</span><br><span class="line">        <span class="built_in">NSMutableData</span> *data = [[<span class="built_in">NSMutableData</span> alloc] init];</span><br><span class="line">        [stream open];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ([stream hasBytesAvailable]) &#123;</span><br><span class="line">            <span class="built_in">NSInteger</span> len = [stream read:d maxLength:<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span> &amp;&amp; stream.streamError == <span class="literal">nil</span>) &#123;</span><br><span class="line">                [data appendBytes:(<span class="keyword">void</span> *)d length:len];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        request.HTTPBody = [data <span class="keyword">copy</span>];</span><br><span class="line">        [stream close];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        request.HTTPBody = <span class="keyword">self</span>.request.HTTPBody;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个方法就可以获得HTTPBody的内容。</p><h2 id="registerClass-方法只适用于sharedSession"><a href="#registerClass-方法只适用于sharedSession" class="headerlink" title="+registerClass:方法只适用于sharedSession"></a><code>+registerClass:</code>方法只适用于<code>sharedSession</code></h2><p>另外一个要注意的地方就是，只用在使用<code>[NSURLSession sharedSession]</code>时，注册NSURLProtocol才能使用<code>+registerClass:</code>方法，否则就需要使用<code>NSURLSessionConfiguration</code>来注册NSURLProtocol，代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">configuration.protocolClasses = @[[MySessionURLProtocol <span class="keyword">class</span>]];</span><br><span class="line"><span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:configuration];</span><br></pre></td></tr></table></figure><p>因此，对于新版的AFNetworking，由于它使用的不是<code>sharedSession</code>，所以就不能简单的通过类方法<code>+registerClass:</code>来注册自定义NSURLProtocol，也必须通过<code>NSURLSessionConfiguration</code>来设置。代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">configuration.protocolClasses = @[[CustomUrlProtocol <span class="keyword">class</span>]];</span><br><span class="line">AFHTTPSessionManager *sessionManager = [[AFHTTPSessionManager alloc] initWithBaseURL:baseUrl sessionConfiguration:configuration];</span><br><span class="line">[sessionManager GET:url parameters:params progress:^(<span class="built_in">NSProgress</span> * _Nonnull downloadProgress) &#123;</span><br><span class="line">    <span class="comment">// do somting</span></span><br><span class="line">&#125; success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</span><br><span class="line">    <span class="comment">// do somting</span></span><br><span class="line">&#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">    <span class="comment">// do somting</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>以上就是使用NSURLProtocol时要注意的两个问题，希望能对大家有所帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目中使用到了NSURLProtocol，用于拦截所有发出的请求并做一些处理。具体用法可以参考&lt;a href=&quot;http://nshipster.cn/nsurlprotocol/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;，我还专门写
      
    
    </summary>
    
      <category term="iOS Tips" scheme="http://liujinlongxa.com/categories/iOS-Tips/"/>
    
    
      <category term="其他" scheme="http://liujinlongxa.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Xcode如何设置在编译前自动运行脚本</title>
    <link href="http://liujinlongxa.com/2016/11/27/Xcode%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%9C%A8%E7%BC%96%E8%AF%91%E5%89%8D%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/"/>
    <id>http://liujinlongxa.com/2016/11/27/Xcode如何设置在编译前自动运行脚本/</id>
    <published>2016-11-27T04:45:13.000Z</published>
    <updated>2017-03-01T06:42:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时我们可能需要在iOS项目打包前执行一些操作，例如更新资源，修改配置等等，手动修改太麻烦也太Low了，那有没有自动执行的方法呢？</p><p>当然有，这里我会列举三种方法，并且着重讲解一下最后一种方法</p><h3 id="三种方法"><a href="#三种方法" class="headerlink" title="三种方法"></a>三种方法</h3><ul><li>第一种方法：如果你使用的是脚本进行打包，那么事情就简单了，在执行xcodebuild命令前，执行你想做的操作就可以了。</li><li>第二种方法：使用CI平台，最常用的就是jenkins，一般的CI平台都支持在编译前执行脚本。</li><li>第三种方法：如果你使用的是Xcode Archive进行打包，那么就要用到下面的方法添加编译前执行的脚本。</li></ul><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>打开项目配置，选择Build Phases</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/5335ab06bc21202c00fa0014d2df47a3.png" alt="1"></p><p>点击左上角的加号，选择New Run Script Phase</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/63c4d36a01c97b137892fa32fb78a028.png" alt="2"></p><p>这样就可以创建一个新Script Phase，然后在黑色区域写入你的脚本</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/f247183d1bc837e1d67ea5ae04281be5.png" alt="3"></p><p>在脚本中，你可以使用一些环境变量，例如<code>${SRCROOT}</code>表示项目的根目录，<code>${CONFIGURATION}</code>表示项目的Configuration，更多可以使用的环境变量可以参考<a href="https://developer.apple.com/legacy/library/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/0-Introduction/introduction.html#//apple_ref/doc/uid/TP40003931-CH1-SW1" target="_blank" rel="noopener">苹果官方文档</a>。</p><p>最后一步，也是最关键的一步（我在这里卡了半天），选中你创建的Script Phase，然后按住鼠标，把它拖到Compile Source的上面，这样你的脚本才会在代码编译前执行，否则脚本是在代码编译后执行的，如下图：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/d44a9e7f77e737fce5826e39d74a3d9d.png" alt="4"></p><p>这样在编译时就会自动执行脚本了。上图中的脚本内容是在Release下编译时自动执行一个Python脚本。脚本的输出内容可以在Build Log里找到，如下图：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/7bef4677d75f71376b834102880f364b.png" alt="5"></p><p>以上就是整个配置过程，希望这篇文章对您有帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时我们可能需要在iOS项目打包前执行一些操作，例如更新资源，修改配置等等，手动修改太麻烦也太Low了，那有没有自动执行的方法呢？&lt;/p&gt;
&lt;p&gt;当然有，这里我会列举三种方法，并且着重讲解一下最后一种方法&lt;/p&gt;
&lt;h3 id=&quot;三种方法&quot;&gt;&lt;a href=&quot;#三种方法&quot; 
      
    
    </summary>
    
      <category term="iOS Tips" scheme="http://liujinlongxa.com/categories/iOS-Tips/"/>
    
    
      <category term="Xcode" scheme="http://liujinlongxa.com/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>使用defaults命令获取iOS项目版本号</title>
    <link href="http://liujinlongxa.com/2016/11/15/%E4%BD%BF%E7%94%A8defaults%E5%91%BD%E4%BB%A4%E8%8E%B7%E5%8F%96iOS%E9%A1%B9%E7%9B%AE%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    <id>http://liujinlongxa.com/2016/11/15/使用defaults命令获取iOS项目版本号/</id>
    <published>2016-11-15T01:51:44.000Z</published>
    <updated>2017-03-01T06:42:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>defaults命令可以用来读取和修改plist文件，因此可以用它来读取iOS项目里的Info.plist文件，具体用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults read &lt;plist文件的绝对路径&gt; &lt;Key&gt;</span><br></pre></td></tr></table></figure><p>例如，读取项目的版本号，则名为如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults read ~/Project/Info.plist CFBundleShortVersionString</span><br></pre></td></tr></table></figure><p>这里要注意，<strong>路径一定要是绝对路径，不能是相对路径</strong>。</p><p>有了这个命令，我们就可以很方便的在脚本中获取版本号，编写一些更复杂的应用。</p><p>其实，获取版本号还可以使用xcode自带的<a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/agvtool.1.html" target="_blank" rel="noopener">agvtool</a>，但是如果项目中有多个.xcodeproj文件，agvtool就不能正确获取版本号了，暂时还没找到解决方案。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://developer.apple.com/library/content/qa/qa1827/_index.html" target="_blank" rel="noopener">Automating Version and Build Numbers Using agvtool</a><br><a href="https://github.com/nomad/shenzhen/issues/160" target="_blank" rel="noopener">Include Build Number in ipa info command</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;defaults命令可以用来读取和修改plist文件，因此可以用它来读取iOS项目里的Info.plist文件，具体用法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
      <category term="iOS Tips" scheme="http://liujinlongxa.com/categories/iOS-Tips/"/>
    
    
      <category term="其他" scheme="http://liujinlongxa.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C中如何忽略warning</title>
    <link href="http://liujinlongxa.com/2016/11/10/Objective-C%E4%B8%AD%E5%A6%82%E4%BD%95%E5%BF%BD%E7%95%A5warning/"/>
    <id>http://liujinlongxa.com/2016/11/10/Objective-C中如何忽略warning/</id>
    <published>2016-11-10T13:05:51.000Z</published>
    <updated>2017-03-01T06:42:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>经常会在有些第三方框架里看到这样的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wgnu"</span></span></span><br><span class="line">    <span class="built_in">NSString</span> *pathToBeMatched = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (method &amp;&amp; path) &#123;</span><br><span class="line">        pathToBeMatched = [[[<span class="keyword">self</span> requestWithMethod:(method ?: <span class="string">@"GET"</span>) path:path parameters:<span class="literal">nil</span>] URL] path];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br></pre></td></tr></table></figure><p>这段代码的前两句和最后一句的作用是忽略中间的代码的某种警告（warning），如果我们的代码中有些警告希望被忽略，可以使用这种方法忽略警告。</p><p>其中第二句代码的<code>-Wgnu</code>是警告类型，可以通过以下方法查看警告类型。</p><p>首先Command+b编译代码，然后Command+8来到报告导航栏，选中刚才的那次编译，如下图：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/ba9ee4f9e59a474670f251598e7978d6.png" alt="1"></p><p>然后在左侧，找到相应的警告详情，点击左边的<img src="http://7xn88v.com1.z0.glb.clouddn.com/f12763686090a1cec73de963526971be.png" alt="2">按钮可以打开详情，然后就可以在最底部的警告描述里找到警告的类型，如下图：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/4d8b40432de09a56e50622b099f002bb.png" alt="3"></p><p>以上就是OC忽略警告的方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经常会在有些第三方框架里看到这样的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cla
      
    
    </summary>
    
      <category term="iOS Tips" scheme="http://liujinlongxa.com/categories/iOS-Tips/"/>
    
    
      <category term="Objective-C" scheme="http://liujinlongxa.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>使用nat123实现外网ssh连接内网树莓派设备</title>
    <link href="http://liujinlongxa.com/2016/11/05/%E4%BD%BF%E7%94%A8nat123%E5%AE%9E%E7%8E%B0%E5%A4%96%E7%BD%91ssh%E8%BF%9E%E6%8E%A5%E5%86%85%E7%BD%91%E6%A0%91%E8%8E%93%E6%B4%BE%E8%AE%BE%E5%A4%87/"/>
    <id>http://liujinlongxa.com/2016/11/05/使用nat123实现外网ssh连接内网树莓派设备/</id>
    <published>2016-11-05T09:56:46.000Z</published>
    <updated>2017-03-01T06:42:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/zh-cn/%E6%A0%91%E8%8E%93%E6%B4%BE" target="_blank" rel="noopener">树莓派</a>是一款基于Linux的单板机电脑。最近入手了一块，打算作为Linux服务器来使用。</p><p>树莓派自带以太网接口和Wifi模块，可以通过网线或Wifi连接网络。但是由于我家里的网络是电信的光纤网络，用的是电信配的路由器，各个终端都是通过Wifi或网线连到这个路由上，因此各个终端相当于处于局域网，外网无法通过ip直接访问到内网的树莓派设备，这样如果我在树莓派上搭建一个服务器，外网就无法访问。</p><p>一般这种问题，只需要在路由器上设置一下<a href="http://www.hrtl.com.cn/News_398.aspx" target="_blank" rel="noopener">端口映射</a>就可通过外网访问内网主机了，但是电信配的这个路由器不支持设置端口映射（吐槽一下，电信自带的路由器简直弱爆了），所有就没办法通过设置路由器的方法解决。</p><p>经过一番探索，找了一种可行的方案：<a href="http://www.nat123.com/" target="_blank" rel="noopener">nat123</a>。nat123是一家专业提供端口映射和域名解析的网站，下面我就详细介绍一下如何使用nat123来实现外网访问内网树莓派设备。</p><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="第一步-准备工作"><a href="#第一步-准备工作" class="headerlink" title="第一步 准备工作"></a>第一步 准备工作</h3><p>确保在内网环境下可以通过ssh访问树莓派，如何在树莓派上配置ssh，可以参考<a href="http://www.itnose.net/detail/6109563.html" target="_blank" rel="noopener">这篇文章</a></p><h3 id="第二步-注册nat123"><a href="#第二步-注册nat123" class="headerlink" title="第二步 注册nat123"></a>第二步 注册nat123</h3><p>打开<a href="http://www.nat123.com/" target="_blank" rel="noopener">nat123</a>官网，点击右上角的注册按钮完成注册</p><h3 id="第三步-在树莓派上安装nat123-Linux版"><a href="#第三步-在树莓派上安装nat123-Linux版" class="headerlink" title="第三步 在树莓派上安装nat123 Linux版"></a>第三步 在树莓派上安装nat123 Linux版</h3><p>打开树莓派，按照<a href="http://www.nat123.com/pages_17_600.jsp" target="_blank" rel="noopener">这篇文章</a>的内容安装并启动相关软件。这里注意要根据你树莓派上的操作系统选择不同的安装方式，如果安装的官方操作系统Raspbian，应该选用Debian系统的安装方式。</p><h3 id="第四步-配置端口映射"><a href="#第四步-配置端口映射" class="headerlink" title="第四步 配置端口映射"></a>第四步 配置端口映射</h3><p>登录<a href="http://www.nat123.com/" target="_blank" rel="noopener">nat123</a>，在左侧的用户中心点击“端口映射添加”，如下图：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/7855931f84f019009241b787d7c35f87.png" alt="1"></p><p>应用类型选择“其他（非网站）”，这里我要实现的是通过ssh访问树莓派，所有不是80端口，具体应该根据自己的需求选择应用类型，可以参考<a href="http://www.nat123.com/Pages_8_570.jsp" target="_blank" rel="noopener">这篇文章</a>。</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/d784b452f4e1a71ef9555fd783b95386.png" alt="2"></p><p>下面解释一下每一项的含义：</p><ul><li>应用名称：随便起，这里因为是用于ssh连接的，所以起名为ssh</li><li>内网端口：内网应用的端口，ssh访问默认端口为22，如果是其他服务，这里的端口号应该填相应服务的端口号，例如，ftp服务默认端口号为21，http服务默认端口80等。</li><li>内网地址：即树莓派在内网的ip地址，可以通过<code>ifconfig</code>命令查看</li><li>外网端口：自动生成，要记住这个端口号，待会链接是要用到</li><li>外网域名：自动生成，这就是外网要访问的地址</li></ul><p>然后点击“确认保存”，这里需要认证，认证需要收费（30￥），付款完成后，再次点击“确认保存”，就可以保存成功。可以在左侧的“端口映射列表”里查看和修改添加的端口映射。</p><p>这样就完成了端口映射的添加。</p><h3 id="第五步-外网访问"><a href="#第五步-外网访问" class="headerlink" title="第五步 外网访问"></a>第五步 外网访问</h3><p>这时就已经可以通过外网访问了，在外网环境下打开终端，输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh pi@45067491.nat123.net -p 22996</span><br></pre></td></tr></table></figure><p>然后输入密码，就可以通过ssh访问树莓派了。这里”pi”是你在树莓派里的用户名，-p参数是刚才的端口号。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是我使用nat123实现外网访问内网树莓派设备的这个过程。整个过程并不复杂，但是我在进行的过程中还是磕磕绊绊折腾了好久才完全整好，不过这个过程中还是学到了不少的东西。</p><p>由于水平有限，如果上文中有不正确的地方，欢迎大家交流指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E6%A0%91%E8%8E%93%E6%B4%BE&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;树莓派&lt;/a&gt;是一款基于Linux的单板机电脑。最近入手了一块，打算作为L
      
    
    </summary>
    
      <category term="树莓派" scheme="http://liujinlongxa.com/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
      <category term="树莓派" scheme="http://liujinlongxa.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="SSH" scheme="http://liujinlongxa.com/tags/SSH/"/>
    
      <category term="网络" scheme="http://liujinlongxa.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Swift3中的预处理宏</title>
    <link href="http://liujinlongxa.com/2016/10/28/Swift3%E4%B8%AD%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%E5%AE%8F/"/>
    <id>http://liujinlongxa.com/2016/10/28/Swift3中的预处理宏/</id>
    <published>2016-10-28T09:18:57.000Z</published>
    <updated>2017-03-01T06:42:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Swift中也可以使用预处理宏，只不过和ObjectiveC有点不一样，下面详细说明一下。</p><ul><li>Swift中取消了#define，建议使用全局常量替换宏定义</li><li>Swift中仍然可以使用<code>#if, #elseif, #endif</code>等宏，注意，Swift中是<code>#elseif</code>，而在OC中是<code>#elif</code>。还有<code>#if</code>和<code>#elseif</code>后面的判断条件必须是Bool类型的。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">if</span> <span class="literal">false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"aaaa"</span>)</span><br><span class="line">#elseif <span class="literal">true</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"bbbb"</span>)</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"cccc"</span>)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><ul><li>Swift中取消了<code>__FUNCTION__, __FILE__, __LINE__</code>，分别改为了<code>#function, #file, #line</code></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(#file)</span><br><span class="line"><span class="built_in">print</span>(#line)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(#function)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Swift中也可以使用预处理宏，只不过和ObjectiveC有点不一样，下面详细说明一下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Swift中取消了#define，建议使用全局常量替换宏定义&lt;/li&gt;
&lt;li&gt;Swift中仍然可以使用&lt;code&gt;#if, #elseif, #endif
      
    
    </summary>
    
      <category term="Swift" scheme="http://liujinlongxa.com/categories/Swift/"/>
    
    
      <category term="Swift" scheme="http://liujinlongxa.com/tags/Swift/"/>
    
      <category term="预处理宏" scheme="http://liujinlongxa.com/tags/%E9%A2%84%E5%A4%84%E7%90%86%E5%AE%8F/"/>
    
  </entry>
  
  <entry>
    <title>给多个Target添加CocoaPods</title>
    <link href="http://liujinlongxa.com/2016/10/26/%E7%BB%99%E5%A4%9A%E4%B8%AATarget%E6%B7%BB%E5%8A%A0CocoaPods/"/>
    <id>http://liujinlongxa.com/2016/10/26/给多个Target添加CocoaPods/</id>
    <published>2016-10-26T14:25:04.000Z</published>
    <updated>2017-03-01T06:42:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>一般我们使用CocoaPods进行依赖管理时，如果项目里只有一个Target，则Podfile文件的格式应该是：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target <span class="string">'ZipApp'</span> <span class="keyword">do</span>  <span class="comment"># ZipApp为Target名称</span></span><br><span class="line">  pod <span class="string">'SSZipArchive'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如果项目中有多个Target，可以定义多个这样的block，如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target <span class="string">'ZipApp'</span> <span class="keyword">do</span>  <span class="comment"># ZipApp为Target名称</span></span><br><span class="line">  pod <span class="string">'SSZipArchive'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target <span class="string">'ZipAppTest'</span> <span class="keyword">do</span>  <span class="comment"># ZipAppTest为另一个Target名称</span></span><br><span class="line">  pod <span class="string">'SSZipArchive'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如果多个Target的依赖的库都是一样的，没有必要每一个Target都把所有库都写一遍，可以定义一个函数，写法如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">common_pods</span></span></span><br><span class="line">    pod <span class="string">'SSZipArchive'</span></span><br><span class="line">    pod <span class="string">'AFNetworking'</span></span><br><span class="line">    pod <span class="string">'JSPatch'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target <span class="string">'ZipApp'</span> <span class="keyword">do</span>  <span class="comment"># ZipApp即使Target名称</span></span><br><span class="line">  common_pods</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target <span class="string">'ZipAppTest'</span> <span class="keyword">do</span></span><br><span class="line">    common_pods</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="其他的用法"><a href="#其他的用法" class="headerlink" title="其他的用法"></a>其他的用法</h3><p>如果多个Target有嵌套关系，即一个Target是另一个Target的父Target，则可以写成以下形式：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">target <span class="string">'ZipApp'</span> <span class="keyword">do</span></span><br><span class="line">  pod <span class="string">'SSZipArchive'</span></span><br><span class="line"></span><br><span class="line">  target <span class="string">'ZipAppTests'</span> <span class="keyword">do</span></span><br><span class="line">    inherit! <span class="symbol">:search_paths</span> <span class="comment"># 这句话表示子Target继承了父Target包含的pod，即ZipAppTests这个Target里包含了SSZipArchive和Nimble两个pod</span></span><br><span class="line">    pod <span class="string">'Nimble'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如果一个Workspace里包含了多个Project，并且每一个Project都有不同的Target，则可以使用以下形式定义多个Project的Target：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">target <span class="string">'Target1'</span> <span class="keyword">do</span></span><br><span class="line">  project <span class="string">'Project1'</span></span><br><span class="line">  pod <span class="string">'AFNetworking'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target <span class="string">'Target2'</span> <span class="keyword">do</span></span><br><span class="line">  project <span class="string">'Project2'</span></span><br><span class="line">  pod <span class="string">'JSPatch'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h3&gt;&lt;p&gt;一般我们使用CocoaPods进行依赖管理时，如果项目里只有一个Target，则Podfile文件的格式应该是：&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="iOS开发" scheme="http://liujinlongxa.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Target" scheme="http://liujinlongxa.com/tags/Target/"/>
    
      <category term="CocoaPods" scheme="http://liujinlongxa.com/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>如何获取WebView的UserAgent</title>
    <link href="http://liujinlongxa.com/2016/10/25/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96WebView%E7%9A%84UserAgent/"/>
    <id>http://liujinlongxa.com/2016/10/25/如何获取WebView的UserAgent/</id>
    <published>2016-10-25T03:46:04.000Z</published>
    <updated>2017-03-01T06:42:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>项目中用到了WebView的UserAgent，可以通过以下方式获取到：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIWebView</span>* webView = [[<span class="built_in">UIWebView</span> alloc] init];</span><br><span class="line"><span class="built_in">NSString</span>* secretAgent = [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"navigator.userAgent"</span>];</span><br></pre></td></tr></table></figure><p>如果是WKWebView，可以通过以下方式获取</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WKWebView</span> *webView = [[<span class="built_in">WKWebView</span> alloc] init];</span><br><span class="line">[webView evaluateJavaScript:<span class="string">@"navigator.userAgent"</span> completionHandler:^(<span class="keyword">id</span> _Nullable userAgent, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"userAgent: %@"</span>, userAgent);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">self</span>.webView = webView; <span class="comment">// 注意，一定要对webView进行强引用</span></span><br></pre></td></tr></table></figure><p>获取到的值的为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (iPhone; CPU iPhone OS 10_0_1 like Mac OS X) AppleWebKit/602.1.50 (KHTML, like Gecko) Mobile/14A403</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目中用到了WebView的UserAgent，可以通过以下方式获取到：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/sp
      
    
    </summary>
    
      <category term="iOS Tips" scheme="http://liujinlongxa.com/categories/iOS-Tips/"/>
    
    
      <category term="其他" scheme="http://liujinlongxa.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>iOS10无法获取IDFA的问题</title>
    <link href="http://liujinlongxa.com/2016/10/18/iOS10%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96IDFA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://liujinlongxa.com/2016/10/18/iOS10无法获取IDFA的问题/</id>
    <published>2016-10-18T02:17:44.000Z</published>
    <updated>2017-03-01T06:42:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS10上，如果用户开启了“限制广告跟踪”选项（设置-&gt;隐私-&gt;广告），则在使用<code>[[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString]</code>方法获取IDFA时会返回全部是0，如下：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/13bbfe746dacb7c156cac2aaac5b2c0d.png" alt="1"></p><p>有两种解决方案：</p><p>第一种方法是通过<code>isAdvertisingTrackingEnabled</code>属性判断是否可以返回正确的IDFA，如果返回为NO，则可以提示用户去设置中关闭限制广告跟踪。代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *idfa = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> ([[ASIdentifierManager sharedManager] isAdvertisingTrackingEnabled]) &#123;</span><br><span class="line">    idfa = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 弹窗提示用户关闭限制广告跟踪</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种更好的方法是使用第三方库获取IDFA，这里推荐两个第三方库：<a href="https://github.com/ylechelle/OpenIDFA" target="_blank" rel="noopener">OpenIDFA</a>和<a href="https://github.com/youmi/SimulateIDFA" target="_blank" rel="noopener">SimulateIDFA</a>，个人更推荐SimulateIDFA，因为他的重复率更低。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;iOS10上，如果用户开启了“限制广告跟踪”选项（设置-&amp;gt;隐私-&amp;gt;广告），则在使用&lt;code&gt;[[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString]&lt;/code&gt;方法获取I
      
    
    </summary>
    
      <category term="iOS Tips" scheme="http://liujinlongxa.com/categories/iOS-Tips/"/>
    
    
      <category term="IDFA" scheme="http://liujinlongxa.com/tags/IDFA/"/>
    
  </entry>
  
  <entry>
    <title>获取本地化的APP版本描述信息</title>
    <link href="http://liujinlongxa.com/2016/10/09/%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%9C%B0%E5%8C%96%E7%9A%84APP%E7%89%88%E6%9C%AC%E6%8F%8F%E8%BF%B0%E4%BF%A1%E6%81%AF/"/>
    <id>http://liujinlongxa.com/2016/10/09/获取本地化的APP版本描述信息/</id>
    <published>2016-10-09T15:25:15.000Z</published>
    <updated>2017-03-01T06:42:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>在制作APP升级提示框时，需要APP的最新版本信息，苹果提供了”<a href="http://itunes.apple.com/lookup?id=123123&quot;接口用于查询AppStore上的APP的详细信息，参数id表示的是应用程序的AppId。" target="_blank" rel="noopener">http://itunes.apple.com/lookup?id=123123&quot;接口用于查询AppStore上的APP的详细信息，参数id表示的是应用程序的AppId。</a></p><p>如果在iTunesConnect上对应用的版本描述信息做了本地化，上述接口只会返回首选语言的描述信息，如果要返回特定语言的描述信息，还要加上两个参数:</p><ul><li>country: 国家参数，CN表示中国，US表示美国，国家代码可以在<a href="https://zh.wikipedia.org/wiki/ISO_3166-1" target="_blank" rel="noopener">这里</a>找到</li><li>lang: 语言参数，zh_cn表示中文，zh_tw表示繁体中文，en_us表示美国英国，语言编码可以参考<a href="https://zh.wikipedia.org/wiki/%E5%8C%BA%E5%9F%9F%E8%AE%BE%E7%BD%AE" target="_blank" rel="noopener">维基百科</a></li></ul><p>例如：</p><ul><li>要获取中文的描述信息，应该调用<a href="http://itunes.apple.com/lookup?id=123123&amp;country=CN&amp;lang=zh_cn" target="_blank" rel="noopener">http://itunes.apple.com/lookup?id=123123&amp;country=CN&amp;lang=zh_cn</a></li><li>要获取繁体中文的描述信息，应该调用<a href="http://itunes.apple.com/lookup?id=123123&amp;country=TW&amp;lang=zh_tw" target="_blank" rel="noopener">http://itunes.apple.com/lookup?id=123123&amp;country=TW&amp;lang=zh_tw</a></li><li>要获取英文的描述信息，应该调用<a href="http://itunes.apple.com/lookup?id=123123&amp;country=US&amp;lang=en_us" target="_blank" rel="noopener">http://itunes.apple.com/lookup?id=123123&amp;country=US&amp;lang=en_us</a></li></ul><p>参考资料：</p><p><a href="https://zh.wikipedia.org/wiki/%E5%8C%BA%E5%9F%9F%E8%AE%BE%E7%BD%AE" target="_blank" rel="noopener">语言区域</a><br><a href="https://zh.wikipedia.org/wiki/ISO_3166-1" target="_blank" rel="noopener">ISO_3166-1</a><br><a href="https://affiliate.itunes.apple.com/resources/documentation/itunes-store-web-service-search-api/" target="_blank" rel="noopener">iTunes Affiliate Resources</a><br><a href="http://blog.hoachuck.biz/blog/2012/07/01/playing-around-with-app-store-meta-data/" target="_blank" rel="noopener">Playing Around With App Store Meta Data</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在制作APP升级提示框时，需要APP的最新版本信息，苹果提供了”&lt;a href=&quot;http://itunes.apple.com/lookup?id=123123&amp;quot;接口用于查询AppStore上的APP的详细信息，参数id表示的是应用程序的AppId。&quot; targ
      
    
    </summary>
    
      <category term="iOS Tips" scheme="http://liujinlongxa.com/categories/iOS-Tips/"/>
    
    
      <category term="本地化" scheme="http://liujinlongxa.com/tags/%E6%9C%AC%E5%9C%B0%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>iOS多环境配置实践</title>
    <link href="http://liujinlongxa.com/2016/10/07/iOS%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/"/>
    <id>http://liujinlongxa.com/2016/10/07/iOS多环境配置实践/</id>
    <published>2016-10-07T02:04:43.000Z</published>
    <updated>2017-03-01T06:42:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在移动客户端开发过程中，服务器一般都会提供多个环境的API接口，例如测试环境(TEST_ENV)，发布环境(RELEASE_ENV)，预发布环境(PRERELEASE_ENV)等，我们客户端在打包的时候需要在不同的阶段打不同环境的包，最简单的做法就是在代码里直接修改URL来切换不同的环境。但是这种做法太Low了，而且也不易于使用脚本自动打包。本文的主要内容就是介绍一种不修改代码达到配置不同环境的方法。</p><h2 id="明确需求"><a href="#明确需求" class="headerlink" title="明确需求"></a>明确需求</h2><p>在开始主要内容之前，先明确一下需求：</p><ol><li>服务器有三个环境，测试环境(TEST_ENV)，发布环境(RELEASE_ENV)，预发布环境(PRERELEASE_ENV)，要求要很方便的实现在三个不同环境之间自由切换</li><li>代码中大量使用了DEBUG宏，因此要求每个环境都应该区分DEBUG和RELEASE，即在任一环境下都可能需要打DEBUG包或RELEASE包</li></ol><p>为此，我编写了一份测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#if TEST_ENV // 测试环境</span><br><span class="line">#if DEBUG</span><br><span class="line">    NSLog(@&quot;hello test env debug&quot;);</span><br><span class="line">#else</span><br><span class="line">    NSLog(@&quot;hello test env release&quot;);</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if RELEASE_ENV // 发布环境</span><br><span class="line">#if DEBUG</span><br><span class="line">    NSLog(@&quot;hello release env debug&quot;);</span><br><span class="line">#else</span><br><span class="line">    NSLog(@&quot;hello release env release&quot;);</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if PRERELEASE_ENV // 预发布环境</span><br><span class="line">#if DEBUG</span><br><span class="line">    NSLog(@&quot;hello pre-relase env debug&quot;);</span><br><span class="line">#else</span><br><span class="line">    NSLog(@&quot;hello pre-relase env release&quot;);</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="1-为每一个环境创建一个Target"><a href="#1-为每一个环境创建一个Target" class="headerlink" title="1. 为每一个环境创建一个Target"></a>1. 为每一个环境创建一个Target</h3><p>创建项目后，项目本身就会有一个Target（如果不了解Target的概念可以看一下<a href="https://developer.apple.com/library/content/featuredarticles/XcodeConcepts/Concept-Targets.html" target="_blank" rel="noopener">这篇官方文档</a>）,我们可以把这个Target就作为某一个环境的Target，这里我们把它作为发布环境的Target，然后还需要创建测试环境和预发布环境的Target，方法如下：</p><p>在项目配置界面左侧，选中Target，点击右键，选择”Duplicate”，复制一个新的Target，如下图：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/ec6ceac9d953c320c0cbf0bfe55ee361.png" alt="1"></p><p>然后在弹出的菜单中点击”Duplicate Only”</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/463b4e2b32269ab485d9f160315e1d75.png" alt="2"></p><p>这样就创建好了一个新的Target。新的Target的默认名称为”项目名称 copy”，即”Test1007 copy”，单击新创建的Target，修改Target名称为”Test1007_Test”，将这个Target作为测试环境的Target。</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/4e99d383134b80176fedbe7853327b6f.png" alt="3"></p><p>创建完Target后，XCode会自动为这个Target创建一个Scheme，为了方便起见，也将这个Scheme的名称修改为”Test1007_Test”，方法是在左上角点击”Manage Schemes…”，单机要修改名称的Scheme，即可修改Scheme的名称。</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/32c4abd9100ed10efbebda4f876c5939.png" alt="4"></p><p>同样的方法，在创建一个名为”Test1007_Prerelease”的Target作为预发布环境的Target。</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/640b7eebdbb792330544b5211110f278.png" alt="5"></p><h3 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2. 配置环境变量"></a>2. 配置环境变量</h3><p>配置环境变量，就是添加TEST_ENV，RELEASE_ENV和PRERELEASE_ENV这三个宏，这一步在ObjectiveC下和Swift是不一样的，这里会分别讲解</p><h4 id="ObjectiveC下配置环境变量"><a href="#ObjectiveC下配置环境变量" class="headerlink" title="ObjectiveC下配置环境变量"></a>ObjectiveC下配置环境变量</h4><p>在项目配置界面选择发布环境的Target “Test1007”，点击Build Settings，找到Preprocessor Macros，在Debug和Release下都添加环境变量”RELEASE_ENV=1”，如图：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/e685c55dc756723ecd8a2d513efca11e.png" alt="6"></p><p>添加完成后结果如图：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/60989466ad3f7b1b1e272210c2fafe8d.png" alt="7"></p><p>这样就为发布环境添加好了”RELEASE_ENV”宏。</p><p>同样的方法，分别在Target “Test1007_Test”和”Test1007_Prerelease”添加TEST_ENV和PRERELEASE_ENV这两个宏。</p><h4 id="Swift下配置环境变量"><a href="#Swift下配置环境变量" class="headerlink" title="Swift下配置环境变量"></a>Swift下配置环境变量</h4><p>在项目配置界面选择发布环境的Target “Test1007”，点击Build Settings，找到Other Swift Flags，在Debug和Release下都添加环境变量”-D RELEASE_ENV”，如图：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/d7ec2f7e6073166d15fc64d488b42fcb.png" alt="8"></p><p>添加完成后如图：</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/2697bee36a116092b03257cfca9bf774.png" alt="9"></p><p>同样的方法，分别在Target “Test1007_Test”和”Test1007_Prerelease”下添加TEST_ENV和PRERELEASE_ENV这两个宏。</p><p>这样就完成了环境变量的配置。</p><h3 id="3-为不同环境的包配置不同的名称，BundleId和图标"><a href="#3-为不同环境的包配置不同的名称，BundleId和图标" class="headerlink" title="3. 为不同环境的包配置不同的名称，BundleId和图标"></a>3. 为不同环境的包配置不同的名称，BundleId和图标</h3><p>其实到这一步就已经完成了不同环境的配置，要切换环境，只需要切换左上角的Scheme就可以了。为了更好的区分不同环境下的包，可以给每个环境配置不同的App名称，BundleId和App图标，方法如下：</p><p>在项目配置界面选中一个Target，通过修改Display Name和Bundle Identifier可以为不同环境的包设置不同的App名称和BundleId。</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/98681390ae672ce58b2a541c3068e4c6.png" alt="10"></p><p>要设置不同的图标，需要在Build Settings里找到”Asset Calalog App Icon Set Name”，其默认值是AppIcon，可以为不同Target设置不同的Icon Set Name，然后在Assets.xcassets中添加对应的Image Set即可。</p><p><img src="http://7xn88v.com1.z0.glb.clouddn.com/a9fa6a0db2bccb6d5945fe5c3f4d8360.png" alt="11"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文是通过多个Target来实现多环境配置的，其实除了本文介绍的方法，还有其他方法可以实现多环境配置，具体可以参考<a href="http://www.jianshu.com/p/83b6e781eb51" target="_blank" rel="noopener">这篇文章</a>。</p><p>有了多环境配置，就可以很方便的实现多环境自动打包，如果在加入持续集成系统（例如jenkins等），就可以非常优雅的打包。这个以后有时间会专门写一篇博客来介绍相关内容。</p><p>参考资料：<br><a href="http://www.jianshu.com/p/83b6e781eb51" target="_blank" rel="noopener">手把手教你给一个iOS app配置多个环境变量</a><br><a href="http://www.cocoachina.com/ios/20151023/13869.html" target="_blank" rel="noopener">iOS开发必备–环境变量配置(Debug &amp; Release)</a><br><a href="http://kevindelord.io/2016/06/08/project-configuration/" target="_blank" rel="noopener">Xcode Project Configuration</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在移动客户端开发过程中，服务器一般都会提供多个环境的API接口，例如测试环境(TEST_ENV)，发布环境(RELEASE_ENV)，预发布
      
    
    </summary>
    
      <category term="iOS开发" scheme="http://liujinlongxa.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Target" scheme="http://liujinlongxa.com/tags/Target/"/>
    
      <category term="Scheme" scheme="http://liujinlongxa.com/tags/Scheme/"/>
    
  </entry>
  
  <entry>
    <title>使用xUnique遇到了的问题</title>
    <link href="http://liujinlongxa.com/2016/10/04/%E4%BD%BF%E7%94%A8xUnique%E9%81%87%E5%88%B0%E4%BA%86%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://liujinlongxa.com/2016/10/04/使用xUnique遇到了的问题/</id>
    <published>2016-10-04T14:24:27.000Z</published>
    <updated>2017-03-01T06:42:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>xUnique是一个用来对iOS向的<em>.xcodeproj文件进行排序的工具，它可以降低</em>.xcodeproj文件冲突的概率。其实质是一个Git Hook脚本，在提交一个Commit时，如果*.xcodeproj文件有修改，则会对文件进行重新排序。</p><p>最近在使用时发现了一个问题，当我执行“pod install”安装第三方库时，在进行提交时会报”File ‘project.pbxproj’ is broken. Cannot find PBXProject name.”，从字面意思看’project.pbxproj’文件损坏，但是进入*.xcodeproj文件夹，双击‘project.pbxproj’，发现是可以打开的，并没有问题。</p><p>最后通过查找资料，找到了原因，具体原因是由于在执行‘pod install’后，CocoaPods会重写‘project.pbxproj’文件，并且改变了它的格式，导致xUnique无法正确读取’project.pbxproj’文件。</p><p>解决方法是：让xcode重新生成‘project.pbxproj’，具体步骤如下：</p><ol><li>先关闭xUnique，然后提交代码。关闭xUnique的方法是打开“&lt;项目仓库根目录&gt;/.git/hooks/pre-commit”文件，注释掉xUnique有关的内容</li><li>做出任意一个可以导致’project.pbxproj’修改的修改，例如修改版本号，创建文件等，这样xcode会重写’project.pbxproj’文件</li><li>打开xUnique，提交代码，这时xUnique就可以识别’project.pbxproj’文件了</li></ol><p>参看文档：<br><a href="https://github.com/truebit/xUnique/issues/34" target="_blank" rel="noopener">File ‘project.pbxproj’ is broken. Cannot find PBXProject name.</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;xUnique是一个用来对iOS向的&lt;em&gt;.xcodeproj文件进行排序的工具，它可以降低&lt;/em&gt;.xcodeproj文件冲突的概率。其实质是一个Git Hook脚本，在提交一个Commit时，如果*.xcodeproj文件有修改，则会对文件进行重新排序。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="iOS Tips" scheme="http://liujinlongxa.com/categories/iOS-Tips/"/>
    
    
      <category term="其他" scheme="http://liujinlongxa.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
</feed>
