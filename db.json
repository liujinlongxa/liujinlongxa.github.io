{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/Staticfile","path":"Staticfile","modified":1,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/README.md","path":"README.md","modified":1,"renderable":0},{"_id":"source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":0},{"_id":"source/images/cyclehead.png","path":"images/cyclehead.png","modified":1,"renderable":0},{"_id":"source/images/smallhead.png","path":"images/smallhead.png","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/Staticfile","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1471015204000},{"_id":"source/CNAME","hash":"ec600ca74a4560b8006ae601739a1985c8d0b12c","modified":1471015204000},{"_id":"source/README.md","hash":"6241eb736c81425f44c5ce61555c89e128cee41a","modified":1471015204000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1471160754000},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1471160754000},{"_id":"themes/next/.gitignore","hash":"c8d6a73b9e17f0f8a3716e4ada6960d3180425a6","modified":1471160754000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1471160754000},{"_id":"themes/next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1471160754000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1471160754000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1471160754000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1471160754000},{"_id":"themes/next/_config.yml","hash":"a42b2ac8f16b979d29a7dceaf0a8446031f159d3","modified":1471162067000},{"_id":"themes/next/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1471160754000},{"_id":"themes/next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1471160754000},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1471160754000},{"_id":"source/_posts/2015-10-03-博客新家.md","hash":"dbceb588bcc277ac4a32f9bdd86c633935da454c","modified":1471015204000},{"_id":"source/_posts/2015-10-04-NSURLProtocol的使用.md","hash":"b801fa426b776a1fade19d8b4308a50b794b4f43","modified":1471015204000},{"_id":"source/_posts/2015-10-04-iOS中Emoji表情的判断.md","hash":"1e1cb1dc93806788082be5a12db65ef109c9ea56","modified":1471015204000},{"_id":"source/_posts/2015-10-04-iOS中的多线程编程.md","hash":"e9d9dda15a3a6bdf0fb04fb38d6cd3eb6766c8df","modified":1471015204000},{"_id":"source/_posts/2015-10-04-iOS中的富文本技术(2)CoreText框架.md","hash":"ea52268985553d5ab745a771b104b331d5225507","modified":1471015204000},{"_id":"source/_posts/2015-10-04-iOS中的富文本技术(1)TextKit简介.md","hash":"38334f0b7834838d9e1220b2f839721814f01add","modified":1471015204000},{"_id":"source/_posts/2015-10-04-iOS运行时初探-使用运行时机制向Category中添加属性.md","hash":"68caa04b6a7b4f6c05639e383b55e38a4daf4ba4","modified":1471015204000},{"_id":"source/_posts/2015-10-04-使用jekyll+GithubPage搭建个人博客系统.md","hash":"6f4418ea3614212473a4d7bb986b5e7401abcc35","modified":1471015204000},{"_id":"source/_posts/2015-10-05-《图解HTTP》读书笔记(1).md","hash":"a146ccc639187cc54a1b05fff28b04510ddc5260","modified":1471015204000},{"_id":"source/_posts/2015-10-04-适配iOS9（ATS问题）.md","hash":"c3bc80c7f2160f49b635a81eeca1616628284ad9","modified":1471015204000},{"_id":"source/_posts/2015-10-07-《图解HTTP》读书笔记(3).md","hash":"ac7142582de3187b90b0fafcbfe05e37b42d9172","modified":1471015204000},{"_id":"source/_posts/2015-10-06-《图解HTTP》读书笔记(2).md","hash":"3786da9e11499253f7503008b21cc07df69846f1","modified":1471015204000},{"_id":"source/_posts/2015-10-16-最近开发中遇到的一些问题.md","hash":"20d569463be65b2b1caa79c9b1d6ae6290061d90","modified":1471015204000},{"_id":"source/_posts/2015-10-27-UIScrollView与Autolayout.md","hash":"cdd624955b48ba68c8d4a818380f99ac5ed0eba5","modified":1471015204000},{"_id":"source/_posts/2015-11-07-ContentHugging与ContentCompressionResistance.md","hash":"93d81d37fdfa53956430ff1406ec907562eec9ef","modified":1471015204000},{"_id":"source/_posts/2015-12-13-CoreAnimation编程指南学习笔记(2).md","hash":"21e3eb91e6207a02e8c6be87f365fe4c16a5ea66","modified":1471015204000},{"_id":"source/_posts/2015-12-06-CoreAnimation编程指南学习笔记(1).md","hash":"c91d96830d316420bef036fa1683a350e0f88b03","modified":1471015204000},{"_id":"source/_posts/2015-12-20-RAC学习笔记.md","hash":"eb1f89c5d63027fa5f81a488b2ce7ca9c32beaa4","modified":1471015204000},{"_id":"source/_posts/2015-12-27-《ios核心动画高级技巧》阅读笔记(1).md","hash":"b298c0c0b979109de303396b5055824b47da3a7d","modified":1471015204000},{"_id":"source/_posts/2015-12-27-《ios核心动画高级技巧》阅读笔记(2).md","hash":"371cde7a8a626ce94d0f0c2d8261e3b36d71f448","modified":1471015204000},{"_id":"source/_posts/2015-12-27-《ios核心动画高级技巧》阅读笔记(3).md","hash":"a8fa1e22041c4f9e8e34d96d658cc4ebca00c829","modified":1471015204000},{"_id":"source/_posts/2016-01-01-自动打包工具shenzhen使用简介.md","hash":"0a5351c9790a14b37965e1dd554e0e55013eaeec","modified":1471015204000},{"_id":"source/_posts/2016-04-10-iOS开发企业证书申请过程全记录.md","hash":"ee927eb7524ee0c3af215ee9f6bdaf6c75a09d2d","modified":1471015204000},{"_id":"source/_posts/2016-05-08-2016年5月开发问题记录.md","hash":"4363af2cad368bd6d1d280265cb554d04aed37b9","modified":1471015204000},{"_id":"source/_posts/2016-05-09-MVVMTutorialwithReactiveCocoaPart2(翻译).md","hash":"74e5399d78af3e9089464e358afc83b047a52564","modified":1471015204000},{"_id":"source/_posts/2016-05-29-自定义NSOperation的那些事.md","hash":"de06841fc6f333fb0b3f5d4b7aef65dbad06ee7f","modified":1471015204000},{"_id":"source/_posts/2016-06-05-2016年6月开发问题记录.md","hash":"5df1068bd5bc8f27b27a538f74d9290659385ac8","modified":1471015204000},{"_id":"source/_posts/2016-06-11-打造自己的翻墙VPS:搬运工VPS购买使用流程全记录.md","hash":"cb837a2d91744acf660d08ad8b0e6bf3fd76d10d","modified":1471015204000},{"_id":"source/_posts/2016-06-29-GMTC全球移动技术大会见闻.md","hash":"4e5bda0d2dcc2c025c0f468522f7940bc3b3cc63","modified":1471015204000},{"_id":"source/_posts/2016-07-01-从jekyll迁移到hexo.md","hash":"c8f1be0c72a236d37c5c52dcb9883febe8bb11d8","modified":1471015204000},{"_id":"source/_posts/2016-07-03-Could-not-load-the-xxx-image-referenced-from-a-nib-in-the-bundle-with-identifier-xxxx问题.md","hash":"7fb7e9089bee23ef7f63abf5dae954d4a45b8e55","modified":1471015204000},{"_id":"source/_posts/2016-07-03-UILabel设置lineBreakMode属性无效.md","hash":"ed7e90d20a6c9fc4814387f57fac5ab456a17245","modified":1471015204000},{"_id":"source/_posts/2016-07-03-用XCode8打开Xib后项目不能在XCode7上运行.md","hash":"120de38767ed7691938be65a16ee80ed4dc1b18a","modified":1471015204000},{"_id":"source/_posts/2016-07-03-设置富文本字间距，文字不能居中对齐.md","hash":"f75fe31146e376a1fd02635b749969acf02192d9","modified":1471015204000},{"_id":"source/_posts/2016-07-10-深入理解CoreAnimation的fillMode和isRemovedOnCompletion.md","hash":"162126cfd7fe6e1bd9f6f23e603c1cf8dfda812e","modified":1471015204000},{"_id":"source/_posts/2016-07-26-UIButton设置标题无效.md","hash":"1fcc184d9dcaee9424f3e314be1d2e42ee464d79","modified":1471015204000},{"_id":"source/_posts/2016-07-30-使用HTTPS方法clone下来的Git仓库push时报错.md","hash":"3c2a0cc480beda087fae8ad425d564f5e478d083","modified":1471160551000},{"_id":"source/_posts/2016-08-07-在VPS上搭建Git服务器.md","hash":"5391bc838635db868f8c11e4c65a205fdfbacec9","modified":1471015204000},{"_id":"source/_posts/2016-08-24-使用ownCloud作为OmniFocus的云同步服务器.md","hash":"94c8f1e874f253beb5c85fc683c0044089e78420","modified":1472056444000},{"_id":"source/images/favicon.ico","hash":"195dab033350d8bdb617378c719e1184e7d7845a","modified":1471015204000},{"_id":"source/categories/index.md","hash":"625a9dd629be6760ea4d80df7fd95bc57ee55ee9","modified":1471015204000},{"_id":"source/tags/index.md","hash":"7c90e297c92dcc793b9e911f6d75f7977081bdbb","modified":1471015204000},{"_id":"themes/next/.git/COMMIT_EDITMSG","hash":"6070278c2e3b31bc1e40c485f66da5336bd2cbb0","modified":1471163707000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1471160754000},{"_id":"themes/next/.git/config","hash":"70dd828a531c8cf4f912e109f75ef5f583173279","modified":1471160754000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1471160444000},{"_id":"themes/next/.git/index","hash":"c6e989f7c36d2fec3c1ea4786f9a829fb3271307","modified":1471163707000},{"_id":"themes/next/.git/packed-refs","hash":"c260c6d28e96faeec8fe2ead52f6103d079e2f0c","modified":1471160754000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1471160754000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1471160754000},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1471160754000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1471160754000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1471160754000},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1471160754000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1471160754000},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1471160754000},{"_id":"themes/next/languages/pt-BR.yml","hash":"462aa865ca3d479bcf6b363cba61247b50f230ff","modified":1471160754000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1471160754000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1471160754000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"bea452bc49aed171a210d09bd6cddc4e846ea8ab","modified":1471160754000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1471160754000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1471160754000},{"_id":"themes/next/layout/_layout.swig","hash":"74157f6cfd679ea11febec632542793f37c5e5d4","modified":1471160754000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1471160754000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1471160754000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1471160754000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1471160754000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1471160754000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1471160754000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1471160754000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1471160754000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1471160754000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1471160754000},{"_id":"source/images/cyclehead.png","hash":"1fa870e293d9b5e32cc4f7451f2c62fabdf1f9c9","modified":1471015204000},{"_id":"source/images/smallhead.png","hash":"0687a3fb4b724385888d78d8af89e4daa28ca5cc","modified":1471015204000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1471160754000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1471160444000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1471160444000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1471160444000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1471160444000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1471160444000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1471160444000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1471160444000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1471160444000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1471160444000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1471160444000},{"_id":"themes/next/.git/logs/HEAD","hash":"791885d16592eb2f178b98b9b75beb5b4b86f9ce","modified":1471163707000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1471160754000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1471160754000},{"_id":"themes/next/layout/_macro/post.swig","hash":"1ca03011bed92614832b1343b65be92183957dc5","modified":1471160754000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1471160754000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1a77843ce5eac62151dc3d38f0a36c43e19e1a74","modified":1471160754000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"b73f9443bee2d3ea383aad52e49ffca8aa97dcc2","modified":1471160754000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1471160754000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4fe588ff8ba8587885c2936db2df490774f89e10","modified":1471160754000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b0c495b8154ef8b2d2cb0a554e164ff22cdc962","modified":1471160754000},{"_id":"themes/next/layout/_partials/header.swig","hash":"eb028685cb3c329537bbced06c063d23e6a33817","modified":1471160754000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1471160754000},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1471160754000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1471160754000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1471160754000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1471160754000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1471160754000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1471160754000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1471160754000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1471160754000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1471160754000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1471160754000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1471160754000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1471160754000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1471160754000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1471160754000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1471160754000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1471160754000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1471160754000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1471160754000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1471160754000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1471160754000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1471160754000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1471160754000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1471160754000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1471160754000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1471160754000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1471160754000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1471160754000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1471160754000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1471160754000},{"_id":"themes/next/.git/objects/21/b2370f53fd95bb58211ba2363d31c6942d69c0","hash":"e7e9be380cb099808504fe6629370507f7b40116","modified":1471163707000},{"_id":"themes/next/.git/objects/ee/04c2cc14a5071f13e0bb9d35514b482b5ca992","hash":"e0ad889f3bd6a6f7fffcc4cf01a30ce1b6ff4522","modified":1471163704000},{"_id":"themes/next/.git/objects/52/b1b146bd7c087f08280db6ce41fb012edc0b51","hash":"26891ec435c1d285b01ed4279547c4134dbf35df","modified":1471163707000},{"_id":"themes/next/.git/refs/heads/master","hash":"08337c7c61715aad6f3759d3fee02d7c012ed821","modified":1471163707000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1471160754000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1471160754000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1471160754000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1471160754000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1471160754000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1471160754000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1471160754000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1471160754000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1471160754000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1471160754000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1471160754000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1471160754000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"7f7148c8f52e4d3cfc070d964160362179fa8e91","modified":1471160754000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1471160754000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1471160754000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1471160754000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1471160754000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1471160754000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1471160754000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1471160754000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1471160754000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"17624186f7a1f28daddea258d044f8e03b2f4bea","modified":1471160754000},{"_id":"themes/next/source/vendors/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1471160754000},{"_id":"themes/next/source/vendors/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1471160754000},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1471160754000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1471160754000},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1471160754000},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1471160754000},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1471160754000},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1471160754000},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1471160754000},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1471160754000},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1471160754000},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1471160754000},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1471160754000},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1471160754000},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1471160754000},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1471160754000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1471160754000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1471160754000},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1471160754000},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1471160754000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1471160754000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1471160754000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1471160754000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1471160754000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1471160754000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1471160754000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1471160754000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1471160754000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1471160754000},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1471160754000},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1471160754000},{"_id":"themes/next/.git/objects/pack/pack-5182bfdb5614ae5dfee668f8addf954c0ab190af.idx","hash":"d2f74a227629f69096c221824076517f86dc9ead","modified":1471160748000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"791885d16592eb2f178b98b9b75beb5b4b86f9ce","modified":1471163707000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1471160754000},{"_id":"themes/next/.git/refs/remotes/origin/master","hash":"08337c7c61715aad6f3759d3fee02d7c012ed821","modified":1471163715000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1471160754000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1471160754000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"f9c6ee91c2a615edd8ca26edcc8a66b71883c238","modified":1471160754000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1471160754000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1471160754000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1471160754000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"bff3b18f56175c53f3bc6d733166c4d998e08732","modified":1471160754000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"696666141cdd204fd8818ac2ad18f05e320f8587","modified":1471160754000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1471160754000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1471160754000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1471160754000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1471160754000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1471160754000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1471160754000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1471160754000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1471160754000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1471160754000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1471160754000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1471160754000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1471160754000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1471160754000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1471160754000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1471160754000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1471160754000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1471160754000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1471160754000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1471160754000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1471160754000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1471160754000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1471160754000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1471160754000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1471160754000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1471160754000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1471160754000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1471160754000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1471160754000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1471160754000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1471160754000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1471160754000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1471160754000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1471160754000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1471160754000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1471160754000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1471160754000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1471160754000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1471160754000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1471160754000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1471160754000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1471160754000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1471160754000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1471160754000},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1471160754000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1471160754000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1471160754000},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1471160754000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"ec14f8846bf817c2635b962abbdcafec15047582","modified":1471160754000},{"_id":"themes/next/.git/logs/refs/remotes/origin/master","hash":"840130a70fbcb654b8183efdd81f0befc8b5a5e7","modified":1471163715000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1471160754000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1471160754000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1471160754000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1471160754000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1471160754000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1471160754000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1471160754000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1471160754000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1471160754000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1471160754000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1471160754000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1471160754000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1471160754000},{"_id":"themes/next/.git/objects/pack/pack-5182bfdb5614ae5dfee668f8addf954c0ab190af.pack","hash":"5d566632504b87ecfaa3d9bd0ff5401a974682d9","modified":1471160748000},{"_id":"public/atom.xml","hash":"15d71b9376ebc05e145213a382089615e08719d0","modified":1472056909164},{"_id":"public/categories/index.html","hash":"902cf49d07cb2e062448549c1d8201c6f898394c","modified":1472056909203},{"_id":"public/tags/index.html","hash":"3e5235953949e777fe97f35ed1e3c6e43496a6e9","modified":1472056909203},{"_id":"public/2016/07/03/用XCode8打开Xib后项目不能在XCode7上运行/index.html","hash":"b6a8b8cf4d6fa186c6d43671bfa6f227a2077b54","modified":1472056909203},{"_id":"public/2016/07/03/Could-not-load-the-xxx-image-referenced-from-a-nib-in-the-bundle-with-identifier-xxxx问题/index.html","hash":"0251f794350a79aa164de40203179f6fa1a9a0ae","modified":1472056909203},{"_id":"public/2015/10/03/博客新家/index.html","hash":"efb96e7adb1afafd585156c44e7cbe0d792371c9","modified":1472056909203},{"_id":"public/archives/2015/page/2/index.html","hash":"2497fa20901c52158e47e29f5d5b1e210ff99187","modified":1472056909203},{"_id":"public/archives/2015/11/index.html","hash":"49e6ffa254ae145c204ed2f7ffa106a1f8f2b03a","modified":1472056909203},{"_id":"public/archives/2015/12/index.html","hash":"aa16be7321ca9bb877758fbc95d6b68d6e6a7b0a","modified":1472056909203},{"_id":"public/archives/2016/01/index.html","hash":"8dc57c744de484a9ade51c3d7b137c2d923b5079","modified":1472056909203},{"_id":"public/archives/2016/04/index.html","hash":"a8df49e1fff736a1df815cddf1a1f19e8d440860","modified":1472056909203},{"_id":"public/archives/2016/05/index.html","hash":"f598332303146ccb98e05c0e82dbe9277148edc5","modified":1472056909204},{"_id":"public/archives/2016/06/index.html","hash":"0ca27dad9fc7ba06afc752f44eb6f5b1ae5d4868","modified":1472056909204},{"_id":"public/archives/2016/08/index.html","hash":"bdb87e820517f5ed8baeecbe2226ffb3f594a900","modified":1472056909204},{"_id":"public/categories/其他/index.html","hash":"b0c214d72f4d1be1a832310a50359f8c4dd3b918","modified":1472056909204},{"_id":"public/categories/iOS-Tips/index.html","hash":"7b52523854b3315a8087839be26533979a18b389","modified":1472056909204},{"_id":"public/categories/Git/index.html","hash":"6d208fa145e4caeb45496bb8c446bb51747a9a53","modified":1472056909204},{"_id":"public/tags/iOS开发/index.html","hash":"fe790102d731a200ffcfcf31bb48473c8e1d9957","modified":1472056909204},{"_id":"public/tags/Emoji表情/index.html","hash":"d296cccefd5fc8a45295781d33f8242cfaa29e82","modified":1472056909204},{"_id":"public/tags/Hexo/index.html","hash":"e18363e1b08b99acd7735529f3e5b766fb1badea","modified":1472056909204},{"_id":"public/tags/其他/index.html","hash":"1060260b831f8132f5e913caed9bc7dd7ff82389","modified":1472056909204},{"_id":"public/tags/UILabel/index.html","hash":"3de627283932ba88ed87d1a2d22cca15ede8a5f9","modified":1472056909204},{"_id":"public/tags/NSAttributedString/index.html","hash":"3c48b2512db7a8cc5485a0b920d916ae8074ece0","modified":1472056909204},{"_id":"public/tags/CoreAnimation/index.html","hash":"37d00d9ab5cb50dbb46621a9ab398a1a7a34e752","modified":1472056909204},{"_id":"public/tags/UIButton/index.html","hash":"36723acdd1bf87800921c397e33339d9fc9e0b5d","modified":1472056909204},{"_id":"public/tags/Git/index.html","hash":"bb3c5ed32919846019535655b65f303541a8f6bd","modified":1472056909204},{"_id":"public/tags/WebDAV/index.html","hash":"60947495c7c6ff88bac5c93fe7de9264fb45c9cf","modified":1472056909205},{"_id":"public/tags/ownCloud/index.html","hash":"1fb618323e0876d6efbec5c33ead581c765909f7","modified":1472056909205},{"_id":"public/2016/08/24/使用ownCloud作为OmniFocus的云同步服务器/index.html","hash":"be9fe2e7eb4ebc69192cfcce8a3429d0853e80db","modified":1472056909205},{"_id":"public/2016/08/07/在VPS上搭建Git服务器/index.html","hash":"a1436eedd45567017ea3cd9cff3d6f17cef812b6","modified":1472056909205},{"_id":"public/2016/07/30/使用HTTPS方法clone下来的Git仓库push时报错/index.html","hash":"7192c1eef3e023684cb81ae34b42336ea3eaf979","modified":1472056909205},{"_id":"public/2016/07/26/UIButton设置标题无效/index.html","hash":"3a5a4aafa70a8ecb69e88139ecb76232169cf310","modified":1472056909205},{"_id":"public/2016/07/10/深入理解CoreAnimation的fillMode和isRemovedOnCompletion/index.html","hash":"3bdc10de339957ca8f367de8b634bd9377ba7742","modified":1472056909205},{"_id":"public/2016/07/03/设置富文本字间距，文字不能居中对齐/index.html","hash":"3bf45ba80a33e447ba0e9d15ce784b7ded8cf859","modified":1472056909205},{"_id":"public/2016/07/03/UILabel设置lineBreakMode属性无效/index.html","hash":"178256ccdb3041c9e369024177149fd7e4765f31","modified":1472056909205},{"_id":"public/2016/07/01/从jekyll迁移到hexo/index.html","hash":"668baa0fc813175f6fab922449aba3748ba50523","modified":1472056909205},{"_id":"public/2016/06/29/GMTC全球移动技术大会见闻/index.html","hash":"29055acb2b5503ac0df79e13980088f79ab2265f","modified":1472056909205},{"_id":"public/2016/06/11/打造自己的翻墙VPS:搬运工VPS购买使用流程全记录/index.html","hash":"fba9dc4f958948042ae3df83d121fd09c2a77775","modified":1472056909205},{"_id":"public/2016/06/05/2016年6月开发问题记录/index.html","hash":"f5a325afac59ec4cde98715c8722374c6681ab05","modified":1472056909205},{"_id":"public/2016/05/29/自定义NSOperation的那些事/index.html","hash":"e0d5d8210f9d04f737954c8a7666d27b0a295f6f","modified":1472056909205},{"_id":"public/2016/05/09/MVVMTutorialwithReactiveCocoaPart2(翻译)/index.html","hash":"c04cee6f06cd882e83dc763e720f3f37f9a36af4","modified":1472056909205},{"_id":"public/2016/05/08/2016年5月开发问题记录/index.html","hash":"edad8d51826f8a255c7b3fc696b167d927e258ac","modified":1472056909205},{"_id":"public/2016/04/10/iOS开发企业证书申请过程全记录/index.html","hash":"88804a3f26964e680a32d63ad0fd7fc059c2edbe","modified":1472056909205},{"_id":"public/2016/01/01/自动打包工具shenzhen使用简介/index.html","hash":"b43f265cf2d197100ac95a36027f462c33949492","modified":1472056909206},{"_id":"public/2015/12/27/《ios核心动画高级技巧》阅读笔记(1)/index.html","hash":"f7d45ec247d4a70a7a63d5d4aa8f0682cd240ab6","modified":1472056909206},{"_id":"public/2015/12/27/《ios核心动画高级技巧》阅读笔记(3)/index.html","hash":"fc31f29c058408a81b037b9072829427289b65b7","modified":1472056909206},{"_id":"public/2015/12/27/《ios核心动画高级技巧》阅读笔记(2)/index.html","hash":"28708b65bff6b2ee1a2f993d0e9c5141dee6aacc","modified":1472056909206},{"_id":"public/2015/12/20/RAC学习笔记/index.html","hash":"a317959f450980dcfe9ba8ab109bc400d4a9dd3c","modified":1472056909206},{"_id":"public/2015/12/13/CoreAnimation编程指南学习笔记(2)/index.html","hash":"98c4c2c2e4354b378614b938629e82a68bd6a3dc","modified":1472056909206},{"_id":"public/2015/12/06/CoreAnimation编程指南学习笔记(1)/index.html","hash":"1dc982fda4beac10ffd89c1f1c07325fcdc5be9e","modified":1472056909206},{"_id":"public/2015/11/07/ContentHugging与ContentCompressionResistance/index.html","hash":"ff4ad922de77b33384e97a62b140e06f911eb527","modified":1472056909206},{"_id":"public/2015/10/27/UIScrollView与Autolayout/index.html","hash":"d93de2fc356dfbb2a1a3dd3f373655ea63469b53","modified":1472056909206},{"_id":"public/2015/10/16/最近开发中遇到的一些问题/index.html","hash":"69da0e351f4e146752ab7747b82f61a505af4b44","modified":1472056909206},{"_id":"public/2015/10/07/《图解HTTP》读书笔记(3)/index.html","hash":"d5607b842b950af4667ff78050aa946233f705fb","modified":1472056909206},{"_id":"public/2015/10/06/《图解HTTP》读书笔记(2)/index.html","hash":"85812904c87a2e4811bb7191be4e6d61790e2157","modified":1472056909206},{"_id":"public/2015/10/05/《图解HTTP》读书笔记(1)/index.html","hash":"ef99500a7145a45dd69de90fe2b78e2999d09225","modified":1472056909206},{"_id":"public/2015/10/04/适配iOS9（ATS问题）/index.html","hash":"9f8d1b8b579d2fce4b9146f8fe181dd41e3b9543","modified":1472056909206},{"_id":"public/2015/10/04/NSURLProtocol的使用/index.html","hash":"f9e178236340bf7821bb138c94efc0e201ef8025","modified":1472056909206},{"_id":"public/2015/10/04/使用jekyll+GithubPage搭建个人博客系统/index.html","hash":"3b24293f2413090c95af552be4cea94ae6c7002f","modified":1472056909206},{"_id":"public/2015/10/04/iOS运行时初探-使用运行时机制向Category中添加属性/index.html","hash":"e1dd5b1cc2ff8ee754e1a91770d794a355c9b41d","modified":1472056909206},{"_id":"public/2015/10/04/iOS中的富文本技术(1)TextKit简介/index.html","hash":"56f63e47c67a57992948a6a74c6fd2cad5011992","modified":1472056909206},{"_id":"public/2015/10/04/iOS中的富文本技术(2)CoreText框架/index.html","hash":"1bbc37eddba21df06d2c921f678af17a92823135","modified":1472056909206},{"_id":"public/2015/10/04/iOS中的多线程编程/index.html","hash":"06fd1c7a1b90e69fe446f63a1096b1cab8ff162a","modified":1472056909206},{"_id":"public/2015/10/04/iOS中Emoji表情的判断/index.html","hash":"3a8d99bbf3eb16a23172538291b52269d3bee914","modified":1472056909206},{"_id":"public/archives/index.html","hash":"20ce8e153cca3d9590f81d52affbbd10d3b33e1a","modified":1472056909206},{"_id":"public/archives/page/2/index.html","hash":"e6ab129881a67ee9bbfdd6f86efe1944c047834f","modified":1472056909206},{"_id":"public/archives/2015/index.html","hash":"0b4430a33380230cef254645a03e7df3a5fa659e","modified":1472056909207},{"_id":"public/archives/2015/10/index.html","hash":"13650231b41f95a6342d201d864b2105e7818179","modified":1472056909207},{"_id":"public/archives/2016/index.html","hash":"4fda171595f6ecd7d22ba73f9a012f525201da49","modified":1472056909207},{"_id":"public/archives/2016/07/index.html","hash":"2d20bbc0f1f5fbaee1ef65a064381b0ef981bb82","modified":1472056909207},{"_id":"public/categories/iOS开发/index.html","hash":"c52f856bed32809a6e79a6ee909027cfb18ea8fe","modified":1472056909207},{"_id":"public/categories/读书笔记/index.html","hash":"4793a556e4ea4112a70cf6897b6a9266a63896bc","modified":1472056909207},{"_id":"public/index.html","hash":"7de313987910e3942a78388ff24038b9baeacd29","modified":1472056909207},{"_id":"public/page/2/index.html","hash":"c7793321a575f36d8ede79d39166a0cd4ddcb17d","modified":1472056909207},{"_id":"public/Staticfile","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472056909207},{"_id":"public/CNAME","hash":"ec600ca74a4560b8006ae601739a1985c8d0b12c","modified":1472056909216},{"_id":"public/README.md","hash":"6241eb736c81425f44c5ce61555c89e128cee41a","modified":1472056909216},{"_id":"public/images/favicon.ico","hash":"195dab033350d8bdb617378c719e1184e7d7845a","modified":1472056909216},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1472056909216},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1472056909216},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1472056909216},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1472056909216},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1472056909216},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1472056909216},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1472056909216},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1472056909216},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1472056909216},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1472056909216},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1472056909217},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1472056909217},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1472056909217},{"_id":"public/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1472056909217},{"_id":"public/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1472056909217},{"_id":"public/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1472056909217},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1472056909217},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1472056909217},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1472056909217},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1472056909217},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1472056909217},{"_id":"public/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1472056909217},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1472056909217},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1472056909217},{"_id":"public/images/cyclehead.png","hash":"1fa870e293d9b5e32cc4f7451f2c62fabdf1f9c9","modified":1472056909919},{"_id":"public/images/smallhead.png","hash":"0687a3fb4b724385888d78d8af89e4daa28ca5cc","modified":1472056909919},{"_id":"public/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1472056909923},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1472056909923},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1472056909923},{"_id":"public/vendors/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1472056909929},{"_id":"public/vendors/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1472056909929},{"_id":"public/vendors/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1472056909929},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1472056909929},{"_id":"public/vendors/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1472056909929},{"_id":"public/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1472056909929},{"_id":"public/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1472056909929},{"_id":"public/vendors/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1472056909929},{"_id":"public/vendors/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1472056909929},{"_id":"public/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1472056909929},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1472056909930},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1472056909930},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1472056909930},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1472056909930},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1472056909930},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1472056909930},{"_id":"public/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1472056909930},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1472056909930},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1472056909930},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1472056909930},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1472056909930},{"_id":"public/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1472056909930},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1472056909930},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1472056909930},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1472056909930},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1472056909930},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1472056909931},{"_id":"public/css/main.css","hash":"38bd2159c1d19f6d6a50eda3ef942a46ffb925ba","modified":1472056909931},{"_id":"public/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1472056909932},{"_id":"public/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1472056909932},{"_id":"public/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1472056909932},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1472056909932},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1472056909932},{"_id":"public/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1472056909932},{"_id":"public/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1472056909932},{"_id":"public/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1472056909932},{"_id":"public/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1472056909932},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1472056909932},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1472056909944}],"Category":[{"name":"其他","_id":"cis94oa9r0004zrm02ijvrmd0"},{"name":"iOS开发","_id":"cis94oaa30009zrm0gi3u9z7a"},{"name":"读书笔记","_id":"cis94oaaq000uzrm0pe62umv7"},{"name":"iOS Tips","_id":"cis94oabi001lzrm0efe9rjlg"},{"name":"Git","_id":"cis94oach002izrm057yfxoxq"}],"Data":[],"Page":[{"title":"categories","date":"2016-07-01T10:48:41.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-07-01 18:48:41\ntype: \"categories\" # 类型\ncomments: false # 关闭评论\n---\n","updated":"2016-08-12T15:20:04.000Z","path":"categories/index.html","layout":"page","_id":"cis94oa9k0001zrm0jrdwyv33","content":"","excerpt":"","more":""},{"title":"tags","date":"2016-07-01T10:40:34.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-07-01 18:40:34\ntype: \"tags\" # 类型\ncomments: false # 关闭评论\n---\n","updated":"2016-08-12T15:20:04.000Z","path":"tags/index.html","layout":"page","_id":"cis94oa9o0003zrm0hmcq1gww","content":"","excerpt":"","more":""}],"Post":[{"layout":"post","title":"博客新家","_content":"\n终于有了自己的个人博客，以后要坚持写博客，记录自己的学习，生活，工作。\n\n以前写的博客会陆续搬过来。\n\n来段代码吧！！！\n```objectivec\nNSString * str = @\"I love coding!!\";\nNSLog(@\"%@\", str);\n```\n","source":"_posts/2015-10-03-博客新家.md","raw":"---\nlayout: post\ntitle: \"博客新家\"\ncategories: 其他\n---\n\n终于有了自己的个人博客，以后要坚持写博客，记录自己的学习，生活，工作。\n\n以前写的博客会陆续搬过来。\n\n来段代码吧！！！\n```objectivec\nNSString * str = @\"I love coding!!\";\nNSLog(@\"%@\", str);\n```\n","slug":"博客新家","published":1,"date":"2015-10-02T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oa9d0000zrm0zpcnt0np","content":"<p>终于有了自己的个人博客，以后要坚持写博客，记录自己的学习，生活，工作。</p>\n<p>以前写的博客会陆续搬过来。</p>\n<p>来段代码吧！！！<br><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> * str = <span class=\"string\">@\"I love coding!!\"</span>;</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, str);</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>终于有了自己的个人博客，以后要坚持写博客，记录自己的学习，生活，工作。</p>\n<p>以前写的博客会陆续搬过来。</p>\n<p>来段代码吧！！！<br><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> * str = <span class=\"string\">@\"I love coding!!\"</span>;</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, str);</div></pre></td></tr></table></figure></p>\n"},{"layout":"post","title":"NSURLProtocol的使用","_content":"\n###NSURLProtocol的使用\n\nNSURLProtocol可以拦截所有由[URL Loading System](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i)发起的请求，可用于实现以下功能：\n\n * 重定向网络请求，实现代理等功能\n * 实现网络缓存\n * 全局设置网络请求\n * 自定义网络请求返回结果\n\n具体的实现步骤如下：\n\n**第一步** 创建NSURLProtocol的子类，重写以下方法\n\n`+ (BOOL)canInitWithRequest:(NSURLRequest *)request`这个方法用来返回是否需要处理这个请求，如果需要处理，返回YES，否则返回NO。在该方法中可以对不需要处理的请求进行过滤。\n\n`+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request`重写该方法，可以对请求进行修改，例如添加新的头部信息，修改，修改url等，返回修改后的请求。\n\n`+ (BOOL)requestIsCacheEquivalent:(NSURLRequest *)a toRequest:(NSURLRequest *)b`该方法主要用来判断两个请求是否是同一个请求，如果是，则可以使用缓存数据，通常只需要调用父类的实现即可\n\n`- (void)startLoading`重写该方法，需要在该方法中发起一个请求，对于NSURLConnection来说，就是创建一个NSURLConnection，对于NSURLSession，就是发起一个NSURLSessionTask\n\n`- (void)stopLoading`重写该方法，需要停止响应的请求\n\n**第二步** 实现相应的协议代理方法，对NSURLConnection来说，要实现NSURLConnectionDataDelegate代理方法，对于NSURLSession来说，需要实现NSURLSessionTaskDelegate代理方法。在这些代理方法中，需要使用NSURLProtocolClient来通知URL Loading System。具体实现方式详见示例代码。\n\n**第三步** 在合适的位置注册自定义的NSURLProtocol子类。调用`[NSURLProtocol registerClass:[MyURLProtocol class]]`进行注册，调用`[NSURLProtocol unregisterClass:[MyURLProtocol class]]`可以注销。注意，代码中可以注册多个NSURLProtocol子类，每个子类可以\n\n以上就是整个实现过程，详细内容可以参见代码。\n\n代码地址:[NSURLProtocolDemo](https://github.com/liujinlongxa/NSURLProtocolDemo)\n","source":"_posts/2015-10-04-NSURLProtocol的使用.md","raw":"---\nlayout: post\ntitle: \"NSURLProtocol的使用\"\ncategories: \"iOS开发\"\n---\n\n###NSURLProtocol的使用\n\nNSURLProtocol可以拦截所有由[URL Loading System](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i)发起的请求，可用于实现以下功能：\n\n * 重定向网络请求，实现代理等功能\n * 实现网络缓存\n * 全局设置网络请求\n * 自定义网络请求返回结果\n\n具体的实现步骤如下：\n\n**第一步** 创建NSURLProtocol的子类，重写以下方法\n\n`+ (BOOL)canInitWithRequest:(NSURLRequest *)request`这个方法用来返回是否需要处理这个请求，如果需要处理，返回YES，否则返回NO。在该方法中可以对不需要处理的请求进行过滤。\n\n`+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request`重写该方法，可以对请求进行修改，例如添加新的头部信息，修改，修改url等，返回修改后的请求。\n\n`+ (BOOL)requestIsCacheEquivalent:(NSURLRequest *)a toRequest:(NSURLRequest *)b`该方法主要用来判断两个请求是否是同一个请求，如果是，则可以使用缓存数据，通常只需要调用父类的实现即可\n\n`- (void)startLoading`重写该方法，需要在该方法中发起一个请求，对于NSURLConnection来说，就是创建一个NSURLConnection，对于NSURLSession，就是发起一个NSURLSessionTask\n\n`- (void)stopLoading`重写该方法，需要停止响应的请求\n\n**第二步** 实现相应的协议代理方法，对NSURLConnection来说，要实现NSURLConnectionDataDelegate代理方法，对于NSURLSession来说，需要实现NSURLSessionTaskDelegate代理方法。在这些代理方法中，需要使用NSURLProtocolClient来通知URL Loading System。具体实现方式详见示例代码。\n\n**第三步** 在合适的位置注册自定义的NSURLProtocol子类。调用`[NSURLProtocol registerClass:[MyURLProtocol class]]`进行注册，调用`[NSURLProtocol unregisterClass:[MyURLProtocol class]]`可以注销。注意，代码中可以注册多个NSURLProtocol子类，每个子类可以\n\n以上就是整个实现过程，详细内容可以参见代码。\n\n代码地址:[NSURLProtocolDemo](https://github.com/liujinlongxa/NSURLProtocolDemo)\n","slug":"NSURLProtocol的使用","published":1,"date":"2015-10-03T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oa9m0002zrm0xp5rj3ju","content":"<p>###NSURLProtocol的使用</p>\n<p>NSURLProtocol可以拦截所有由<a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i\" target=\"_blank\" rel=\"external\">URL Loading System</a>发起的请求，可用于实现以下功能：</p>\n<ul>\n<li>重定向网络请求，实现代理等功能</li>\n<li>实现网络缓存</li>\n<li>全局设置网络请求</li>\n<li>自定义网络请求返回结果</li>\n</ul>\n<p>具体的实现步骤如下：</p>\n<p><strong>第一步</strong> 创建NSURLProtocol的子类，重写以下方法</p>\n<p><code>+ (BOOL)canInitWithRequest:(NSURLRequest *)request</code>这个方法用来返回是否需要处理这个请求，如果需要处理，返回YES，否则返回NO。在该方法中可以对不需要处理的请求进行过滤。</p>\n<p><code>+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request</code>重写该方法，可以对请求进行修改，例如添加新的头部信息，修改，修改url等，返回修改后的请求。</p>\n<p><code>+ (BOOL)requestIsCacheEquivalent:(NSURLRequest *)a toRequest:(NSURLRequest *)b</code>该方法主要用来判断两个请求是否是同一个请求，如果是，则可以使用缓存数据，通常只需要调用父类的实现即可</p>\n<p><code>- (void)startLoading</code>重写该方法，需要在该方法中发起一个请求，对于NSURLConnection来说，就是创建一个NSURLConnection，对于NSURLSession，就是发起一个NSURLSessionTask</p>\n<p><code>- (void)stopLoading</code>重写该方法，需要停止响应的请求</p>\n<p><strong>第二步</strong> 实现相应的协议代理方法，对NSURLConnection来说，要实现NSURLConnectionDataDelegate代理方法，对于NSURLSession来说，需要实现NSURLSessionTaskDelegate代理方法。在这些代理方法中，需要使用NSURLProtocolClient来通知URL Loading System。具体实现方式详见示例代码。</p>\n<p><strong>第三步</strong> 在合适的位置注册自定义的NSURLProtocol子类。调用<code>[NSURLProtocol registerClass:[MyURLProtocol class]]</code>进行注册，调用<code>[NSURLProtocol unregisterClass:[MyURLProtocol class]]</code>可以注销。注意，代码中可以注册多个NSURLProtocol子类，每个子类可以</p>\n<p>以上就是整个实现过程，详细内容可以参见代码。</p>\n<p>代码地址:<a href=\"https://github.com/liujinlongxa/NSURLProtocolDemo\" target=\"_blank\" rel=\"external\">NSURLProtocolDemo</a></p>\n","excerpt":"","more":"<p>###NSURLProtocol的使用</p>\n<p>NSURLProtocol可以拦截所有由<a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i\">URL Loading System</a>发起的请求，可用于实现以下功能：</p>\n<ul>\n<li>重定向网络请求，实现代理等功能</li>\n<li>实现网络缓存</li>\n<li>全局设置网络请求</li>\n<li>自定义网络请求返回结果</li>\n</ul>\n<p>具体的实现步骤如下：</p>\n<p><strong>第一步</strong> 创建NSURLProtocol的子类，重写以下方法</p>\n<p><code>+ (BOOL)canInitWithRequest:(NSURLRequest *)request</code>这个方法用来返回是否需要处理这个请求，如果需要处理，返回YES，否则返回NO。在该方法中可以对不需要处理的请求进行过滤。</p>\n<p><code>+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request</code>重写该方法，可以对请求进行修改，例如添加新的头部信息，修改，修改url等，返回修改后的请求。</p>\n<p><code>+ (BOOL)requestIsCacheEquivalent:(NSURLRequest *)a toRequest:(NSURLRequest *)b</code>该方法主要用来判断两个请求是否是同一个请求，如果是，则可以使用缓存数据，通常只需要调用父类的实现即可</p>\n<p><code>- (void)startLoading</code>重写该方法，需要在该方法中发起一个请求，对于NSURLConnection来说，就是创建一个NSURLConnection，对于NSURLSession，就是发起一个NSURLSessionTask</p>\n<p><code>- (void)stopLoading</code>重写该方法，需要停止响应的请求</p>\n<p><strong>第二步</strong> 实现相应的协议代理方法，对NSURLConnection来说，要实现NSURLConnectionDataDelegate代理方法，对于NSURLSession来说，需要实现NSURLSessionTaskDelegate代理方法。在这些代理方法中，需要使用NSURLProtocolClient来通知URL Loading System。具体实现方式详见示例代码。</p>\n<p><strong>第三步</strong> 在合适的位置注册自定义的NSURLProtocol子类。调用<code>[NSURLProtocol registerClass:[MyURLProtocol class]]</code>进行注册，调用<code>[NSURLProtocol unregisterClass:[MyURLProtocol class]]</code>可以注销。注意，代码中可以注册多个NSURLProtocol子类，每个子类可以</p>\n<p>以上就是整个实现过程，详细内容可以参见代码。</p>\n<p>代码地址:<a href=\"https://github.com/liujinlongxa/NSURLProtocolDemo\">NSURLProtocolDemo</a></p>\n"},{"layout":"post","title":"iOS中Emoji表情的判断","_content":"\n##问题\n服务器端不支持Emoji表情，因此客户端在上传用户输入时，不能包含Emoji表情。\n\n##解决方案\n在客户端发送请求前，判断用户输入中是否含有表情，如果含有表情，则提示用户重新输入。这个过程关键是如何判断字符串中是否含有Emoji表情。要判断是否含有Emoji表情，\n必须先了解什么是Emoji。\n> Emoji 是一套起源于日本的12x12像素表情符号，由栗田穣崇(Shigetaka Kurit)创作，最早在日本网络及手机用户中流行，自苹果公司发布的iOS 5输入法中加入了emoji后，这种表情符号开始席卷全球，目前emoji已被大多数现代计算机系统所兼容的Unicode编码采纳，普遍应用于各种手机短信和社交网络中。\n\n以上是摘自百度百科里的一段话，Emoji表情最终会被编码成Unicode，因此，只要知道Emoji表情的Unicode编码的范围，就可以判断用户是否输入了Emoji表情。以下是具体代码，\n我这里写成了NSString的一个分类\n\n```objectivec\n@implementation NSString (Emoji)\n\n+ (BOOL)stringContainsEmoji:(NSString *)string\n{\n    __block BOOL returnValue = NO;\n\n    [string enumerateSubstringsInRange:NSMakeRange(0, [string length])\n    options:NSStringEnumerationByComposedCharacterSequences\n    usingBlock:^(NSString *substring, NSRange substringRange, NSRange enclosingRange, BOOL *stop) {\n        const unichar hs = [substring characterAtIndex:0];\n        if (0xd800 <= hs && hs <= 0xdbff) {\n            if (substring.length > 1) {\n                const unichar ls = [substring characterAtIndex:1];\n                const int uc = ((hs - 0xd800) * 0x400) + (ls - 0xdc00) + 0x10000;\n                if (0x1d000 <= uc && uc <= 0x1f77f) {\n                    returnValue = YES;\n                }\n            }\n        } else if (substring.length > 1) {\n            const unichar ls = [substring characterAtIndex:1];\n            if (ls == 0x20e3) {\n                returnValue = YES;\n            }\n        } else {\n            if (0x2100 <= hs && hs <= 0x27ff) {\n                returnValue = YES;\n            } else if (0x2B05 <= hs && hs <= 0x2b07) {\n                returnValue = YES;\n            } else if (0x2934 <= hs && hs <= 0x2935) {\n                returnValue = YES;\n            } else if (0x3297 <= hs && hs <= 0x3299) {\n                returnValue = YES;\n            } else if (hs == 0xa9 || hs == 0xae || hs == 0x303d || hs == 0x3030 || hs == 0x2b55 || hs == 0x2b1c || hs == 0x2b1b || hs == 0x2b50) {\n                returnValue = YES;\n            }\n        }\n    }];\n\n    return returnValue;\n}\n```\n\n这段代码并非本人原创，也是取自互联网，经测试好使，分享给大家。\n\n原博客地址: [iOS中Emoji表情的判断](http://blog.csdn.net/liujinlongxa/article/details/44207003)\n","source":"_posts/2015-10-04-iOS中Emoji表情的判断.md","raw":"---\nlayout: post\ntitle: \"iOS中Emoji表情的判断\"\ncategories: iOS开发\ntags:\n    - iOS开发\n    - Emoji表情\n---\n\n##问题\n服务器端不支持Emoji表情，因此客户端在上传用户输入时，不能包含Emoji表情。\n\n##解决方案\n在客户端发送请求前，判断用户输入中是否含有表情，如果含有表情，则提示用户重新输入。这个过程关键是如何判断字符串中是否含有Emoji表情。要判断是否含有Emoji表情，\n必须先了解什么是Emoji。\n> Emoji 是一套起源于日本的12x12像素表情符号，由栗田穣崇(Shigetaka Kurit)创作，最早在日本网络及手机用户中流行，自苹果公司发布的iOS 5输入法中加入了emoji后，这种表情符号开始席卷全球，目前emoji已被大多数现代计算机系统所兼容的Unicode编码采纳，普遍应用于各种手机短信和社交网络中。\n\n以上是摘自百度百科里的一段话，Emoji表情最终会被编码成Unicode，因此，只要知道Emoji表情的Unicode编码的范围，就可以判断用户是否输入了Emoji表情。以下是具体代码，\n我这里写成了NSString的一个分类\n\n```objectivec\n@implementation NSString (Emoji)\n\n+ (BOOL)stringContainsEmoji:(NSString *)string\n{\n    __block BOOL returnValue = NO;\n\n    [string enumerateSubstringsInRange:NSMakeRange(0, [string length])\n    options:NSStringEnumerationByComposedCharacterSequences\n    usingBlock:^(NSString *substring, NSRange substringRange, NSRange enclosingRange, BOOL *stop) {\n        const unichar hs = [substring characterAtIndex:0];\n        if (0xd800 <= hs && hs <= 0xdbff) {\n            if (substring.length > 1) {\n                const unichar ls = [substring characterAtIndex:1];\n                const int uc = ((hs - 0xd800) * 0x400) + (ls - 0xdc00) + 0x10000;\n                if (0x1d000 <= uc && uc <= 0x1f77f) {\n                    returnValue = YES;\n                }\n            }\n        } else if (substring.length > 1) {\n            const unichar ls = [substring characterAtIndex:1];\n            if (ls == 0x20e3) {\n                returnValue = YES;\n            }\n        } else {\n            if (0x2100 <= hs && hs <= 0x27ff) {\n                returnValue = YES;\n            } else if (0x2B05 <= hs && hs <= 0x2b07) {\n                returnValue = YES;\n            } else if (0x2934 <= hs && hs <= 0x2935) {\n                returnValue = YES;\n            } else if (0x3297 <= hs && hs <= 0x3299) {\n                returnValue = YES;\n            } else if (hs == 0xa9 || hs == 0xae || hs == 0x303d || hs == 0x3030 || hs == 0x2b55 || hs == 0x2b1c || hs == 0x2b1b || hs == 0x2b50) {\n                returnValue = YES;\n            }\n        }\n    }];\n\n    return returnValue;\n}\n```\n\n这段代码并非本人原创，也是取自互联网，经测试好使，分享给大家。\n\n原博客地址: [iOS中Emoji表情的判断](http://blog.csdn.net/liujinlongxa/article/details/44207003)\n","slug":"iOS中Emoji表情的判断","published":1,"date":"2015-10-03T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oa9v0005zrm0eeqes0ah","content":"<p>##问题<br>服务器端不支持Emoji表情，因此客户端在上传用户输入时，不能包含Emoji表情。</p>\n<p>##解决方案<br>在客户端发送请求前，判断用户输入中是否含有表情，如果含有表情，则提示用户重新输入。这个过程关键是如何判断字符串中是否含有Emoji表情。要判断是否含有Emoji表情，<br>必须先了解什么是Emoji。</p>\n<blockquote>\n<p>Emoji 是一套起源于日本的12x12像素表情符号，由栗田穣崇(Shigetaka Kurit)创作，最早在日本网络及手机用户中流行，自苹果公司发布的iOS 5输入法中加入了emoji后，这种表情符号开始席卷全球，目前emoji已被大多数现代计算机系统所兼容的Unicode编码采纳，普遍应用于各种手机短信和社交网络中。</p>\n</blockquote>\n<p>以上是摘自百度百科里的一段话，Emoji表情最终会被编码成Unicode，因此，只要知道Emoji表情的Unicode编码的范围，就可以判断用户是否输入了Emoji表情。以下是具体代码，<br>我这里写成了NSString的一个分类</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSString</span> (<span class=\"title\">Emoji</span>)</span></div><div class=\"line\"></div><div class=\"line\">+ (<span class=\"built_in\">BOOL</span>)stringContainsEmoji:(<span class=\"built_in\">NSString</span> *)string</div><div class=\"line\">&#123;</div><div class=\"line\">    __block <span class=\"built_in\">BOOL</span> returnValue = <span class=\"literal\">NO</span>;</div><div class=\"line\"></div><div class=\"line\">    [string enumerateSubstringsInRange:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, [string length])</div><div class=\"line\">    options:<span class=\"built_in\">NSStringEnumerationByComposedCharacterSequences</span></div><div class=\"line\">    usingBlock:^(<span class=\"built_in\">NSString</span> *substring, <span class=\"built_in\">NSRange</span> substringRange, <span class=\"built_in\">NSRange</span> enclosingRange, <span class=\"built_in\">BOOL</span> *stop) &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">unichar</span> hs = [substring characterAtIndex:<span class=\"number\">0</span>];</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">0xd800</span> &lt;= hs &amp;&amp; hs &lt;= <span class=\"number\">0xdbff</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (substring.length &gt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">const</span> <span class=\"keyword\">unichar</span> ls = [substring characterAtIndex:<span class=\"number\">1</span>];</div><div class=\"line\">                <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> uc = ((hs - <span class=\"number\">0xd800</span>) * <span class=\"number\">0x400</span>) + (ls - <span class=\"number\">0xdc00</span>) + <span class=\"number\">0x10000</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"number\">0x1d000</span> &lt;= uc &amp;&amp; uc &lt;= <span class=\"number\">0x1f77f</span>) &#123;</div><div class=\"line\">                    returnValue = <span class=\"literal\">YES</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (substring.length &gt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keyword\">unichar</span> ls = [substring characterAtIndex:<span class=\"number\">1</span>];</div><div class=\"line\">            <span class=\"keyword\">if</span> (ls == <span class=\"number\">0x20e3</span>) &#123;</div><div class=\"line\">                returnValue = <span class=\"literal\">YES</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"number\">0x2100</span> &lt;= hs &amp;&amp; hs &lt;= <span class=\"number\">0x27ff</span>) &#123;</div><div class=\"line\">                returnValue = <span class=\"literal\">YES</span>;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"number\">0x2B05</span> &lt;= hs &amp;&amp; hs &lt;= <span class=\"number\">0x2b07</span>) &#123;</div><div class=\"line\">                returnValue = <span class=\"literal\">YES</span>;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"number\">0x2934</span> &lt;= hs &amp;&amp; hs &lt;= <span class=\"number\">0x2935</span>) &#123;</div><div class=\"line\">                returnValue = <span class=\"literal\">YES</span>;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"number\">0x3297</span> &lt;= hs &amp;&amp; hs &lt;= <span class=\"number\">0x3299</span>) &#123;</div><div class=\"line\">                returnValue = <span class=\"literal\">YES</span>;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (hs == <span class=\"number\">0xa9</span> || hs == <span class=\"number\">0xae</span> || hs == <span class=\"number\">0x303d</span> || hs == <span class=\"number\">0x3030</span> || hs == <span class=\"number\">0x2b55</span> || hs == <span class=\"number\">0x2b1c</span> || hs == <span class=\"number\">0x2b1b</span> || hs == <span class=\"number\">0x2b50</span>) &#123;</div><div class=\"line\">                returnValue = <span class=\"literal\">YES</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> returnValue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这段代码并非本人原创，也是取自互联网，经测试好使，分享给大家。</p>\n<p>原博客地址: <a href=\"http://blog.csdn.net/liujinlongxa/article/details/44207003\" target=\"_blank\" rel=\"external\">iOS中Emoji表情的判断</a></p>\n","excerpt":"","more":"<p>##问题<br>服务器端不支持Emoji表情，因此客户端在上传用户输入时，不能包含Emoji表情。</p>\n<p>##解决方案<br>在客户端发送请求前，判断用户输入中是否含有表情，如果含有表情，则提示用户重新输入。这个过程关键是如何判断字符串中是否含有Emoji表情。要判断是否含有Emoji表情，<br>必须先了解什么是Emoji。</p>\n<blockquote>\n<p>Emoji 是一套起源于日本的12x12像素表情符号，由栗田穣崇(Shigetaka Kurit)创作，最早在日本网络及手机用户中流行，自苹果公司发布的iOS 5输入法中加入了emoji后，这种表情符号开始席卷全球，目前emoji已被大多数现代计算机系统所兼容的Unicode编码采纳，普遍应用于各种手机短信和社交网络中。</p>\n</blockquote>\n<p>以上是摘自百度百科里的一段话，Emoji表情最终会被编码成Unicode，因此，只要知道Emoji表情的Unicode编码的范围，就可以判断用户是否输入了Emoji表情。以下是具体代码，<br>我这里写成了NSString的一个分类</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSString</span> (<span class=\"title\">Emoji</span>)</span></div><div class=\"line\"></div><div class=\"line\">+ (<span class=\"built_in\">BOOL</span>)stringContainsEmoji:(<span class=\"built_in\">NSString</span> *)string</div><div class=\"line\">&#123;</div><div class=\"line\">    __block <span class=\"built_in\">BOOL</span> returnValue = <span class=\"literal\">NO</span>;</div><div class=\"line\"></div><div class=\"line\">    [string enumerateSubstringsInRange:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, [string length])</div><div class=\"line\">    options:<span class=\"built_in\">NSStringEnumerationByComposedCharacterSequences</span></div><div class=\"line\">    usingBlock:^(<span class=\"built_in\">NSString</span> *substring, <span class=\"built_in\">NSRange</span> substringRange, <span class=\"built_in\">NSRange</span> enclosingRange, <span class=\"built_in\">BOOL</span> *stop) &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">unichar</span> hs = [substring characterAtIndex:<span class=\"number\">0</span>];</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">0xd800</span> &lt;= hs &amp;&amp; hs &lt;= <span class=\"number\">0xdbff</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (substring.length &gt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">const</span> <span class=\"keyword\">unichar</span> ls = [substring characterAtIndex:<span class=\"number\">1</span>];</div><div class=\"line\">                <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> uc = ((hs - <span class=\"number\">0xd800</span>) * <span class=\"number\">0x400</span>) + (ls - <span class=\"number\">0xdc00</span>) + <span class=\"number\">0x10000</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"number\">0x1d000</span> &lt;= uc &amp;&amp; uc &lt;= <span class=\"number\">0x1f77f</span>) &#123;</div><div class=\"line\">                    returnValue = <span class=\"literal\">YES</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (substring.length &gt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keyword\">unichar</span> ls = [substring characterAtIndex:<span class=\"number\">1</span>];</div><div class=\"line\">            <span class=\"keyword\">if</span> (ls == <span class=\"number\">0x20e3</span>) &#123;</div><div class=\"line\">                returnValue = <span class=\"literal\">YES</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"number\">0x2100</span> &lt;= hs &amp;&amp; hs &lt;= <span class=\"number\">0x27ff</span>) &#123;</div><div class=\"line\">                returnValue = <span class=\"literal\">YES</span>;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"number\">0x2B05</span> &lt;= hs &amp;&amp; hs &lt;= <span class=\"number\">0x2b07</span>) &#123;</div><div class=\"line\">                returnValue = <span class=\"literal\">YES</span>;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"number\">0x2934</span> &lt;= hs &amp;&amp; hs &lt;= <span class=\"number\">0x2935</span>) &#123;</div><div class=\"line\">                returnValue = <span class=\"literal\">YES</span>;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"number\">0x3297</span> &lt;= hs &amp;&amp; hs &lt;= <span class=\"number\">0x3299</span>) &#123;</div><div class=\"line\">                returnValue = <span class=\"literal\">YES</span>;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (hs == <span class=\"number\">0xa9</span> || hs == <span class=\"number\">0xae</span> || hs == <span class=\"number\">0x303d</span> || hs == <span class=\"number\">0x3030</span> || hs == <span class=\"number\">0x2b55</span> || hs == <span class=\"number\">0x2b1c</span> || hs == <span class=\"number\">0x2b1b</span> || hs == <span class=\"number\">0x2b50</span>) &#123;</div><div class=\"line\">                returnValue = <span class=\"literal\">YES</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> returnValue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这段代码并非本人原创，也是取自互联网，经测试好使，分享给大家。</p>\n<p>原博客地址: <a href=\"http://blog.csdn.net/liujinlongxa/article/details/44207003\">iOS中Emoji表情的判断</a></p>\n"},{"layout":"post","title":"iOS中的多线程编程","_content":"\n##关于多线程编程\n\n###什么是多线程\n简单的来说，并发应用程序中一个单独的执行路径，就是一个线程。\n###相关术语\n* 进程：用于指代一个正在运行的可执行程序，它可以包含多个线程。\n* 任务：用于指代抽象的概念，表示需要执行工作。\n* 线程的同步：同步就是协同步调，按预定的先后次序进行运行。线程的同步即一个线程执行完指定操作后，另个一个线程再执行。\n* 线程的互斥：线程互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。\n###iOS中的多线程编程\n* pthread（POSIX threads）：一套C语言接口，定义了创建和管理线程的API，非常灵活，可以直接操作线程。\n* NSThread：一套OC接口，需要自己手动管理线程，比GCD和NSOperation更加轻量级。\n* GCD：是iOS4出的一套并发编程的接口，纯C语言接口。以队列为基础。\n* NSOperation：一套面向对象的OC API，不需要手动管理线程。能实现一些GCD实现不了的功能。\n\n##NSThread\n###基本操作\n####线程的创建\n* 类方法创建线程\n```objectivec\n[NSThread detachNewThreadSelector:@selector(threadFun:) toTarget:self withObject:@\"helloworld\"];\n```\n\n* 实例方法创建线程\n```objectivec\nNSThread * th = [[NSThread alloc] initWithTarget:self selector:@selector(threadFun:) object:@\"helloworld\"];\n    [th start];\n```\n\n* 继承NSThread，重写main方法(与NSOperation类似)\n```objectivec\n//MyThread.h\n@interface MyThread : NSThread\n@end\n\n//MyThread.m\n@implementation MyThread\n- (void)main {\n    NSLog(@\"this is MyThread\");\n}\n\n//main.m\n#import <Foundation/Foundation.h>\n#import \"MyThread.h\"\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        MyThread * th = [[MyThread alloc] init];\n        [th start];\n        [[NSRunLoop mainRunLoop] run];\n    }\n    return 0;\n}\n@end\n```\n\n* 其他：NSObject中的方法\n```objectivec\n - (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg;\n```\n\n####线程的基本管理\n* 获取主线程`+ (NSThread *)mainThread`\n* 获取当前线程`+ (NSThread *)currentThread;`\n* 阻塞当前线程`+ (void)sleepUntilDate:(NSDate *)date;`和`+ (void)sleepForTimeInterval:(NSTimeInterval)ti;`\n* 销毁消除当前线程（currentThread）`+ (void)exit;`\n* 取消线程`- (void)cancel;`：将线程的状体置为cancelled，并不会停止线程的执行\n* 线程键的通讯\n```objectivec\n- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;\n- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait;\n```\n\n###线程同步与互斥\n####锁\n* @synchronized（obj）对代码段进行加锁，同时只能一个线程访问该代码段\n```objectivec\n@synchronized(self) {\n    i++;\n    NSLog(@\"%ld\", i);\n}\n```\n\n* NSLock：与@synchronized类似\n```objectivec\nNSLock * lock = [[NSLock alloc] init];\nif ([lock tryLock]) {\n    [lock lock];\n    i++;\n    NSLog(@\"%ld\", i);\n    [lock unlock];\n}\n```\n\n* NSConditionLock条件锁：在所的基础上添加了条件，只有满足对应的条件，才能打开相应的锁\n```objectivec\n- (void)startTest {\n    _conLock = [[NSConditionLock alloc] init];\n    [NSThread detachNewThreadSelector:@selector(threadFun:) toTarget:self withObject:@\"top thread\"];\n    for (int i = 0; i < 200; i++) {\n        [NSThread detachNewThreadSelector:@selector(threadFun2:) toTarget:self withObject:@(i)];\n    }\n}\n\n- (void)threadFun:(id)obj {\n\n    [_conLock lock];\n    NSLog(@\"%@\", obj);\n    [NSThread sleepForTimeInterval:1.0f];\n    //加锁，条件为10\n    [_conLock unlockWithCondition:10];\n}\n\n- (void)threadFun2:(id)obj {\n    NSInteger value = [obj integerValue];\n\n    //只有到value等于10时，才能成功加锁，否则阻塞\n    [_conLock lockWhenCondition:value];\n    NSLog(@\"thread%@\", obj);\n    [NSThread sleepForTimeInterval:1.0f];\n    //解锁，并把条件设为value + 3,则下次上锁的条件为13，一次类推13,16,19...\n    [_conLock unlockWithCondition:value + 3];\n}\n```\n\n输出结果：\n\n![这里写图片描述](http://img.blog.csdn.net/20150410103408108)\n\n* NSRecursiveLock递归锁：同一个线程中，递归或多次调用加锁代码段，不会造成死锁\n```objectivec\nj = 0;\n[NSThread detachNewThreadSelector:@selector(threadFun:) toTarget:self withObject:@\"top thread1\"];\n[NSThread detachNewThreadSelector:@selector(threadFun:) toTarget:self withObject:@\"top thread2\"];\n\n- (void)threadFun:(id)obj {\n    [self testWith:obj];\n}\n\n- (void)testWith:(id)obj {\n    [_recLock lock];\n    NSLog(@\"test recursive,thread:%@, lock:%ld\", obj, j++);\n    [NSThread sleepForTimeInterval:1.0f];\n    if (j < 10) {\n        [self testWith:obj];\n    }\n    [_recLock unlock];\n}\n```\n\n输出结果：\n\n![这里写图片描述](http://img.blog.csdn.net/20150410104742410)\n\n* NSDistributedLock分布式锁：用于多个进程之间互斥访问资源，一般用于Mac开发\n\n####条件\n使用NSCondition，可以实现多线程的同步，解决类似生产者消费者问题。\n```objectivec\n#import \"testThread.h\"\n\n@implementation testThread\n{\n    NSInteger i;\n    NSCondition * _con;\n    NSMutableArray * _products;\n}\n\n- (void)startTest {\n    _con = [[NSCondition alloc] init];\n    _products = [[NSMutableArray alloc] init];\n    [NSThread detachNewThreadSelector:@selector(threadFun2:) toTarget:self withObject:@\"thread2\"];\n    [NSThread detachNewThreadSelector:@selector(threadFun2:) toTarget:self withObject:@\"thread3\"];\n    [NSThread detachNewThreadSelector:@selector(threadFun1:) toTarget:self withObject:@\"thread1\"];\n}\n\n- (void)threadFun1:(id)obj {\n    while (1) {\n        [NSThread sleepForTimeInterval:2.0f];\n        [_products addObject:@\"apple\"];//生产者创造一个产品\n        NSLog(@\"%@ add one product, product count:%ld\", obj, _products.count);\n        [_con signal];//通知消费者，消费产品\n//        [_con broadcast];\n    }\n}\n\n- (void)threadFun2:(id)obj {\n    while (1) {\n        [_con lock];\n        [_con wait];//等待生产者的通知\n        [_products removeObjectAtIndex:0];//消费者消费一个产品\n        NSLog(@\"%@ remove one product, proudct count:%ld\", obj, _products.count);\n        [_con unlock];\n    }\n}\n\n@end\n```\n\n##GCD\n###基本用法\n####队列\n* 串行队列：同时只能执行一个任务\n\t* 所有任务都在同一个线程中执行，FIFO\n\t* 多个串行队列之间是并行执行的，会占用多个线程\n\t* 创建串行队列：`dispatch_queue_t serialQueue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_SERIAL);`\n\t* `dispatch_get_main_queue();`获取主线程上的一个全局可用的串行队列\n* 并行队列：同时可以执行多个任务\n\t* 多个任务在不同的线程上执行，最大并发数（最多起的线程数）由操作系统根据当前的系统状态决定，不可手动设置（NSOperation可以）\n\t* 创建并行队列：`dispatch_queue_t concurrentQueue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_CONCURRENT);`\n\t* `dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);`获取一个全局可用的并行队列\n####任务\n* 同步任务：添加一个任务后，需要等待任务执行完后才能返回\n\t* 无论是串行队列还是并行队列，同步任务都是在主线程上执行的\n\t* 同步任务会阻塞当前线程\n\t* 向主队列中添加同步任务会造成**死锁**，见死锁①\n\t* 向串行队列中添加嵌套的同步任务会造成**死锁**，见死锁②\n```objectivec\n//同步任务\ndispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n            [NSThread sleepForTimeInterval:1.0f];\n            //先打印\n            NSLog(@\"thread:%@\", [NSThread currentThread]);\n        });\nNSLog(@\"haha\");//后打印\n\n//死锁①\ndispatch_sync(dispatch_get_main_queue(), ^{\n            [NSThread sleepForTimeInterval:1.0f];\n            NSLog(@\"thread:%@\", [NSThread currentThread]);\n        });        \nNSLog(@\"haha\");//造成死锁，haha永远不会打印\n\n//死锁②\ndispatch_queue_t serialQueue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_SERIAL);\ndispatch_sync(serialQueue, ^{\n            NSLog(@\"thread1:%@\", [NSThread currentThread]);\n            dispatch_sync(serialQueue, ^{\n                NSLog(@\"thread2:%@\", [NSThread currentThread]);//造成死锁，thread2永远不会打印\n            });\n        });\n```\n\n* 异步任务：添加一个任务后不需要等待任务执行完成\n```objectivec\n//异步任务\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n            [NSThread sleepForTimeInterval:1.0f];\n            //后打印\n            NSLog(@\"thread:%@\", [NSThread currentThread]);\n        });\nNSLog(@\"haha\");//先打印\n```\n\n###其他用法\n* dispatch_after：延迟指定的时间后，将任务添加到指定的队列中\n```objectivec\ndispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10.0f * NSEC_PER_SEC));\ndispatch_after(time, dispatch_get_main_queue(), ^{\n    NSLog(@\"haha\");\n});\n```\n\n* dispatch_group：将多个任务或队列归为一组，在这组的所有任务都执行完之后再执行后面的操作\n\t* dispatch_group_async函数：创建一个指定队列中的异步任务，并将其添加到指定组中\n\t* dispatch_group_notify函数：指定组中所有任务都执行完后，会执行该函数所指定的的任务\n\t* dispatch_group_wait函数：阻塞当前线程，等待group中所有任务执行完毕\n```objectivec\n//使用dispatch_group_notify\ndispatch_group_t group = dispatch_group_create();\ndispatch_queue_t concurrentQueue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_CONCURRENT);\ndispatch_group_async(group, concurrentQueue, ^{\n    NSLog(@\"1\");\n    [NSThread sleepForTimeInterval:1.0f];\n});\ndispatch_group_async(group, concurrentQueue, ^{\n    NSLog(@\"2\");\n    [NSThread sleepForTimeInterval:1.0f];\n});\ndispatch_group_async(group, concurrentQueue, ^{\n    NSLog(@\"3\");\n    [NSThread sleepForTimeInterval:1.0f];\n});\ndispatch_group_async(group, concurrentQueue, ^{\n    NSLog(@\"4\");\n    [NSThread sleepForTimeInterval:1.0f];\n});\n\ndispatch_group_notify(group, concurrentQueue, ^{\n    NSLog(@\"5\");//\"1234\"全部打印后，才会打印5\n});\n\n//使用dispatch_group_wait\ndispatch_group_t group = dispatch_group_create();\ndispatch_queue_t concurrentQueue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_CONCURRENT);\ndispatch_group_async(group, concurrentQueue, ^{\n    NSLog(@\"1\");\n    [NSThread sleepForTimeInterval:1.0f];\n});\ndispatch_group_async(group, concurrentQueue, ^{\n    NSLog(@\"2\");\n    [NSThread sleepForTimeInterval:1.0f];\n});\ndispatch_group_async(group, concurrentQueue, ^{\n    NSLog(@\"3\");\n    [NSThread sleepForTimeInterval:1.0f];\n});\ndispatch_group_async(group, concurrentQueue, ^{\n    NSLog(@\"4\");\n    [NSThread sleepForTimeInterval:1.0f];\n});\n\ndispatch_group_wait(group, DISPATCH_TIME_FOREVER);\n\nNSLog(@\"haha\");//\"dispatch_group_wait\"会阻塞线程，所有haha会在\"1234\"之后打印\n```\n\n* diapatch_once：执行一次\n* dispatch_apply：按照指定的次数将指定的Block追加到指定的DispatchQueue中，并等待全部处理执行结束\n```objectivec\ndispatch_apply(10, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t t) {\n    NSLog(@\"%zu\", t);\n    [NSThread sleepForTimeInterval:1.0f];\n});\nNSLog(@\"haha\");//等待dispatch_apply中的所有任务都执行完之后才会带引\"haha\"\n```\n\n* dispatch_suspend / dispatch_resume\n\t* dispatch_suspend：挂起指定的队列\n\t* dispatch_resume：恢复指定的队列\n* Dispatch Semaphore：信号量，用于排他控制\n```objectivec\ndispatch_semaphore_t semaphore = dispatch_semaphore_create(1);\n\nfor (int i = 0; i < 10; i++) {\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n\n        long result = dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n        //排他，同时只能有一个线程进入这个代码块，相当于锁\n        NSLog(@\"end wait, result:%ld\", result);\n        [NSThread sleepForTimeInterval:1.0f];\n\n        dispatch_semaphore_signal(semaphore);\n    });\n}\n```\n\n##NSOperation\n###基本用法\n* NSBlockOperation：以Block的形式定义任务\n```objectivec\n@interface testOperation ()\n@property (nonatomic, strong) NSOperationQueue * queue;\n@end\n\n@implementation testOperation\n\n- (void)startTest {\n\n    //创建操作\n    NSOperation * oper1 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"test block operation1, current thread:%@\", [NSThread currentThread]);\n        [NSThread sleepForTimeInterval:1.0f];\n    }];\n\n    NSOperation * oper2 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"test block operation2, current thread:%@\", [NSThread currentThread]);\n        [NSThread sleepForTimeInterval:1.0f];\n    }];\n\n    NSOperation * oper3 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"test block operation3, current thread:%@\", [NSThread currentThread]);\n        [NSThread sleepForTimeInterval:1.0f];\n    }];\n\n    NSOperation * oper4 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"test block operation4, current thread:%@\", [NSThread currentThread]);\n        [NSThread sleepForTimeInterval:1.0f];\n    }];\n\n    self.queue = [[NSOperationQueue alloc] init];\n    //将操作加入队列中，操作就会在队列中并发执行，NSOperationQueue默认是并发队列\n    [self.queue addOperation:oper1];\n    [self.queue addOperation:oper2];\n    [self.queue addOperation:oper3];\n    [self.queue addOperation:oper4];\n}\n@end\n```\n\n* NSInvocationOperation\n```objectivec\n@interface testOperation ()\n@property (nonatomic, strong) NSOperationQueue * queue;\n@end\n\n@implementation testOperation\n\n- (void)startTest {\n\n    NSMethodSignature * sig = [[self class] instanceMethodSignatureForSelector:@selector(oper1Fun:andObj2:)];\n    NSInvocation * invo = [NSInvocation invocationWithMethodSignature:sig];\n    [invo setTarget:self];\n    [invo setSelector:@selector(oper1Fun:andObj2:)];\n    NSString * arg1 = @\"haha\";\n    NSString * arg2 = @\"oooo\";\n    [invo setArgument:&arg1 atIndex:2];\n    [invo setArgument:&arg2 atIndex:3];\n    NSOperation * oper1 = [[NSInvocationOperation alloc] initWithInvocation:invo];\n\n    NSOperation * oper2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(oper2Fun) object:nil];\n\n    self.queue = [[NSOperationQueue alloc] init];\n    [self.queue addOperation:oper1];\n    [self.queue addOperation:oper2];\n}\n\n- (void)oper1Fun:(id)obj1 andObj2:(id)obj2 {\n    NSLog(@\"test invocation operation1, current thread:%@, obj1:%@, obj2:%@\", [NSThread currentThread], obj1, obj2);\n    [NSThread sleepForTimeInterval:1.0f];\n}\n\n- (void)oper2Fun {\n    NSLog(@\"test invocation operation2, current thread:%@\", [NSThread currentThread]);\n}\n@end\n```\n\n* 继承NSOperation，重写main方法\n```objectivec\n@interface MyOperation : NSOperation\n@end\n\n@implementation MyOperation\n- (void)main {\n    NSLog(@\"MyOperation, current thread:%@\", [NSThread currentThread]);\n    [NSThread sleepForTimeInterval:1.0f];\n}\n@end\n\n//main.m\nNSOperationQueue * queue = [[NSOperationQueue alloc] init];\n\nMyOperation * op1 = [[MyOperation alloc] init];\nMyOperation * op2 = [[MyOperation alloc] init];\nMyOperation * op3 = [[MyOperation alloc] init];\nMyOperation * op4 = [[MyOperation alloc] init];\nMyOperation * op5 = [[MyOperation alloc] init];\nMyOperation * op6 = [[MyOperation alloc] init];\n\n[queue addOperation:op1];\n[queue addOperation:op2];\n[queue addOperation:op3];\n[queue addOperation:op4];\n[queue addOperation:op5];\n[queue addOperation:op6];\n```\n\n###其他用法\n* 设置最大并发数\n`self.queue.maxConcurrentOperationCount = 3;`\n* 设置操作之间的依赖关系\n`[oper2 addDependency:oper1];//oper2依赖于oper1，即必须oper1执行完之后才能执行oper2`\n* 手动管理NSOperation\n\t* 运行一个Operation：`- (void)start;`默认的start方法会直接进行一些异常判断，然后直接调用`- (void)main;`\n\t* 取消一个Operation：`- (void)cancel;`调用cancel方法并不会停止操作的执行，这取决于main方法中对cancel的处理。如果在main方法中没有对cancel进行处理，发送cancel消息是没有任何效果的\n```objectivec\n//MyOperation.m\n@implementation MyOperation\n\n- (void)start {\n    [NSThread detachNewThreadSelector:@selector(main) toTarget:self withObject:nil];\n}\n\n- (void)main {\n    NSInteger index = 0;\n    while (1) {\n        NSLog(@\"current thread:%@, index:%ld\", [NSThread currentThread], index++);\n        if (self.isCancelled) {\n            NSLog(@\"cancel\");\n            return;\n        }\n        [NSThread sleepForTimeInterval:1.0f];\n    }\n}\n@end\n\n//main.m\nMyOperation * op1 = [[MyOperation alloc] init];\n[op1 start];\n[NSThread sleepForTimeInterval:3.0f];\n[op1 cancel];\n```\n","source":"_posts/2015-10-04-iOS中的多线程编程.md","raw":"---\nlayout: post\ntitle: \"iOS中的多线程编程\"\ncategories: \"iOS开发\"\n---\n\n##关于多线程编程\n\n###什么是多线程\n简单的来说，并发应用程序中一个单独的执行路径，就是一个线程。\n###相关术语\n* 进程：用于指代一个正在运行的可执行程序，它可以包含多个线程。\n* 任务：用于指代抽象的概念，表示需要执行工作。\n* 线程的同步：同步就是协同步调，按预定的先后次序进行运行。线程的同步即一个线程执行完指定操作后，另个一个线程再执行。\n* 线程的互斥：线程互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。\n###iOS中的多线程编程\n* pthread（POSIX threads）：一套C语言接口，定义了创建和管理线程的API，非常灵活，可以直接操作线程。\n* NSThread：一套OC接口，需要自己手动管理线程，比GCD和NSOperation更加轻量级。\n* GCD：是iOS4出的一套并发编程的接口，纯C语言接口。以队列为基础。\n* NSOperation：一套面向对象的OC API，不需要手动管理线程。能实现一些GCD实现不了的功能。\n\n##NSThread\n###基本操作\n####线程的创建\n* 类方法创建线程\n```objectivec\n[NSThread detachNewThreadSelector:@selector(threadFun:) toTarget:self withObject:@\"helloworld\"];\n```\n\n* 实例方法创建线程\n```objectivec\nNSThread * th = [[NSThread alloc] initWithTarget:self selector:@selector(threadFun:) object:@\"helloworld\"];\n    [th start];\n```\n\n* 继承NSThread，重写main方法(与NSOperation类似)\n```objectivec\n//MyThread.h\n@interface MyThread : NSThread\n@end\n\n//MyThread.m\n@implementation MyThread\n- (void)main {\n    NSLog(@\"this is MyThread\");\n}\n\n//main.m\n#import <Foundation/Foundation.h>\n#import \"MyThread.h\"\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        MyThread * th = [[MyThread alloc] init];\n        [th start];\n        [[NSRunLoop mainRunLoop] run];\n    }\n    return 0;\n}\n@end\n```\n\n* 其他：NSObject中的方法\n```objectivec\n - (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg;\n```\n\n####线程的基本管理\n* 获取主线程`+ (NSThread *)mainThread`\n* 获取当前线程`+ (NSThread *)currentThread;`\n* 阻塞当前线程`+ (void)sleepUntilDate:(NSDate *)date;`和`+ (void)sleepForTimeInterval:(NSTimeInterval)ti;`\n* 销毁消除当前线程（currentThread）`+ (void)exit;`\n* 取消线程`- (void)cancel;`：将线程的状体置为cancelled，并不会停止线程的执行\n* 线程键的通讯\n```objectivec\n- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;\n- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait;\n```\n\n###线程同步与互斥\n####锁\n* @synchronized（obj）对代码段进行加锁，同时只能一个线程访问该代码段\n```objectivec\n@synchronized(self) {\n    i++;\n    NSLog(@\"%ld\", i);\n}\n```\n\n* NSLock：与@synchronized类似\n```objectivec\nNSLock * lock = [[NSLock alloc] init];\nif ([lock tryLock]) {\n    [lock lock];\n    i++;\n    NSLog(@\"%ld\", i);\n    [lock unlock];\n}\n```\n\n* NSConditionLock条件锁：在所的基础上添加了条件，只有满足对应的条件，才能打开相应的锁\n```objectivec\n- (void)startTest {\n    _conLock = [[NSConditionLock alloc] init];\n    [NSThread detachNewThreadSelector:@selector(threadFun:) toTarget:self withObject:@\"top thread\"];\n    for (int i = 0; i < 200; i++) {\n        [NSThread detachNewThreadSelector:@selector(threadFun2:) toTarget:self withObject:@(i)];\n    }\n}\n\n- (void)threadFun:(id)obj {\n\n    [_conLock lock];\n    NSLog(@\"%@\", obj);\n    [NSThread sleepForTimeInterval:1.0f];\n    //加锁，条件为10\n    [_conLock unlockWithCondition:10];\n}\n\n- (void)threadFun2:(id)obj {\n    NSInteger value = [obj integerValue];\n\n    //只有到value等于10时，才能成功加锁，否则阻塞\n    [_conLock lockWhenCondition:value];\n    NSLog(@\"thread%@\", obj);\n    [NSThread sleepForTimeInterval:1.0f];\n    //解锁，并把条件设为value + 3,则下次上锁的条件为13，一次类推13,16,19...\n    [_conLock unlockWithCondition:value + 3];\n}\n```\n\n输出结果：\n\n![这里写图片描述](http://img.blog.csdn.net/20150410103408108)\n\n* NSRecursiveLock递归锁：同一个线程中，递归或多次调用加锁代码段，不会造成死锁\n```objectivec\nj = 0;\n[NSThread detachNewThreadSelector:@selector(threadFun:) toTarget:self withObject:@\"top thread1\"];\n[NSThread detachNewThreadSelector:@selector(threadFun:) toTarget:self withObject:@\"top thread2\"];\n\n- (void)threadFun:(id)obj {\n    [self testWith:obj];\n}\n\n- (void)testWith:(id)obj {\n    [_recLock lock];\n    NSLog(@\"test recursive,thread:%@, lock:%ld\", obj, j++);\n    [NSThread sleepForTimeInterval:1.0f];\n    if (j < 10) {\n        [self testWith:obj];\n    }\n    [_recLock unlock];\n}\n```\n\n输出结果：\n\n![这里写图片描述](http://img.blog.csdn.net/20150410104742410)\n\n* NSDistributedLock分布式锁：用于多个进程之间互斥访问资源，一般用于Mac开发\n\n####条件\n使用NSCondition，可以实现多线程的同步，解决类似生产者消费者问题。\n```objectivec\n#import \"testThread.h\"\n\n@implementation testThread\n{\n    NSInteger i;\n    NSCondition * _con;\n    NSMutableArray * _products;\n}\n\n- (void)startTest {\n    _con = [[NSCondition alloc] init];\n    _products = [[NSMutableArray alloc] init];\n    [NSThread detachNewThreadSelector:@selector(threadFun2:) toTarget:self withObject:@\"thread2\"];\n    [NSThread detachNewThreadSelector:@selector(threadFun2:) toTarget:self withObject:@\"thread3\"];\n    [NSThread detachNewThreadSelector:@selector(threadFun1:) toTarget:self withObject:@\"thread1\"];\n}\n\n- (void)threadFun1:(id)obj {\n    while (1) {\n        [NSThread sleepForTimeInterval:2.0f];\n        [_products addObject:@\"apple\"];//生产者创造一个产品\n        NSLog(@\"%@ add one product, product count:%ld\", obj, _products.count);\n        [_con signal];//通知消费者，消费产品\n//        [_con broadcast];\n    }\n}\n\n- (void)threadFun2:(id)obj {\n    while (1) {\n        [_con lock];\n        [_con wait];//等待生产者的通知\n        [_products removeObjectAtIndex:0];//消费者消费一个产品\n        NSLog(@\"%@ remove one product, proudct count:%ld\", obj, _products.count);\n        [_con unlock];\n    }\n}\n\n@end\n```\n\n##GCD\n###基本用法\n####队列\n* 串行队列：同时只能执行一个任务\n\t* 所有任务都在同一个线程中执行，FIFO\n\t* 多个串行队列之间是并行执行的，会占用多个线程\n\t* 创建串行队列：`dispatch_queue_t serialQueue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_SERIAL);`\n\t* `dispatch_get_main_queue();`获取主线程上的一个全局可用的串行队列\n* 并行队列：同时可以执行多个任务\n\t* 多个任务在不同的线程上执行，最大并发数（最多起的线程数）由操作系统根据当前的系统状态决定，不可手动设置（NSOperation可以）\n\t* 创建并行队列：`dispatch_queue_t concurrentQueue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_CONCURRENT);`\n\t* `dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);`获取一个全局可用的并行队列\n####任务\n* 同步任务：添加一个任务后，需要等待任务执行完后才能返回\n\t* 无论是串行队列还是并行队列，同步任务都是在主线程上执行的\n\t* 同步任务会阻塞当前线程\n\t* 向主队列中添加同步任务会造成**死锁**，见死锁①\n\t* 向串行队列中添加嵌套的同步任务会造成**死锁**，见死锁②\n```objectivec\n//同步任务\ndispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n            [NSThread sleepForTimeInterval:1.0f];\n            //先打印\n            NSLog(@\"thread:%@\", [NSThread currentThread]);\n        });\nNSLog(@\"haha\");//后打印\n\n//死锁①\ndispatch_sync(dispatch_get_main_queue(), ^{\n            [NSThread sleepForTimeInterval:1.0f];\n            NSLog(@\"thread:%@\", [NSThread currentThread]);\n        });        \nNSLog(@\"haha\");//造成死锁，haha永远不会打印\n\n//死锁②\ndispatch_queue_t serialQueue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_SERIAL);\ndispatch_sync(serialQueue, ^{\n            NSLog(@\"thread1:%@\", [NSThread currentThread]);\n            dispatch_sync(serialQueue, ^{\n                NSLog(@\"thread2:%@\", [NSThread currentThread]);//造成死锁，thread2永远不会打印\n            });\n        });\n```\n\n* 异步任务：添加一个任务后不需要等待任务执行完成\n```objectivec\n//异步任务\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n            [NSThread sleepForTimeInterval:1.0f];\n            //后打印\n            NSLog(@\"thread:%@\", [NSThread currentThread]);\n        });\nNSLog(@\"haha\");//先打印\n```\n\n###其他用法\n* dispatch_after：延迟指定的时间后，将任务添加到指定的队列中\n```objectivec\ndispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10.0f * NSEC_PER_SEC));\ndispatch_after(time, dispatch_get_main_queue(), ^{\n    NSLog(@\"haha\");\n});\n```\n\n* dispatch_group：将多个任务或队列归为一组，在这组的所有任务都执行完之后再执行后面的操作\n\t* dispatch_group_async函数：创建一个指定队列中的异步任务，并将其添加到指定组中\n\t* dispatch_group_notify函数：指定组中所有任务都执行完后，会执行该函数所指定的的任务\n\t* dispatch_group_wait函数：阻塞当前线程，等待group中所有任务执行完毕\n```objectivec\n//使用dispatch_group_notify\ndispatch_group_t group = dispatch_group_create();\ndispatch_queue_t concurrentQueue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_CONCURRENT);\ndispatch_group_async(group, concurrentQueue, ^{\n    NSLog(@\"1\");\n    [NSThread sleepForTimeInterval:1.0f];\n});\ndispatch_group_async(group, concurrentQueue, ^{\n    NSLog(@\"2\");\n    [NSThread sleepForTimeInterval:1.0f];\n});\ndispatch_group_async(group, concurrentQueue, ^{\n    NSLog(@\"3\");\n    [NSThread sleepForTimeInterval:1.0f];\n});\ndispatch_group_async(group, concurrentQueue, ^{\n    NSLog(@\"4\");\n    [NSThread sleepForTimeInterval:1.0f];\n});\n\ndispatch_group_notify(group, concurrentQueue, ^{\n    NSLog(@\"5\");//\"1234\"全部打印后，才会打印5\n});\n\n//使用dispatch_group_wait\ndispatch_group_t group = dispatch_group_create();\ndispatch_queue_t concurrentQueue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_CONCURRENT);\ndispatch_group_async(group, concurrentQueue, ^{\n    NSLog(@\"1\");\n    [NSThread sleepForTimeInterval:1.0f];\n});\ndispatch_group_async(group, concurrentQueue, ^{\n    NSLog(@\"2\");\n    [NSThread sleepForTimeInterval:1.0f];\n});\ndispatch_group_async(group, concurrentQueue, ^{\n    NSLog(@\"3\");\n    [NSThread sleepForTimeInterval:1.0f];\n});\ndispatch_group_async(group, concurrentQueue, ^{\n    NSLog(@\"4\");\n    [NSThread sleepForTimeInterval:1.0f];\n});\n\ndispatch_group_wait(group, DISPATCH_TIME_FOREVER);\n\nNSLog(@\"haha\");//\"dispatch_group_wait\"会阻塞线程，所有haha会在\"1234\"之后打印\n```\n\n* diapatch_once：执行一次\n* dispatch_apply：按照指定的次数将指定的Block追加到指定的DispatchQueue中，并等待全部处理执行结束\n```objectivec\ndispatch_apply(10, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t t) {\n    NSLog(@\"%zu\", t);\n    [NSThread sleepForTimeInterval:1.0f];\n});\nNSLog(@\"haha\");//等待dispatch_apply中的所有任务都执行完之后才会带引\"haha\"\n```\n\n* dispatch_suspend / dispatch_resume\n\t* dispatch_suspend：挂起指定的队列\n\t* dispatch_resume：恢复指定的队列\n* Dispatch Semaphore：信号量，用于排他控制\n```objectivec\ndispatch_semaphore_t semaphore = dispatch_semaphore_create(1);\n\nfor (int i = 0; i < 10; i++) {\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n\n        long result = dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n        //排他，同时只能有一个线程进入这个代码块，相当于锁\n        NSLog(@\"end wait, result:%ld\", result);\n        [NSThread sleepForTimeInterval:1.0f];\n\n        dispatch_semaphore_signal(semaphore);\n    });\n}\n```\n\n##NSOperation\n###基本用法\n* NSBlockOperation：以Block的形式定义任务\n```objectivec\n@interface testOperation ()\n@property (nonatomic, strong) NSOperationQueue * queue;\n@end\n\n@implementation testOperation\n\n- (void)startTest {\n\n    //创建操作\n    NSOperation * oper1 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"test block operation1, current thread:%@\", [NSThread currentThread]);\n        [NSThread sleepForTimeInterval:1.0f];\n    }];\n\n    NSOperation * oper2 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"test block operation2, current thread:%@\", [NSThread currentThread]);\n        [NSThread sleepForTimeInterval:1.0f];\n    }];\n\n    NSOperation * oper3 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"test block operation3, current thread:%@\", [NSThread currentThread]);\n        [NSThread sleepForTimeInterval:1.0f];\n    }];\n\n    NSOperation * oper4 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"test block operation4, current thread:%@\", [NSThread currentThread]);\n        [NSThread sleepForTimeInterval:1.0f];\n    }];\n\n    self.queue = [[NSOperationQueue alloc] init];\n    //将操作加入队列中，操作就会在队列中并发执行，NSOperationQueue默认是并发队列\n    [self.queue addOperation:oper1];\n    [self.queue addOperation:oper2];\n    [self.queue addOperation:oper3];\n    [self.queue addOperation:oper4];\n}\n@end\n```\n\n* NSInvocationOperation\n```objectivec\n@interface testOperation ()\n@property (nonatomic, strong) NSOperationQueue * queue;\n@end\n\n@implementation testOperation\n\n- (void)startTest {\n\n    NSMethodSignature * sig = [[self class] instanceMethodSignatureForSelector:@selector(oper1Fun:andObj2:)];\n    NSInvocation * invo = [NSInvocation invocationWithMethodSignature:sig];\n    [invo setTarget:self];\n    [invo setSelector:@selector(oper1Fun:andObj2:)];\n    NSString * arg1 = @\"haha\";\n    NSString * arg2 = @\"oooo\";\n    [invo setArgument:&arg1 atIndex:2];\n    [invo setArgument:&arg2 atIndex:3];\n    NSOperation * oper1 = [[NSInvocationOperation alloc] initWithInvocation:invo];\n\n    NSOperation * oper2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(oper2Fun) object:nil];\n\n    self.queue = [[NSOperationQueue alloc] init];\n    [self.queue addOperation:oper1];\n    [self.queue addOperation:oper2];\n}\n\n- (void)oper1Fun:(id)obj1 andObj2:(id)obj2 {\n    NSLog(@\"test invocation operation1, current thread:%@, obj1:%@, obj2:%@\", [NSThread currentThread], obj1, obj2);\n    [NSThread sleepForTimeInterval:1.0f];\n}\n\n- (void)oper2Fun {\n    NSLog(@\"test invocation operation2, current thread:%@\", [NSThread currentThread]);\n}\n@end\n```\n\n* 继承NSOperation，重写main方法\n```objectivec\n@interface MyOperation : NSOperation\n@end\n\n@implementation MyOperation\n- (void)main {\n    NSLog(@\"MyOperation, current thread:%@\", [NSThread currentThread]);\n    [NSThread sleepForTimeInterval:1.0f];\n}\n@end\n\n//main.m\nNSOperationQueue * queue = [[NSOperationQueue alloc] init];\n\nMyOperation * op1 = [[MyOperation alloc] init];\nMyOperation * op2 = [[MyOperation alloc] init];\nMyOperation * op3 = [[MyOperation alloc] init];\nMyOperation * op4 = [[MyOperation alloc] init];\nMyOperation * op5 = [[MyOperation alloc] init];\nMyOperation * op6 = [[MyOperation alloc] init];\n\n[queue addOperation:op1];\n[queue addOperation:op2];\n[queue addOperation:op3];\n[queue addOperation:op4];\n[queue addOperation:op5];\n[queue addOperation:op6];\n```\n\n###其他用法\n* 设置最大并发数\n`self.queue.maxConcurrentOperationCount = 3;`\n* 设置操作之间的依赖关系\n`[oper2 addDependency:oper1];//oper2依赖于oper1，即必须oper1执行完之后才能执行oper2`\n* 手动管理NSOperation\n\t* 运行一个Operation：`- (void)start;`默认的start方法会直接进行一些异常判断，然后直接调用`- (void)main;`\n\t* 取消一个Operation：`- (void)cancel;`调用cancel方法并不会停止操作的执行，这取决于main方法中对cancel的处理。如果在main方法中没有对cancel进行处理，发送cancel消息是没有任何效果的\n```objectivec\n//MyOperation.m\n@implementation MyOperation\n\n- (void)start {\n    [NSThread detachNewThreadSelector:@selector(main) toTarget:self withObject:nil];\n}\n\n- (void)main {\n    NSInteger index = 0;\n    while (1) {\n        NSLog(@\"current thread:%@, index:%ld\", [NSThread currentThread], index++);\n        if (self.isCancelled) {\n            NSLog(@\"cancel\");\n            return;\n        }\n        [NSThread sleepForTimeInterval:1.0f];\n    }\n}\n@end\n\n//main.m\nMyOperation * op1 = [[MyOperation alloc] init];\n[op1 start];\n[NSThread sleepForTimeInterval:3.0f];\n[op1 cancel];\n```\n","slug":"iOS中的多线程编程","published":1,"date":"2015-10-03T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oa9y0006zrm0g4hwyup3","content":"<p>##关于多线程编程</p>\n<p>###什么是多线程<br>简单的来说，并发应用程序中一个单独的执行路径，就是一个线程。</p>\n<p>###相关术语</p>\n<ul>\n<li>进程：用于指代一个正在运行的可执行程序，它可以包含多个线程。</li>\n<li>任务：用于指代抽象的概念，表示需要执行工作。</li>\n<li>线程的同步：同步就是协同步调，按预定的先后次序进行运行。线程的同步即一个线程执行完指定操作后，另个一个线程再执行。</li>\n<li>线程的互斥：线程互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。<br>###iOS中的多线程编程</li>\n<li>pthread（POSIX threads）：一套C语言接口，定义了创建和管理线程的API，非常灵活，可以直接操作线程。</li>\n<li>NSThread：一套OC接口，需要自己手动管理线程，比GCD和NSOperation更加轻量级。</li>\n<li>GCD：是iOS4出的一套并发编程的接口，纯C语言接口。以队列为基础。</li>\n<li>NSOperation：一套面向对象的OC API，不需要手动管理线程。能实现一些GCD实现不了的功能。</li>\n</ul>\n<p>##NSThread</p>\n<p>###基本操作</p>\n<p>####线程的创建</p>\n<ul>\n<li><p>类方法创建线程</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(threadFun:) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"string\">@\"helloworld\"</span>];</div></pre></td></tr></table></figure>\n</li>\n<li><p>实例方法创建线程</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSThread</span> * th = [[<span class=\"built_in\">NSThread</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(threadFun:) object:<span class=\"string\">@\"helloworld\"</span>];</div><div class=\"line\">    [th start];</div></pre></td></tr></table></figure>\n</li>\n<li><p>继承NSThread，重写main方法(与NSOperation类似)</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//MyThread.h</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyThread</span> : <span class=\"title\">NSThread</span></span></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//MyThread.m</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyThread</span></span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)main &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"this is MyThread\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//main.m</span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyThread.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[]) &#123;</div><div class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</div><div class=\"line\">        MyThread * th = [[MyThread alloc] init];</div><div class=\"line\">        [th start];</div><div class=\"line\">        [[<span class=\"built_in\">NSRunLoop</span> mainRunLoop] run];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>其他：NSObject中的方法</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)performSelectorInBackground:(SEL)aSelector withObject:(<span class=\"keyword\">id</span>)arg;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>####线程的基本管理</p>\n<ul>\n<li>获取主线程<code>+ (NSThread *)mainThread</code></li>\n<li>获取当前线程<code>+ (NSThread *)currentThread;</code></li>\n<li>阻塞当前线程<code>+ (void)sleepUntilDate:(NSDate *)date;</code>和<code>+ (void)sleepForTimeInterval:(NSTimeInterval)ti;</code></li>\n<li>销毁消除当前线程（currentThread）<code>+ (void)exit;</code></li>\n<li>取消线程<code>- (void)cancel;</code>：将线程的状体置为cancelled，并不会停止线程的执行</li>\n<li>线程键的通讯<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class=\"keyword\">id</span>)arg waitUntilDone:(<span class=\"built_in\">BOOL</span>)wait;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)performSelector:(SEL)aSelector onThread:(<span class=\"built_in\">NSThread</span> *)thr withObject:(<span class=\"keyword\">id</span>)arg waitUntilDone:(<span class=\"built_in\">BOOL</span>)wait;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>###线程同步与互斥</p>\n<p>####锁</p>\n<ul>\n<li><p>@synchronized（obj）对代码段进行加锁，同时只能一个线程访问该代码段</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@synchronized</span>(<span class=\"keyword\">self</span>) &#123;</div><div class=\"line\">    i++;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%ld\"</span>, i);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>NSLock：与@synchronized类似</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSLock</span> * lock = [[<span class=\"built_in\">NSLock</span> alloc] init];</div><div class=\"line\"><span class=\"keyword\">if</span> ([lock tryLock]) &#123;</div><div class=\"line\">    [lock lock];</div><div class=\"line\">    i++;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%ld\"</span>, i);</div><div class=\"line\">    [lock unlock];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>NSConditionLock条件锁：在所的基础上添加了条件，只有满足对应的条件，才能打开相应的锁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)startTest &#123;</div><div class=\"line\">    _conLock = [[<span class=\"built_in\">NSConditionLock</span> alloc] init];</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(threadFun:) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"string\">@\"top thread\"</span>];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">200</span>; i++) &#123;</div><div class=\"line\">        [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(threadFun2:) toTarget:<span class=\"keyword\">self</span> withObject:@(i)];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)threadFun:(<span class=\"keyword\">id</span>)obj &#123;</div><div class=\"line\"></div><div class=\"line\">    [_conLock lock];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, obj);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">    <span class=\"comment\">//加锁，条件为10</span></div><div class=\"line\">    [_conLock unlockWithCondition:<span class=\"number\">10</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)threadFun2:(<span class=\"keyword\">id</span>)obj &#123;</div><div class=\"line\">    <span class=\"built_in\">NSInteger</span> value = [obj integerValue];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//只有到value等于10时，才能成功加锁，否则阻塞</span></div><div class=\"line\">    [_conLock lockWhenCondition:value];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"thread%@\"</span>, obj);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">    <span class=\"comment\">//解锁，并把条件设为value + 3,则下次上锁的条件为13，一次类推13,16,19...</span></div><div class=\"line\">    [_conLock unlockWithCondition:value + <span class=\"number\">3</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>输出结果：</p>\n<p><img src=\"http://img.blog.csdn.net/20150410103408108\" alt=\"这里写图片描述\"></p>\n<ul>\n<li>NSRecursiveLock递归锁：同一个线程中，递归或多次调用加锁代码段，不会造成死锁<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">j = <span class=\"number\">0</span>;</div><div class=\"line\">[<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(threadFun:) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"string\">@\"top thread1\"</span>];</div><div class=\"line\">[<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(threadFun:) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"string\">@\"top thread2\"</span>];</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)threadFun:(<span class=\"keyword\">id</span>)obj &#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span> testWith:obj];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)testWith:(<span class=\"keyword\">id</span>)obj &#123;</div><div class=\"line\">    [_recLock lock];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"test recursive,thread:%@, lock:%ld\"</span>, obj, j++);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">    <span class=\"keyword\">if</span> (j &lt; <span class=\"number\">10</span>) &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> testWith:obj];</div><div class=\"line\">    &#125;</div><div class=\"line\">    [_recLock unlock];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>输出结果：</p>\n<p><img src=\"http://img.blog.csdn.net/20150410104742410\" alt=\"这里写图片描述\"></p>\n<ul>\n<li>NSDistributedLock分布式锁：用于多个进程之间互斥访问资源，一般用于Mac开发</li>\n</ul>\n<p>####条件<br>使用NSCondition，可以实现多线程的同步，解决类似生产者消费者问题。<br><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"testThread.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">testThread</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSInteger</span> i;</div><div class=\"line\">    <span class=\"built_in\">NSCondition</span> * _con;</div><div class=\"line\">    <span class=\"built_in\">NSMutableArray</span> * _products;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)startTest &#123;</div><div class=\"line\">    _con = [[<span class=\"built_in\">NSCondition</span> alloc] init];</div><div class=\"line\">    _products = [[<span class=\"built_in\">NSMutableArray</span> alloc] init];</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(threadFun2:) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"string\">@\"thread2\"</span>];</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(threadFun2:) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"string\">@\"thread3\"</span>];</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(threadFun1:) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"string\">@\"thread1\"</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)threadFun1:(<span class=\"keyword\">id</span>)obj &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</div><div class=\"line\">        [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">2.0</span>f];</div><div class=\"line\">        [_products addObject:<span class=\"string\">@\"apple\"</span>];<span class=\"comment\">//生产者创造一个产品</span></div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ add one product, product count:%ld\"</span>, obj, _products.count);</div><div class=\"line\">        [_con signal];<span class=\"comment\">//通知消费者，消费产品</span></div><div class=\"line\"><span class=\"comment\">//        [_con broadcast];</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)threadFun2:(<span class=\"keyword\">id</span>)obj &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</div><div class=\"line\">        [_con lock];</div><div class=\"line\">        [_con wait];<span class=\"comment\">//等待生产者的通知</span></div><div class=\"line\">        [_products removeObjectAtIndex:<span class=\"number\">0</span>];<span class=\"comment\">//消费者消费一个产品</span></div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ remove one product, proudct count:%ld\"</span>, obj, _products.count);</div><div class=\"line\">        [_con unlock];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>##GCD</p>\n<p>###基本用法</p>\n<p>####队列</p>\n<ul>\n<li>串行队列：同时只能执行一个任务<ul>\n<li>所有任务都在同一个线程中执行，FIFO</li>\n<li>多个串行队列之间是并行执行的，会占用多个线程</li>\n<li>创建串行队列：<code>dispatch_queue_t serialQueue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_SERIAL);</code></li>\n<li><code>dispatch_get_main_queue();</code>获取主线程上的一个全局可用的串行队列</li>\n</ul>\n</li>\n<li>并行队列：同时可以执行多个任务<ul>\n<li>多个任务在不同的线程上执行，最大并发数（最多起的线程数）由操作系统根据当前的系统状态决定，不可手动设置（NSOperation可以）</li>\n<li>创建并行队列：<code>dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</code></li>\n<li><code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</code>获取一个全局可用的并行队列<br>####任务</li>\n</ul>\n</li>\n<li><p>同步任务：添加一个任务后，需要等待任务执行完后才能返回</p>\n<ul>\n<li>无论是串行队列还是并行队列，同步任务都是在主线程上执行的</li>\n<li>同步任务会阻塞当前线程</li>\n<li>向主队列中添加同步任务会造成<strong>死锁</strong>，见死锁①</li>\n<li>向串行队列中添加嵌套的同步任务会造成<strong>死锁</strong>，见死锁②<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//同步任务</span></div><div class=\"line\"><span class=\"built_in\">dispatch_sync</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">            [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">            <span class=\"comment\">//先打印</span></div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"thread:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">        &#125;);</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"haha\"</span>);<span class=\"comment\">//后打印</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//死锁①</span></div><div class=\"line\"><span class=\"built_in\">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"thread:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">        &#125;);        </div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"haha\"</span>);<span class=\"comment\">//造成死锁，haha永远不会打印</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//死锁②</span></div><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class=\"string\">\"myQueue\"</span>, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\"><span class=\"built_in\">dispatch_sync</span>(serialQueue, ^&#123;</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"thread1:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">            <span class=\"built_in\">dispatch_sync</span>(serialQueue, ^&#123;</div><div class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"thread2:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);<span class=\"comment\">//造成死锁，thread2永远不会打印</span></div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>异步任务：添加一个任务后不需要等待任务执行完成</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//异步任务</span></div><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">            [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">            <span class=\"comment\">//后打印</span></div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"thread:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">        &#125;);</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"haha\"</span>);<span class=\"comment\">//先打印</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>###其他用法</p>\n<ul>\n<li><p>dispatch_after：延迟指定的时间后，将任务添加到指定的队列中</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">10.0</span>f * <span class=\"built_in\">NSEC_PER_SEC</span>));</div><div class=\"line\">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"haha\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>dispatch_group：将多个任务或队列归为一组，在这组的所有任务都执行完之后再执行后面的操作</p>\n<ul>\n<li>dispatch_group_async函数：创建一个指定队列中的异步任务，并将其添加到指定组中</li>\n<li>dispatch_group_notify函数：指定组中所有任务都执行完后，会执行该函数所指定的的任务</li>\n<li>dispatch_group_wait函数：阻塞当前线程，等待group中所有任务执行完毕<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//使用dispatch_group_notify</span></div><div class=\"line\">dispatch_group_t group = dispatch_group_create();</div><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class=\"string\">\"myQueue\"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">&#125;);</div><div class=\"line\">dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">&#125;);</div><div class=\"line\">dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">&#125;);</div><div class=\"line\">dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"4\"</span>);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">dispatch_group_notify(group, concurrentQueue, ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"5\"</span>);<span class=\"comment\">//\"1234\"全部打印后，才会打印5</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//使用dispatch_group_wait</span></div><div class=\"line\">dispatch_group_t group = dispatch_group_create();</div><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class=\"string\">\"myQueue\"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">&#125;);</div><div class=\"line\">dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">&#125;);</div><div class=\"line\">dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">&#125;);</div><div class=\"line\">dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"4\"</span>);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"haha\"</span>);<span class=\"comment\">//\"dispatch_group_wait\"会阻塞线程，所有haha会在\"1234\"之后打印</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>diapatch_once：执行一次</p>\n</li>\n<li><p>dispatch_apply：按照指定的次数将指定的Block追加到指定的DispatchQueue中，并等待全部处理执行结束</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_apply(<span class=\"number\">10</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^(size_t t) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%zu\"</span>, t);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"haha\"</span>);<span class=\"comment\">//等待dispatch_apply中的所有任务都执行完之后才会带引\"haha\"</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>dispatch_suspend / dispatch_resume</p>\n<ul>\n<li>dispatch_suspend：挂起指定的队列</li>\n<li>dispatch_resume：恢复指定的队列</li>\n</ul>\n</li>\n<li>Dispatch Semaphore：信号量，用于排他控制<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">long</span> result = dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">        <span class=\"comment\">//排他，同时只能有一个线程进入这个代码块，相当于锁</span></div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"end wait, result:%ld\"</span>, result);</div><div class=\"line\">        [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\"></div><div class=\"line\">        dispatch_semaphore_signal(semaphore);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>##NSOperation</p>\n<p>###基本用法</p>\n<ul>\n<li><p>NSBlockOperation：以Block的形式定义任务</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">testOperation</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSOperationQueue</span> * queue;</div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">testOperation</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)startTest &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//创建操作</span></div><div class=\"line\">    <span class=\"built_in\">NSOperation</span> * oper1 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"test block operation1, current thread:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">        [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSOperation</span> * oper2 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"test block operation2, current thread:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">        [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSOperation</span> * oper3 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"test block operation3, current thread:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">        [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSOperation</span> * oper4 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"test block operation4, current thread:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">        [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</div><div class=\"line\">    <span class=\"comment\">//将操作加入队列中，操作就会在队列中并发执行，NSOperationQueue默认是并发队列</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.queue addOperation:oper1];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.queue addOperation:oper2];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.queue addOperation:oper3];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.queue addOperation:oper4];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>NSInvocationOperation</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">testOperation</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSOperationQueue</span> * queue;</div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">testOperation</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)startTest &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSMethodSignature</span> * sig = [[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] instanceMethodSignatureForSelector:<span class=\"keyword\">@selector</span>(oper1Fun:andObj2:)];</div><div class=\"line\">    <span class=\"built_in\">NSInvocation</span> * invo = [<span class=\"built_in\">NSInvocation</span> invocationWithMethodSignature:sig];</div><div class=\"line\">    [invo setTarget:<span class=\"keyword\">self</span>];</div><div class=\"line\">    [invo setSelector:<span class=\"keyword\">@selector</span>(oper1Fun:andObj2:)];</div><div class=\"line\">    <span class=\"built_in\">NSString</span> * arg1 = <span class=\"string\">@\"haha\"</span>;</div><div class=\"line\">    <span class=\"built_in\">NSString</span> * arg2 = <span class=\"string\">@\"oooo\"</span>;</div><div class=\"line\">    [invo setArgument:&amp;arg1 atIndex:<span class=\"number\">2</span>];</div><div class=\"line\">    [invo setArgument:&amp;arg2 atIndex:<span class=\"number\">3</span>];</div><div class=\"line\">    <span class=\"built_in\">NSOperation</span> * oper1 = [[<span class=\"built_in\">NSInvocationOperation</span> alloc] initWithInvocation:invo];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSOperation</span> * oper2 = [[<span class=\"built_in\">NSInvocationOperation</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(oper2Fun) object:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.queue addOperation:oper1];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.queue addOperation:oper2];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)oper1Fun:(<span class=\"keyword\">id</span>)obj1 andObj2:(<span class=\"keyword\">id</span>)obj2 &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"test invocation operation1, current thread:%@, obj1:%@, obj2:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread], obj1, obj2);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)oper2Fun &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"test invocation operation2, current thread:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>继承NSOperation，重写main方法</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyOperation</span> : <span class=\"title\">NSOperation</span></span></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyOperation</span></span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)main &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"MyOperation, current thread:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//main.m</span></div><div class=\"line\"><span class=\"built_in\">NSOperationQueue</span> * queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</div><div class=\"line\"></div><div class=\"line\">MyOperation * op1 = [[MyOperation alloc] init];</div><div class=\"line\">MyOperation * op2 = [[MyOperation alloc] init];</div><div class=\"line\">MyOperation * op3 = [[MyOperation alloc] init];</div><div class=\"line\">MyOperation * op4 = [[MyOperation alloc] init];</div><div class=\"line\">MyOperation * op5 = [[MyOperation alloc] init];</div><div class=\"line\">MyOperation * op6 = [[MyOperation alloc] init];</div><div class=\"line\"></div><div class=\"line\">[queue addOperation:op1];</div><div class=\"line\">[queue addOperation:op2];</div><div class=\"line\">[queue addOperation:op3];</div><div class=\"line\">[queue addOperation:op4];</div><div class=\"line\">[queue addOperation:op5];</div><div class=\"line\">[queue addOperation:op6];</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>###其他用法</p>\n<ul>\n<li>设置最大并发数<br><code>self.queue.maxConcurrentOperationCount = 3;</code></li>\n<li>设置操作之间的依赖关系<br><code>[oper2 addDependency:oper1];//oper2依赖于oper1，即必须oper1执行完之后才能执行oper2</code></li>\n<li>手动管理NSOperation<ul>\n<li>运行一个Operation：<code>- (void)start;</code>默认的start方法会直接进行一些异常判断，然后直接调用<code>- (void)main;</code></li>\n<li>取消一个Operation：<code>- (void)cancel;</code>调用cancel方法并不会停止操作的执行，这取决于main方法中对cancel的处理。如果在main方法中没有对cancel进行处理，发送cancel消息是没有任何效果的<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//MyOperation.m</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyOperation</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)start &#123;</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(main) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)main &#123;</div><div class=\"line\">    <span class=\"built_in\">NSInteger</span> index = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"current thread:%@, index:%ld\"</span>, [<span class=\"built_in\">NSThread</span> currentThread], index++);</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.isCancelled) &#123;</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"cancel\"</span>);</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//main.m</span></div><div class=\"line\">MyOperation * op1 = [[MyOperation alloc] init];</div><div class=\"line\">[op1 start];</div><div class=\"line\">[<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">3.0</span>f];</div><div class=\"line\">[op1 cancel];</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<p>##关于多线程编程</p>\n<p>###什么是多线程<br>简单的来说，并发应用程序中一个单独的执行路径，就是一个线程。</p>\n<p>###相关术语</p>\n<ul>\n<li>进程：用于指代一个正在运行的可执行程序，它可以包含多个线程。</li>\n<li>任务：用于指代抽象的概念，表示需要执行工作。</li>\n<li>线程的同步：同步就是协同步调，按预定的先后次序进行运行。线程的同步即一个线程执行完指定操作后，另个一个线程再执行。</li>\n<li>线程的互斥：线程互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。<br>###iOS中的多线程编程</li>\n<li>pthread（POSIX threads）：一套C语言接口，定义了创建和管理线程的API，非常灵活，可以直接操作线程。</li>\n<li>NSThread：一套OC接口，需要自己手动管理线程，比GCD和NSOperation更加轻量级。</li>\n<li>GCD：是iOS4出的一套并发编程的接口，纯C语言接口。以队列为基础。</li>\n<li>NSOperation：一套面向对象的OC API，不需要手动管理线程。能实现一些GCD实现不了的功能。</li>\n</ul>\n<p>##NSThread</p>\n<p>###基本操作</p>\n<p>####线程的创建</p>\n<ul>\n<li><p>类方法创建线程</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(threadFun:) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"string\">@\"helloworld\"</span>];</div></pre></td></tr></table></figure>\n</li>\n<li><p>实例方法创建线程</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSThread</span> * th = [[<span class=\"built_in\">NSThread</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(threadFun:) object:<span class=\"string\">@\"helloworld\"</span>];</div><div class=\"line\">    [th start];</div></pre></td></tr></table></figure>\n</li>\n<li><p>继承NSThread，重写main方法(与NSOperation类似)</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//MyThread.h</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyThread</span> : <span class=\"title\">NSThread</span></span></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//MyThread.m</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyThread</span></span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)main &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"this is MyThread\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//main.m</span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyThread.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[]) &#123;</div><div class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</div><div class=\"line\">        MyThread * th = [[MyThread alloc] init];</div><div class=\"line\">        [th start];</div><div class=\"line\">        [[<span class=\"built_in\">NSRunLoop</span> mainRunLoop] run];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>其他：NSObject中的方法</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)performSelectorInBackground:(SEL)aSelector withObject:(<span class=\"keyword\">id</span>)arg;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>####线程的基本管理</p>\n<ul>\n<li>获取主线程<code>+ (NSThread *)mainThread</code></li>\n<li>获取当前线程<code>+ (NSThread *)currentThread;</code></li>\n<li>阻塞当前线程<code>+ (void)sleepUntilDate:(NSDate *)date;</code>和<code>+ (void)sleepForTimeInterval:(NSTimeInterval)ti;</code></li>\n<li>销毁消除当前线程（currentThread）<code>+ (void)exit;</code></li>\n<li>取消线程<code>- (void)cancel;</code>：将线程的状体置为cancelled，并不会停止线程的执行</li>\n<li>线程键的通讯<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class=\"keyword\">id</span>)arg waitUntilDone:(<span class=\"built_in\">BOOL</span>)wait;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)performSelector:(SEL)aSelector onThread:(<span class=\"built_in\">NSThread</span> *)thr withObject:(<span class=\"keyword\">id</span>)arg waitUntilDone:(<span class=\"built_in\">BOOL</span>)wait;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>###线程同步与互斥</p>\n<p>####锁</p>\n<ul>\n<li><p>@synchronized（obj）对代码段进行加锁，同时只能一个线程访问该代码段</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@synchronized</span>(<span class=\"keyword\">self</span>) &#123;</div><div class=\"line\">    i++;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%ld\"</span>, i);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>NSLock：与@synchronized类似</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSLock</span> * lock = [[<span class=\"built_in\">NSLock</span> alloc] init];</div><div class=\"line\"><span class=\"keyword\">if</span> ([lock tryLock]) &#123;</div><div class=\"line\">    [lock lock];</div><div class=\"line\">    i++;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%ld\"</span>, i);</div><div class=\"line\">    [lock unlock];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>NSConditionLock条件锁：在所的基础上添加了条件，只有满足对应的条件，才能打开相应的锁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)startTest &#123;</div><div class=\"line\">    _conLock = [[<span class=\"built_in\">NSConditionLock</span> alloc] init];</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(threadFun:) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"string\">@\"top thread\"</span>];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">200</span>; i++) &#123;</div><div class=\"line\">        [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(threadFun2:) toTarget:<span class=\"keyword\">self</span> withObject:@(i)];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)threadFun:(<span class=\"keyword\">id</span>)obj &#123;</div><div class=\"line\"></div><div class=\"line\">    [_conLock lock];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, obj);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">    <span class=\"comment\">//加锁，条件为10</span></div><div class=\"line\">    [_conLock unlockWithCondition:<span class=\"number\">10</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)threadFun2:(<span class=\"keyword\">id</span>)obj &#123;</div><div class=\"line\">    <span class=\"built_in\">NSInteger</span> value = [obj integerValue];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//只有到value等于10时，才能成功加锁，否则阻塞</span></div><div class=\"line\">    [_conLock lockWhenCondition:value];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"thread%@\"</span>, obj);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">    <span class=\"comment\">//解锁，并把条件设为value + 3,则下次上锁的条件为13，一次类推13,16,19...</span></div><div class=\"line\">    [_conLock unlockWithCondition:value + <span class=\"number\">3</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>输出结果：</p>\n<p><img src=\"http://img.blog.csdn.net/20150410103408108\" alt=\"这里写图片描述\"></p>\n<ul>\n<li>NSRecursiveLock递归锁：同一个线程中，递归或多次调用加锁代码段，不会造成死锁<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">j = <span class=\"number\">0</span>;</div><div class=\"line\">[<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(threadFun:) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"string\">@\"top thread1\"</span>];</div><div class=\"line\">[<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(threadFun:) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"string\">@\"top thread2\"</span>];</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)threadFun:(<span class=\"keyword\">id</span>)obj &#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span> testWith:obj];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)testWith:(<span class=\"keyword\">id</span>)obj &#123;</div><div class=\"line\">    [_recLock lock];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"test recursive,thread:%@, lock:%ld\"</span>, obj, j++);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">    <span class=\"keyword\">if</span> (j &lt; <span class=\"number\">10</span>) &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> testWith:obj];</div><div class=\"line\">    &#125;</div><div class=\"line\">    [_recLock unlock];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>输出结果：</p>\n<p><img src=\"http://img.blog.csdn.net/20150410104742410\" alt=\"这里写图片描述\"></p>\n<ul>\n<li>NSDistributedLock分布式锁：用于多个进程之间互斥访问资源，一般用于Mac开发</li>\n</ul>\n<p>####条件<br>使用NSCondition，可以实现多线程的同步，解决类似生产者消费者问题。<br><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"testThread.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">testThread</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSInteger</span> i;</div><div class=\"line\">    <span class=\"built_in\">NSCondition</span> * _con;</div><div class=\"line\">    <span class=\"built_in\">NSMutableArray</span> * _products;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)startTest &#123;</div><div class=\"line\">    _con = [[<span class=\"built_in\">NSCondition</span> alloc] init];</div><div class=\"line\">    _products = [[<span class=\"built_in\">NSMutableArray</span> alloc] init];</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(threadFun2:) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"string\">@\"thread2\"</span>];</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(threadFun2:) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"string\">@\"thread3\"</span>];</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(threadFun1:) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"string\">@\"thread1\"</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)threadFun1:(<span class=\"keyword\">id</span>)obj &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</div><div class=\"line\">        [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">2.0</span>f];</div><div class=\"line\">        [_products addObject:<span class=\"string\">@\"apple\"</span>];<span class=\"comment\">//生产者创造一个产品</span></div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ add one product, product count:%ld\"</span>, obj, _products.count);</div><div class=\"line\">        [_con signal];<span class=\"comment\">//通知消费者，消费产品</span></div><div class=\"line\"><span class=\"comment\">//        [_con broadcast];</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)threadFun2:(<span class=\"keyword\">id</span>)obj &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</div><div class=\"line\">        [_con lock];</div><div class=\"line\">        [_con wait];<span class=\"comment\">//等待生产者的通知</span></div><div class=\"line\">        [_products removeObjectAtIndex:<span class=\"number\">0</span>];<span class=\"comment\">//消费者消费一个产品</span></div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ remove one product, proudct count:%ld\"</span>, obj, _products.count);</div><div class=\"line\">        [_con unlock];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>##GCD</p>\n<p>###基本用法</p>\n<p>####队列</p>\n<ul>\n<li>串行队列：同时只能执行一个任务<ul>\n<li>所有任务都在同一个线程中执行，FIFO</li>\n<li>多个串行队列之间是并行执行的，会占用多个线程</li>\n<li>创建串行队列：<code>dispatch_queue_t serialQueue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_SERIAL);</code></li>\n<li><code>dispatch_get_main_queue();</code>获取主线程上的一个全局可用的串行队列</li>\n</ul>\n</li>\n<li>并行队列：同时可以执行多个任务<ul>\n<li>多个任务在不同的线程上执行，最大并发数（最多起的线程数）由操作系统根据当前的系统状态决定，不可手动设置（NSOperation可以）</li>\n<li>创建并行队列：<code>dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</code></li>\n<li><code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</code>获取一个全局可用的并行队列<br>####任务</li>\n</ul>\n</li>\n<li><p>同步任务：添加一个任务后，需要等待任务执行完后才能返回</p>\n<ul>\n<li>无论是串行队列还是并行队列，同步任务都是在主线程上执行的</li>\n<li>同步任务会阻塞当前线程</li>\n<li>向主队列中添加同步任务会造成<strong>死锁</strong>，见死锁①</li>\n<li>向串行队列中添加嵌套的同步任务会造成<strong>死锁</strong>，见死锁②<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//同步任务</span></div><div class=\"line\"><span class=\"built_in\">dispatch_sync</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">            [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">            <span class=\"comment\">//先打印</span></div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"thread:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">        &#125;);</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"haha\"</span>);<span class=\"comment\">//后打印</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//死锁①</span></div><div class=\"line\"><span class=\"built_in\">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"thread:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">        &#125;);        </div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"haha\"</span>);<span class=\"comment\">//造成死锁，haha永远不会打印</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//死锁②</span></div><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class=\"string\">\"myQueue\"</span>, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\"><span class=\"built_in\">dispatch_sync</span>(serialQueue, ^&#123;</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"thread1:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">            <span class=\"built_in\">dispatch_sync</span>(serialQueue, ^&#123;</div><div class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"thread2:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);<span class=\"comment\">//造成死锁，thread2永远不会打印</span></div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>异步任务：添加一个任务后不需要等待任务执行完成</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//异步任务</span></div><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">            [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">            <span class=\"comment\">//后打印</span></div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"thread:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">        &#125;);</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"haha\"</span>);<span class=\"comment\">//先打印</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>###其他用法</p>\n<ul>\n<li><p>dispatch_after：延迟指定的时间后，将任务添加到指定的队列中</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">10.0</span>f * <span class=\"built_in\">NSEC_PER_SEC</span>));</div><div class=\"line\">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"haha\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>dispatch_group：将多个任务或队列归为一组，在这组的所有任务都执行完之后再执行后面的操作</p>\n<ul>\n<li>dispatch_group_async函数：创建一个指定队列中的异步任务，并将其添加到指定组中</li>\n<li>dispatch_group_notify函数：指定组中所有任务都执行完后，会执行该函数所指定的的任务</li>\n<li>dispatch_group_wait函数：阻塞当前线程，等待group中所有任务执行完毕<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//使用dispatch_group_notify</span></div><div class=\"line\">dispatch_group_t group = dispatch_group_create();</div><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class=\"string\">\"myQueue\"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">&#125;);</div><div class=\"line\">dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">&#125;);</div><div class=\"line\">dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">&#125;);</div><div class=\"line\">dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"4\"</span>);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">dispatch_group_notify(group, concurrentQueue, ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"5\"</span>);<span class=\"comment\">//\"1234\"全部打印后，才会打印5</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//使用dispatch_group_wait</span></div><div class=\"line\">dispatch_group_t group = dispatch_group_create();</div><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class=\"string\">\"myQueue\"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">&#125;);</div><div class=\"line\">dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">&#125;);</div><div class=\"line\">dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">&#125;);</div><div class=\"line\">dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"4\"</span>);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"haha\"</span>);<span class=\"comment\">//\"dispatch_group_wait\"会阻塞线程，所有haha会在\"1234\"之后打印</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>diapatch_once：执行一次</p>\n</li>\n<li><p>dispatch_apply：按照指定的次数将指定的Block追加到指定的DispatchQueue中，并等待全部处理执行结束</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_apply(<span class=\"number\">10</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^(size_t t) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%zu\"</span>, t);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"haha\"</span>);<span class=\"comment\">//等待dispatch_apply中的所有任务都执行完之后才会带引\"haha\"</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>dispatch_suspend / dispatch_resume</p>\n<ul>\n<li>dispatch_suspend：挂起指定的队列</li>\n<li>dispatch_resume：恢复指定的队列</li>\n</ul>\n</li>\n<li>Dispatch Semaphore：信号量，用于排他控制<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">long</span> result = dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">        <span class=\"comment\">//排他，同时只能有一个线程进入这个代码块，相当于锁</span></div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"end wait, result:%ld\"</span>, result);</div><div class=\"line\">        [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\"></div><div class=\"line\">        dispatch_semaphore_signal(semaphore);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>##NSOperation</p>\n<p>###基本用法</p>\n<ul>\n<li><p>NSBlockOperation：以Block的形式定义任务</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">testOperation</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSOperationQueue</span> * queue;</div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">testOperation</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)startTest &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//创建操作</span></div><div class=\"line\">    <span class=\"built_in\">NSOperation</span> * oper1 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"test block operation1, current thread:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">        [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSOperation</span> * oper2 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"test block operation2, current thread:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">        [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSOperation</span> * oper3 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"test block operation3, current thread:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">        [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSOperation</span> * oper4 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"test block operation4, current thread:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">        [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</div><div class=\"line\">    <span class=\"comment\">//将操作加入队列中，操作就会在队列中并发执行，NSOperationQueue默认是并发队列</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.queue addOperation:oper1];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.queue addOperation:oper2];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.queue addOperation:oper3];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.queue addOperation:oper4];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>NSInvocationOperation</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">testOperation</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSOperationQueue</span> * queue;</div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">testOperation</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)startTest &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSMethodSignature</span> * sig = [[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] instanceMethodSignatureForSelector:<span class=\"keyword\">@selector</span>(oper1Fun:andObj2:)];</div><div class=\"line\">    <span class=\"built_in\">NSInvocation</span> * invo = [<span class=\"built_in\">NSInvocation</span> invocationWithMethodSignature:sig];</div><div class=\"line\">    [invo setTarget:<span class=\"keyword\">self</span>];</div><div class=\"line\">    [invo setSelector:<span class=\"keyword\">@selector</span>(oper1Fun:andObj2:)];</div><div class=\"line\">    <span class=\"built_in\">NSString</span> * arg1 = <span class=\"string\">@\"haha\"</span>;</div><div class=\"line\">    <span class=\"built_in\">NSString</span> * arg2 = <span class=\"string\">@\"oooo\"</span>;</div><div class=\"line\">    [invo setArgument:&amp;arg1 atIndex:<span class=\"number\">2</span>];</div><div class=\"line\">    [invo setArgument:&amp;arg2 atIndex:<span class=\"number\">3</span>];</div><div class=\"line\">    <span class=\"built_in\">NSOperation</span> * oper1 = [[<span class=\"built_in\">NSInvocationOperation</span> alloc] initWithInvocation:invo];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSOperation</span> * oper2 = [[<span class=\"built_in\">NSInvocationOperation</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(oper2Fun) object:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.queue addOperation:oper1];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.queue addOperation:oper2];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)oper1Fun:(<span class=\"keyword\">id</span>)obj1 andObj2:(<span class=\"keyword\">id</span>)obj2 &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"test invocation operation1, current thread:%@, obj1:%@, obj2:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread], obj1, obj2);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)oper2Fun &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"test invocation operation2, current thread:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>继承NSOperation，重写main方法</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyOperation</span> : <span class=\"title\">NSOperation</span></span></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyOperation</span></span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)main &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"MyOperation, current thread:%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//main.m</span></div><div class=\"line\"><span class=\"built_in\">NSOperationQueue</span> * queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</div><div class=\"line\"></div><div class=\"line\">MyOperation * op1 = [[MyOperation alloc] init];</div><div class=\"line\">MyOperation * op2 = [[MyOperation alloc] init];</div><div class=\"line\">MyOperation * op3 = [[MyOperation alloc] init];</div><div class=\"line\">MyOperation * op4 = [[MyOperation alloc] init];</div><div class=\"line\">MyOperation * op5 = [[MyOperation alloc] init];</div><div class=\"line\">MyOperation * op6 = [[MyOperation alloc] init];</div><div class=\"line\"></div><div class=\"line\">[queue addOperation:op1];</div><div class=\"line\">[queue addOperation:op2];</div><div class=\"line\">[queue addOperation:op3];</div><div class=\"line\">[queue addOperation:op4];</div><div class=\"line\">[queue addOperation:op5];</div><div class=\"line\">[queue addOperation:op6];</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>###其他用法</p>\n<ul>\n<li>设置最大并发数<br><code>self.queue.maxConcurrentOperationCount = 3;</code></li>\n<li>设置操作之间的依赖关系<br><code>[oper2 addDependency:oper1];//oper2依赖于oper1，即必须oper1执行完之后才能执行oper2</code></li>\n<li>手动管理NSOperation<ul>\n<li>运行一个Operation：<code>- (void)start;</code>默认的start方法会直接进行一些异常判断，然后直接调用<code>- (void)main;</code></li>\n<li>取消一个Operation：<code>- (void)cancel;</code>调用cancel方法并不会停止操作的执行，这取决于main方法中对cancel的处理。如果在main方法中没有对cancel进行处理，发送cancel消息是没有任何效果的<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//MyOperation.m</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyOperation</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)start &#123;</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(main) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)main &#123;</div><div class=\"line\">    <span class=\"built_in\">NSInteger</span> index = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"current thread:%@, index:%ld\"</span>, [<span class=\"built_in\">NSThread</span> currentThread], index++);</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.isCancelled) &#123;</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"cancel\"</span>);</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>f];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//main.m</span></div><div class=\"line\">MyOperation * op1 = [[MyOperation alloc] init];</div><div class=\"line\">[op1 start];</div><div class=\"line\">[<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">3.0</span>f];</div><div class=\"line\">[op1 cancel];</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n"},{"layout":"post","title":"iOS中的富文本技术(2)CoreText框架","_content":"\n\n## 前言\n前一篇介绍了iOS7新出的TextKit，这一篇打算介绍一下更底层的CoreText框架\n\n## 简介\nCoreText是iOS3.2推出的一套文字排版和渲染框架，可以实现图文混排，富文本显示等效果。CoreText中的几个重要的概念：\n* CTFrameRef：画布，包含多个CTLine\n* CTLineRef：每一行就是一个CTLine\n* CTRunRef：每一行可以分为多个属性相同的小段，每一个小段就是一个CTRun\n如下图展示了这三者的关系：\n\n![这里写图片描述](http://img.blog.csdn.net/20150403235844681)\n\n## 示例\n废话不多说，直接看示例，第一个示例展示了一些常规属性的的设置，效果图如下：\n\n![这里写图片描述](http://img.blog.csdn.net/20150404001114995)\n\n代码如下，这里使用了一个自定义View，然后把要展示的内容绘制在view上，注意代码中使用了很多CoreFoundation框架的类（实际上是结构体），需要使用__bridge进行桥接：\n\n```objectivec\n#import \"DisplayView.h\"\n@import CoreText;\n\nNSString * str4 = @\"asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费\";\n\n@interface DisplayView ()\n\n@end\n\n@implementation DisplayView\n\n- (void)drawRect:(CGRect)rect {\n\n    [super drawRect:rect];\n\n    CGContextRef context = UIGraphicsGetCurrentContext();\n\n    //变换坐标\n    CGContextSetTextMatrix(context, CGAffineTransformIdentity);\n    CGContextTranslateCTM(context, 0, self.bounds.size.height);\n    CGContextScaleCTM(context, 1.0, -1.0);\n\n    //设置绘制的路径\n    CGMutablePathRef path = CGPathCreateMutable();\n    CGPathAddRect(path, NULL, self.bounds);\n\n    //创建属性字符串\n    NSMutableAttributedString * attStr = [[NSMutableAttributedString alloc] initWithString:str4];\n\n    //颜色\n    [attStr addAttribute:(__bridge NSString *)kCTForegroundColorAttributeName value:(__bridge id)[UIColor redColor].CGColor range:NSMakeRange(5, 10)];\n\n    //字体\n    UIFont * font = [UIFont systemFontOfSize:25];\n    CTFontRef fontRef = CTFontCreateWithName((__bridge CFStringRef)font.fontName, 25, NULL);\n    [attStr addAttribute:(__bridge NSString *)kCTFontAttributeName value:(__bridge id)fontRef range:NSMakeRange(20, 10)];\n\n    //空心字\n    [attStr addAttribute:(__bridge NSString *)kCTStrokeWidthAttributeName value:@(3) range:NSMakeRange(36, 5)];\n    [attStr addAttribute:(__bridge NSString *)kCTStrokeColorAttributeName value:(__bridge id)[UIColor blueColor].CGColor range:NSMakeRange(37, 10)];\n\n    //下划线\n    [attStr addAttribute:(__bridge NSString *)kCTUnderlineStyleAttributeName value:@(kCTUnderlineStyleSingle | kCTUnderlinePatternDot) range:NSMakeRange(45, 15)];\n\n\n    CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attStr);\n    CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, attStr.length), path, NULL);\n\n    //绘制内容\n    CTFrameDraw(frame, context);\n\n    CFRelease(fontRef);\n    CFRelease(frame);\n    CFRelease(path);\n    CFRelease(framesetter);\n\n}\n@end\n```\n\n第二个示例展示了一个带表情符号的文本，效果图如下：\n\n![这里写图片描述](http://img.blog.csdn.net/20150404002937477)\n\n先介绍一下CoreText实现表情混排的原理，在简介中介绍过，一个CTLine代表一行，而一个CTLine又由多个CTRun组成，这里实现表情混排的原理其实就是把CTLine中的某一个CTRun替换成空白字符，然后再根据这个CTRun的具体位置，把图片绘制到这个位置上，下面是具体代码：\n```objectivec\n#import \"ImageDisplayView.h\"\n@import CoreText;\n\nNSString * str5 = @\"asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费\";\n\n@interface ImageDisplayView ()\n\n@property (nonatomic, strong) NSAttributedString * attStr;\n\n@end\n\n//回调方法，返回要替换的CTRun的下边缘距离本行文字下边缘的高度\nstatic CGFloat descentCallback(void *ref)\n{\n    return 0;\n}\n\n//回调方法，返回要替换的CTRun的上边缘距离本行文字上边缘的高度\nstatic CGFloat ascentCallback(void *ref)\n{\n    return 30;\n}\n\n//回调方法，返回要替换的CTRun的宽\nstatic CGFloat widthCallback(void *ref)\n{\n    return 30;\n}\n\n@implementation ImageDisplayView\n{\n    CTRunDelegateRef _delegate;\n}\n\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    self = [super initWithFrame:frame];\n    if (self) {\n        NSString * name = @\"010\";\n        unichar objectReplacementChar           = 0xFFFC;//占位字符\n        NSString *objectReplacementString       = [NSString stringWithCharacters:&objectReplacementChar length:1];\n        NSMutableAttributedString *attachText   = [[NSMutableAttributedString alloc]initWithString:objectReplacementString];\n\n        //创建CTRun代理回调\n        CTRunDelegateCallbacks callbacks;\n        callbacks.version       = kCTRunDelegateVersion1;\n        callbacks.getAscent     = ascentCallback;\n        callbacks.getDescent    = descentCallback;\n        callbacks.getWidth      = widthCallback;\n\n        //给属性字符串添加代理回调\n        CTRunDelegateRef delegate = CTRunDelegateCreate(&callbacks, (void *)name);\n        NSDictionary *attr = [NSDictionary dictionaryWithObjectsAndKeys:(__bridge id)delegate,kCTRunDelegateAttributeName, nil];\n        [attachText setAttributes:attr range:NSMakeRange(0, 1)];\n        self.attStr = attachText;\n    }\n    return self;\n}\n\n- (void)drawRect:(CGRect)rect {\n\n    [super drawRect:rect];\n\n    CGContextRef context = UIGraphicsGetCurrentContext();\n\n    //变换坐标\n    CGContextSetTextMatrix(context, CGAffineTransformIdentity);\n    CGContextTranslateCTM(context, 0, self.bounds.size.height);\n    CGContextScaleCTM(context, 1.0, -1.0);\n\n    //设置文本绘制的路径\n    CGMutablePathRef path = CGPathCreateMutable();\n    CGPathAddRect(path, NULL, self.bounds);\n\n    NSMutableAttributedString * attStr = [[NSMutableAttributedString alloc] initWithString:str5];\n    [attStr insertAttributedString:self.attStr atIndex:50];\n\n    CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attStr);\n    CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, attStr.length), path, NULL);\n\n    //计算要替换的CTRun的具体位置\n    NSArray * lines = (NSArray *)CTFrameGetLines(frame);\n    NSUInteger lineCount = lines.count;\n    CGPoint lineOrigins[lineCount];\n    CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), lineOrigins);\n    //循环遍历每一个CTLine中的每一个CTRun，找到要替换的那个CTRun，并且计算它的位置\n    for (int i = 0; i < lineCount; i++) {\n        CTLineRef line = (__bridge CTLineRef)lines[i];\n        CFArrayRef runs = CTLineGetGlyphRuns(line);\n        CFIndex runCount = CFArrayGetCount(runs);\n        CGPoint lineOrigin = lineOrigins[i];\n        CGFloat lineAscent;\n        CGFloat lineDescent;\n        CTLineGetTypographicBounds(line, &lineAscent, &lineDescent, NULL);\n        for (CFIndex k = 0; k < runCount; k++)\n        {\n            CTRunRef run = CFArrayGetValueAtIndex(runs, k);\n            NSDictionary *runAttributes = (NSDictionary *)CTRunGetAttributes(run);\n            CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[runAttributes valueForKey:(id)kCTRunDelegateAttributeName];\n            if (nil == delegate)\n            {\n                continue;\n            }\n\n            CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, nil);\n            CGRect rect = CGRectMake(lineOrigin.x + xOffset, lineOrigin.y - lineDescent, 30, 30);\n\n            //绘制图片\n            CGContextDrawImage(context, rect, [UIImage imageNamed:@\"010\"].CGImage);\n        }\n\n    }\n\n    CTFrameDraw(frame, context);\n\n    CFRelease(frame);\n    CFRelease(path);\n    CFRelease(framesetter);\n\n}\n\n@end\n```\n\n## 总结\n\n下面总结一下CoreText的优缺点：\n* 优点：功能强大，支持iOS3.2以后的所有系统\n* 缺点：纯C的接口，使用复杂，需要自己管理内存\n\nCoreText更加详细的介绍推荐大家可以看看唐巧大神的《iOS开发进阶》第十七章的内容。\n","source":"_posts/2015-10-04-iOS中的富文本技术(2)CoreText框架.md","raw":"---\nlayout: post\ntitle: \"iOS中的富文本技术(2)CoreText框架\"\ncategories: \"iOS开发\"\n---\n\n\n## 前言\n前一篇介绍了iOS7新出的TextKit，这一篇打算介绍一下更底层的CoreText框架\n\n## 简介\nCoreText是iOS3.2推出的一套文字排版和渲染框架，可以实现图文混排，富文本显示等效果。CoreText中的几个重要的概念：\n* CTFrameRef：画布，包含多个CTLine\n* CTLineRef：每一行就是一个CTLine\n* CTRunRef：每一行可以分为多个属性相同的小段，每一个小段就是一个CTRun\n如下图展示了这三者的关系：\n\n![这里写图片描述](http://img.blog.csdn.net/20150403235844681)\n\n## 示例\n废话不多说，直接看示例，第一个示例展示了一些常规属性的的设置，效果图如下：\n\n![这里写图片描述](http://img.blog.csdn.net/20150404001114995)\n\n代码如下，这里使用了一个自定义View，然后把要展示的内容绘制在view上，注意代码中使用了很多CoreFoundation框架的类（实际上是结构体），需要使用__bridge进行桥接：\n\n```objectivec\n#import \"DisplayView.h\"\n@import CoreText;\n\nNSString * str4 = @\"asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费\";\n\n@interface DisplayView ()\n\n@end\n\n@implementation DisplayView\n\n- (void)drawRect:(CGRect)rect {\n\n    [super drawRect:rect];\n\n    CGContextRef context = UIGraphicsGetCurrentContext();\n\n    //变换坐标\n    CGContextSetTextMatrix(context, CGAffineTransformIdentity);\n    CGContextTranslateCTM(context, 0, self.bounds.size.height);\n    CGContextScaleCTM(context, 1.0, -1.0);\n\n    //设置绘制的路径\n    CGMutablePathRef path = CGPathCreateMutable();\n    CGPathAddRect(path, NULL, self.bounds);\n\n    //创建属性字符串\n    NSMutableAttributedString * attStr = [[NSMutableAttributedString alloc] initWithString:str4];\n\n    //颜色\n    [attStr addAttribute:(__bridge NSString *)kCTForegroundColorAttributeName value:(__bridge id)[UIColor redColor].CGColor range:NSMakeRange(5, 10)];\n\n    //字体\n    UIFont * font = [UIFont systemFontOfSize:25];\n    CTFontRef fontRef = CTFontCreateWithName((__bridge CFStringRef)font.fontName, 25, NULL);\n    [attStr addAttribute:(__bridge NSString *)kCTFontAttributeName value:(__bridge id)fontRef range:NSMakeRange(20, 10)];\n\n    //空心字\n    [attStr addAttribute:(__bridge NSString *)kCTStrokeWidthAttributeName value:@(3) range:NSMakeRange(36, 5)];\n    [attStr addAttribute:(__bridge NSString *)kCTStrokeColorAttributeName value:(__bridge id)[UIColor blueColor].CGColor range:NSMakeRange(37, 10)];\n\n    //下划线\n    [attStr addAttribute:(__bridge NSString *)kCTUnderlineStyleAttributeName value:@(kCTUnderlineStyleSingle | kCTUnderlinePatternDot) range:NSMakeRange(45, 15)];\n\n\n    CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attStr);\n    CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, attStr.length), path, NULL);\n\n    //绘制内容\n    CTFrameDraw(frame, context);\n\n    CFRelease(fontRef);\n    CFRelease(frame);\n    CFRelease(path);\n    CFRelease(framesetter);\n\n}\n@end\n```\n\n第二个示例展示了一个带表情符号的文本，效果图如下：\n\n![这里写图片描述](http://img.blog.csdn.net/20150404002937477)\n\n先介绍一下CoreText实现表情混排的原理，在简介中介绍过，一个CTLine代表一行，而一个CTLine又由多个CTRun组成，这里实现表情混排的原理其实就是把CTLine中的某一个CTRun替换成空白字符，然后再根据这个CTRun的具体位置，把图片绘制到这个位置上，下面是具体代码：\n```objectivec\n#import \"ImageDisplayView.h\"\n@import CoreText;\n\nNSString * str5 = @\"asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费\";\n\n@interface ImageDisplayView ()\n\n@property (nonatomic, strong) NSAttributedString * attStr;\n\n@end\n\n//回调方法，返回要替换的CTRun的下边缘距离本行文字下边缘的高度\nstatic CGFloat descentCallback(void *ref)\n{\n    return 0;\n}\n\n//回调方法，返回要替换的CTRun的上边缘距离本行文字上边缘的高度\nstatic CGFloat ascentCallback(void *ref)\n{\n    return 30;\n}\n\n//回调方法，返回要替换的CTRun的宽\nstatic CGFloat widthCallback(void *ref)\n{\n    return 30;\n}\n\n@implementation ImageDisplayView\n{\n    CTRunDelegateRef _delegate;\n}\n\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    self = [super initWithFrame:frame];\n    if (self) {\n        NSString * name = @\"010\";\n        unichar objectReplacementChar           = 0xFFFC;//占位字符\n        NSString *objectReplacementString       = [NSString stringWithCharacters:&objectReplacementChar length:1];\n        NSMutableAttributedString *attachText   = [[NSMutableAttributedString alloc]initWithString:objectReplacementString];\n\n        //创建CTRun代理回调\n        CTRunDelegateCallbacks callbacks;\n        callbacks.version       = kCTRunDelegateVersion1;\n        callbacks.getAscent     = ascentCallback;\n        callbacks.getDescent    = descentCallback;\n        callbacks.getWidth      = widthCallback;\n\n        //给属性字符串添加代理回调\n        CTRunDelegateRef delegate = CTRunDelegateCreate(&callbacks, (void *)name);\n        NSDictionary *attr = [NSDictionary dictionaryWithObjectsAndKeys:(__bridge id)delegate,kCTRunDelegateAttributeName, nil];\n        [attachText setAttributes:attr range:NSMakeRange(0, 1)];\n        self.attStr = attachText;\n    }\n    return self;\n}\n\n- (void)drawRect:(CGRect)rect {\n\n    [super drawRect:rect];\n\n    CGContextRef context = UIGraphicsGetCurrentContext();\n\n    //变换坐标\n    CGContextSetTextMatrix(context, CGAffineTransformIdentity);\n    CGContextTranslateCTM(context, 0, self.bounds.size.height);\n    CGContextScaleCTM(context, 1.0, -1.0);\n\n    //设置文本绘制的路径\n    CGMutablePathRef path = CGPathCreateMutable();\n    CGPathAddRect(path, NULL, self.bounds);\n\n    NSMutableAttributedString * attStr = [[NSMutableAttributedString alloc] initWithString:str5];\n    [attStr insertAttributedString:self.attStr atIndex:50];\n\n    CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attStr);\n    CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, attStr.length), path, NULL);\n\n    //计算要替换的CTRun的具体位置\n    NSArray * lines = (NSArray *)CTFrameGetLines(frame);\n    NSUInteger lineCount = lines.count;\n    CGPoint lineOrigins[lineCount];\n    CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), lineOrigins);\n    //循环遍历每一个CTLine中的每一个CTRun，找到要替换的那个CTRun，并且计算它的位置\n    for (int i = 0; i < lineCount; i++) {\n        CTLineRef line = (__bridge CTLineRef)lines[i];\n        CFArrayRef runs = CTLineGetGlyphRuns(line);\n        CFIndex runCount = CFArrayGetCount(runs);\n        CGPoint lineOrigin = lineOrigins[i];\n        CGFloat lineAscent;\n        CGFloat lineDescent;\n        CTLineGetTypographicBounds(line, &lineAscent, &lineDescent, NULL);\n        for (CFIndex k = 0; k < runCount; k++)\n        {\n            CTRunRef run = CFArrayGetValueAtIndex(runs, k);\n            NSDictionary *runAttributes = (NSDictionary *)CTRunGetAttributes(run);\n            CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[runAttributes valueForKey:(id)kCTRunDelegateAttributeName];\n            if (nil == delegate)\n            {\n                continue;\n            }\n\n            CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, nil);\n            CGRect rect = CGRectMake(lineOrigin.x + xOffset, lineOrigin.y - lineDescent, 30, 30);\n\n            //绘制图片\n            CGContextDrawImage(context, rect, [UIImage imageNamed:@\"010\"].CGImage);\n        }\n\n    }\n\n    CTFrameDraw(frame, context);\n\n    CFRelease(frame);\n    CFRelease(path);\n    CFRelease(framesetter);\n\n}\n\n@end\n```\n\n## 总结\n\n下面总结一下CoreText的优缺点：\n* 优点：功能强大，支持iOS3.2以后的所有系统\n* 缺点：纯C的接口，使用复杂，需要自己管理内存\n\nCoreText更加详细的介绍推荐大家可以看看唐巧大神的《iOS开发进阶》第十七章的内容。\n","slug":"iOS中的富文本技术(2)CoreText框架","published":1,"date":"2015-10-03T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oaa00008zrm0eq8rvu3m","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前一篇介绍了iOS7新出的TextKit，这一篇打算介绍一下更底层的CoreText框架</p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>CoreText是iOS3.2推出的一套文字排版和渲染框架，可以实现图文混排，富文本显示等效果。CoreText中的几个重要的概念：</p>\n<ul>\n<li>CTFrameRef：画布，包含多个CTLine</li>\n<li>CTLineRef：每一行就是一个CTLine</li>\n<li>CTRunRef：每一行可以分为多个属性相同的小段，每一个小段就是一个CTRun<br>如下图展示了这三者的关系：</li>\n</ul>\n<p><img src=\"http://img.blog.csdn.net/20150403235844681\" alt=\"这里写图片描述\"></p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>废话不多说，直接看示例，第一个示例展示了一些常规属性的的设置，效果图如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20150404001114995\" alt=\"这里写图片描述\"></p>\n<p>代码如下，这里使用了一个自定义View，然后把要展示的内容绘制在view上，注意代码中使用了很多CoreFoundation框架的类（实际上是结构体），需要使用__bridge进行桥接：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"DisplayView.h\"</span></span></div><div class=\"line\"><span class=\"keyword\">@import</span> CoreText;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSString</span> * str4 = <span class=\"string\">@\"asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">DisplayView</span> ()</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">DisplayView</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)drawRect:(<span class=\"built_in\">CGRect</span>)rect &#123;</div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">super</span> drawRect:rect];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">UIGraphicsGetCurrentContext</span>();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//变换坐标</span></div><div class=\"line\">    <span class=\"built_in\">CGContextSetTextMatrix</span>(context, <span class=\"built_in\">CGAffineTransformIdentity</span>);</div><div class=\"line\">    <span class=\"built_in\">CGContextTranslateCTM</span>(context, <span class=\"number\">0</span>, <span class=\"keyword\">self</span>.bounds.size.height);</div><div class=\"line\">    <span class=\"built_in\">CGContextScaleCTM</span>(context, <span class=\"number\">1.0</span>, <span class=\"number\">-1.0</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//设置绘制的路径</span></div><div class=\"line\">    <span class=\"built_in\">CGMutablePathRef</span> path = <span class=\"built_in\">CGPathCreateMutable</span>();</div><div class=\"line\">    <span class=\"built_in\">CGPathAddRect</span>(path, <span class=\"literal\">NULL</span>, <span class=\"keyword\">self</span>.bounds);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//创建属性字符串</span></div><div class=\"line\">    <span class=\"built_in\">NSMutableAttributedString</span> * attStr = [[<span class=\"built_in\">NSMutableAttributedString</span> alloc] initWithString:str4];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//颜色</span></div><div class=\"line\">    [attStr addAttribute:(__bridge <span class=\"built_in\">NSString</span> *)kCTForegroundColorAttributeName value:(__bridge <span class=\"keyword\">id</span>)[<span class=\"built_in\">UIColor</span> redColor].CGColor range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">5</span>, <span class=\"number\">10</span>)];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//字体</span></div><div class=\"line\">    <span class=\"built_in\">UIFont</span> * font = [<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">25</span>];</div><div class=\"line\">    <span class=\"built_in\">CTFontRef</span> fontRef = <span class=\"built_in\">CTFontCreateWithName</span>((__bridge <span class=\"built_in\">CFStringRef</span>)font.fontName, <span class=\"number\">25</span>, <span class=\"literal\">NULL</span>);</div><div class=\"line\">    [attStr addAttribute:(__bridge <span class=\"built_in\">NSString</span> *)kCTFontAttributeName value:(__bridge <span class=\"keyword\">id</span>)fontRef range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">20</span>, <span class=\"number\">10</span>)];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//空心字</span></div><div class=\"line\">    [attStr addAttribute:(__bridge <span class=\"built_in\">NSString</span> *)kCTStrokeWidthAttributeName value:@(<span class=\"number\">3</span>) range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">36</span>, <span class=\"number\">5</span>)];</div><div class=\"line\">    [attStr addAttribute:(__bridge <span class=\"built_in\">NSString</span> *)kCTStrokeColorAttributeName value:(__bridge <span class=\"keyword\">id</span>)[<span class=\"built_in\">UIColor</span> blueColor].CGColor range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">37</span>, <span class=\"number\">10</span>)];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//下划线</span></div><div class=\"line\">    [attStr addAttribute:(__bridge <span class=\"built_in\">NSString</span> *)kCTUnderlineStyleAttributeName value:@(kCTUnderlineStyleSingle | kCTUnderlinePatternDot) range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">45</span>, <span class=\"number\">15</span>)];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">CTFramesetterRef</span> framesetter = <span class=\"built_in\">CTFramesetterCreateWithAttributedString</span>((<span class=\"built_in\">CFAttributedStringRef</span>)attStr);</div><div class=\"line\">    <span class=\"built_in\">CTFrameRef</span> frame = <span class=\"built_in\">CTFramesetterCreateFrame</span>(framesetter, <span class=\"built_in\">CFRangeMake</span>(<span class=\"number\">0</span>, attStr.length), path, <span class=\"literal\">NULL</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//绘制内容</span></div><div class=\"line\">    <span class=\"built_in\">CTFrameDraw</span>(frame, context);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">CFRelease</span>(fontRef);</div><div class=\"line\">    <span class=\"built_in\">CFRelease</span>(frame);</div><div class=\"line\">    <span class=\"built_in\">CFRelease</span>(path);</div><div class=\"line\">    <span class=\"built_in\">CFRelease</span>(framesetter);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>第二个示例展示了一个带表情符号的文本，效果图如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20150404002937477\" alt=\"这里写图片描述\"></p>\n<p>先介绍一下CoreText实现表情混排的原理，在简介中介绍过，一个CTLine代表一行，而一个CTLine又由多个CTRun组成，这里实现表情混排的原理其实就是把CTLine中的某一个CTRun替换成空白字符，然后再根据这个CTRun的具体位置，把图片绘制到这个位置上，下面是具体代码：<br><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"ImageDisplayView.h\"</span></span></div><div class=\"line\"><span class=\"keyword\">@import</span> CoreText;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSString</span> * str5 = <span class=\"string\">@\"asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ImageDisplayView</span> ()</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSAttributedString</span> * attStr;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//回调方法，返回要替换的CTRun的下边缘距离本行文字下边缘的高度</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">CGFloat</span> descentCallback(<span class=\"keyword\">void</span> *ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//回调方法，返回要替换的CTRun的上边缘距离本行文字上边缘的高度</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">CGFloat</span> ascentCallback(<span class=\"keyword\">void</span> *ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">30</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//回调方法，返回要替换的CTRun的宽</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">CGFloat</span> widthCallback(<span class=\"keyword\">void</span> *ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">30</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ImageDisplayView</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">CTRunDelegateRef</span> _delegate;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithFrame:(<span class=\"built_in\">CGRect</span>)frame</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> initWithFrame:frame];</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSString</span> * name = <span class=\"string\">@\"010\"</span>;</div><div class=\"line\">        <span class=\"keyword\">unichar</span> objectReplacementChar           = <span class=\"number\">0xFFFC</span>;<span class=\"comment\">//占位字符</span></div><div class=\"line\">        <span class=\"built_in\">NSString</span> *objectReplacementString       = [<span class=\"built_in\">NSString</span> stringWithCharacters:&amp;objectReplacementChar length:<span class=\"number\">1</span>];</div><div class=\"line\">        <span class=\"built_in\">NSMutableAttributedString</span> *attachText   = [[<span class=\"built_in\">NSMutableAttributedString</span> alloc]initWithString:objectReplacementString];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//创建CTRun代理回调</span></div><div class=\"line\">        <span class=\"built_in\">CTRunDelegateCallbacks</span> callbacks;</div><div class=\"line\">        callbacks.version       = kCTRunDelegateVersion1;</div><div class=\"line\">        callbacks.getAscent     = ascentCallback;</div><div class=\"line\">        callbacks.getDescent    = descentCallback;</div><div class=\"line\">        callbacks.getWidth      = widthCallback;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//给属性字符串添加代理回调</span></div><div class=\"line\">        <span class=\"built_in\">CTRunDelegateRef</span> delegate = <span class=\"built_in\">CTRunDelegateCreate</span>(&amp;callbacks, (<span class=\"keyword\">void</span> *)name);</div><div class=\"line\">        <span class=\"built_in\">NSDictionary</span> *attr = [<span class=\"built_in\">NSDictionary</span> dictionaryWithObjectsAndKeys:(__bridge <span class=\"keyword\">id</span>)delegate,kCTRunDelegateAttributeName, <span class=\"literal\">nil</span>];</div><div class=\"line\">        [attachText setAttributes:attr range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>)];</div><div class=\"line\">        <span class=\"keyword\">self</span>.attStr = attachText;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)drawRect:(<span class=\"built_in\">CGRect</span>)rect &#123;</div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">super</span> drawRect:rect];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">UIGraphicsGetCurrentContext</span>();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//变换坐标</span></div><div class=\"line\">    <span class=\"built_in\">CGContextSetTextMatrix</span>(context, <span class=\"built_in\">CGAffineTransformIdentity</span>);</div><div class=\"line\">    <span class=\"built_in\">CGContextTranslateCTM</span>(context, <span class=\"number\">0</span>, <span class=\"keyword\">self</span>.bounds.size.height);</div><div class=\"line\">    <span class=\"built_in\">CGContextScaleCTM</span>(context, <span class=\"number\">1.0</span>, <span class=\"number\">-1.0</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//设置文本绘制的路径</span></div><div class=\"line\">    <span class=\"built_in\">CGMutablePathRef</span> path = <span class=\"built_in\">CGPathCreateMutable</span>();</div><div class=\"line\">    <span class=\"built_in\">CGPathAddRect</span>(path, <span class=\"literal\">NULL</span>, <span class=\"keyword\">self</span>.bounds);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSMutableAttributedString</span> * attStr = [[<span class=\"built_in\">NSMutableAttributedString</span> alloc] initWithString:str5];</div><div class=\"line\">    [attStr insertAttributedString:<span class=\"keyword\">self</span>.attStr atIndex:<span class=\"number\">50</span>];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">CTFramesetterRef</span> framesetter = <span class=\"built_in\">CTFramesetterCreateWithAttributedString</span>((<span class=\"built_in\">CFAttributedStringRef</span>)attStr);</div><div class=\"line\">    <span class=\"built_in\">CTFrameRef</span> frame = <span class=\"built_in\">CTFramesetterCreateFrame</span>(framesetter, <span class=\"built_in\">CFRangeMake</span>(<span class=\"number\">0</span>, attStr.length), path, <span class=\"literal\">NULL</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//计算要替换的CTRun的具体位置</span></div><div class=\"line\">    <span class=\"built_in\">NSArray</span> * lines = (<span class=\"built_in\">NSArray</span> *)<span class=\"built_in\">CTFrameGetLines</span>(frame);</div><div class=\"line\">    <span class=\"built_in\">NSUInteger</span> lineCount = lines.count;</div><div class=\"line\">    <span class=\"built_in\">CGPoint</span> lineOrigins[lineCount];</div><div class=\"line\">    <span class=\"built_in\">CTFrameGetLineOrigins</span>(frame, <span class=\"built_in\">CFRangeMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>), lineOrigins);</div><div class=\"line\">    <span class=\"comment\">//循环遍历每一个CTLine中的每一个CTRun，找到要替换的那个CTRun，并且计算它的位置</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; lineCount; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">CTLineRef</span> line = (__bridge <span class=\"built_in\">CTLineRef</span>)lines[i];</div><div class=\"line\">        <span class=\"built_in\">CFArrayRef</span> runs = <span class=\"built_in\">CTLineGetGlyphRuns</span>(line);</div><div class=\"line\">        <span class=\"built_in\">CFIndex</span> runCount = <span class=\"built_in\">CFArrayGetCount</span>(runs);</div><div class=\"line\">        <span class=\"built_in\">CGPoint</span> lineOrigin = lineOrigins[i];</div><div class=\"line\">        <span class=\"built_in\">CGFloat</span> lineAscent;</div><div class=\"line\">        <span class=\"built_in\">CGFloat</span> lineDescent;</div><div class=\"line\">        <span class=\"built_in\">CTLineGetTypographicBounds</span>(line, &amp;lineAscent, &amp;lineDescent, <span class=\"literal\">NULL</span>);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">CFIndex</span> k = <span class=\"number\">0</span>; k &lt; runCount; k++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">CTRunRef</span> run = <span class=\"built_in\">CFArrayGetValueAtIndex</span>(runs, k);</div><div class=\"line\">            <span class=\"built_in\">NSDictionary</span> *runAttributes = (<span class=\"built_in\">NSDictionary</span> *)<span class=\"built_in\">CTRunGetAttributes</span>(run);</div><div class=\"line\">            <span class=\"built_in\">CTRunDelegateRef</span> delegate = (__bridge <span class=\"built_in\">CTRunDelegateRef</span>)[runAttributes valueForKey:(<span class=\"keyword\">id</span>)kCTRunDelegateAttributeName];</div><div class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"literal\">nil</span> == delegate)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"built_in\">CGFloat</span> xOffset = <span class=\"built_in\">CTLineGetOffsetForStringIndex</span>(line, <span class=\"built_in\">CTRunGetStringRange</span>(run).location, <span class=\"literal\">nil</span>);</div><div class=\"line\">            <span class=\"built_in\">CGRect</span> rect = <span class=\"built_in\">CGRectMake</span>(lineOrigin.x + xOffset, lineOrigin.y - lineDescent, <span class=\"number\">30</span>, <span class=\"number\">30</span>);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//绘制图片</span></div><div class=\"line\">            <span class=\"built_in\">CGContextDrawImage</span>(context, rect, [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"010\"</span>].CGImage);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">CTFrameDraw</span>(frame, context);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">CFRelease</span>(frame);</div><div class=\"line\">    <span class=\"built_in\">CFRelease</span>(path);</div><div class=\"line\">    <span class=\"built_in\">CFRelease</span>(framesetter);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>下面总结一下CoreText的优缺点：</p>\n<ul>\n<li>优点：功能强大，支持iOS3.2以后的所有系统</li>\n<li>缺点：纯C的接口，使用复杂，需要自己管理内存</li>\n</ul>\n<p>CoreText更加详细的介绍推荐大家可以看看唐巧大神的《iOS开发进阶》第十七章的内容。</p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前一篇介绍了iOS7新出的TextKit，这一篇打算介绍一下更底层的CoreText框架</p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>CoreText是iOS3.2推出的一套文字排版和渲染框架，可以实现图文混排，富文本显示等效果。CoreText中的几个重要的概念：</p>\n<ul>\n<li>CTFrameRef：画布，包含多个CTLine</li>\n<li>CTLineRef：每一行就是一个CTLine</li>\n<li>CTRunRef：每一行可以分为多个属性相同的小段，每一个小段就是一个CTRun<br>如下图展示了这三者的关系：</li>\n</ul>\n<p><img src=\"http://img.blog.csdn.net/20150403235844681\" alt=\"这里写图片描述\"></p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>废话不多说，直接看示例，第一个示例展示了一些常规属性的的设置，效果图如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20150404001114995\" alt=\"这里写图片描述\"></p>\n<p>代码如下，这里使用了一个自定义View，然后把要展示的内容绘制在view上，注意代码中使用了很多CoreFoundation框架的类（实际上是结构体），需要使用__bridge进行桥接：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"DisplayView.h\"</span></span></div><div class=\"line\"><span class=\"keyword\">@import</span> CoreText;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSString</span> * str4 = <span class=\"string\">@\"asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">DisplayView</span> ()</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">DisplayView</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)drawRect:(<span class=\"built_in\">CGRect</span>)rect &#123;</div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">super</span> drawRect:rect];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">UIGraphicsGetCurrentContext</span>();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//变换坐标</span></div><div class=\"line\">    <span class=\"built_in\">CGContextSetTextMatrix</span>(context, <span class=\"built_in\">CGAffineTransformIdentity</span>);</div><div class=\"line\">    <span class=\"built_in\">CGContextTranslateCTM</span>(context, <span class=\"number\">0</span>, <span class=\"keyword\">self</span>.bounds.size.height);</div><div class=\"line\">    <span class=\"built_in\">CGContextScaleCTM</span>(context, <span class=\"number\">1.0</span>, <span class=\"number\">-1.0</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//设置绘制的路径</span></div><div class=\"line\">    <span class=\"built_in\">CGMutablePathRef</span> path = <span class=\"built_in\">CGPathCreateMutable</span>();</div><div class=\"line\">    <span class=\"built_in\">CGPathAddRect</span>(path, <span class=\"literal\">NULL</span>, <span class=\"keyword\">self</span>.bounds);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//创建属性字符串</span></div><div class=\"line\">    <span class=\"built_in\">NSMutableAttributedString</span> * attStr = [[<span class=\"built_in\">NSMutableAttributedString</span> alloc] initWithString:str4];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//颜色</span></div><div class=\"line\">    [attStr addAttribute:(__bridge <span class=\"built_in\">NSString</span> *)kCTForegroundColorAttributeName value:(__bridge <span class=\"keyword\">id</span>)[<span class=\"built_in\">UIColor</span> redColor].CGColor range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">5</span>, <span class=\"number\">10</span>)];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//字体</span></div><div class=\"line\">    <span class=\"built_in\">UIFont</span> * font = [<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">25</span>];</div><div class=\"line\">    <span class=\"built_in\">CTFontRef</span> fontRef = <span class=\"built_in\">CTFontCreateWithName</span>((__bridge <span class=\"built_in\">CFStringRef</span>)font.fontName, <span class=\"number\">25</span>, <span class=\"literal\">NULL</span>);</div><div class=\"line\">    [attStr addAttribute:(__bridge <span class=\"built_in\">NSString</span> *)kCTFontAttributeName value:(__bridge <span class=\"keyword\">id</span>)fontRef range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">20</span>, <span class=\"number\">10</span>)];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//空心字</span></div><div class=\"line\">    [attStr addAttribute:(__bridge <span class=\"built_in\">NSString</span> *)kCTStrokeWidthAttributeName value:@(<span class=\"number\">3</span>) range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">36</span>, <span class=\"number\">5</span>)];</div><div class=\"line\">    [attStr addAttribute:(__bridge <span class=\"built_in\">NSString</span> *)kCTStrokeColorAttributeName value:(__bridge <span class=\"keyword\">id</span>)[<span class=\"built_in\">UIColor</span> blueColor].CGColor range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">37</span>, <span class=\"number\">10</span>)];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//下划线</span></div><div class=\"line\">    [attStr addAttribute:(__bridge <span class=\"built_in\">NSString</span> *)kCTUnderlineStyleAttributeName value:@(kCTUnderlineStyleSingle | kCTUnderlinePatternDot) range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">45</span>, <span class=\"number\">15</span>)];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">CTFramesetterRef</span> framesetter = <span class=\"built_in\">CTFramesetterCreateWithAttributedString</span>((<span class=\"built_in\">CFAttributedStringRef</span>)attStr);</div><div class=\"line\">    <span class=\"built_in\">CTFrameRef</span> frame = <span class=\"built_in\">CTFramesetterCreateFrame</span>(framesetter, <span class=\"built_in\">CFRangeMake</span>(<span class=\"number\">0</span>, attStr.length), path, <span class=\"literal\">NULL</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//绘制内容</span></div><div class=\"line\">    <span class=\"built_in\">CTFrameDraw</span>(frame, context);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">CFRelease</span>(fontRef);</div><div class=\"line\">    <span class=\"built_in\">CFRelease</span>(frame);</div><div class=\"line\">    <span class=\"built_in\">CFRelease</span>(path);</div><div class=\"line\">    <span class=\"built_in\">CFRelease</span>(framesetter);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>第二个示例展示了一个带表情符号的文本，效果图如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20150404002937477\" alt=\"这里写图片描述\"></p>\n<p>先介绍一下CoreText实现表情混排的原理，在简介中介绍过，一个CTLine代表一行，而一个CTLine又由多个CTRun组成，这里实现表情混排的原理其实就是把CTLine中的某一个CTRun替换成空白字符，然后再根据这个CTRun的具体位置，把图片绘制到这个位置上，下面是具体代码：<br><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"ImageDisplayView.h\"</span></span></div><div class=\"line\"><span class=\"keyword\">@import</span> CoreText;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSString</span> * str5 = <span class=\"string\">@\"asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ImageDisplayView</span> ()</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSAttributedString</span> * attStr;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//回调方法，返回要替换的CTRun的下边缘距离本行文字下边缘的高度</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">CGFloat</span> descentCallback(<span class=\"keyword\">void</span> *ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//回调方法，返回要替换的CTRun的上边缘距离本行文字上边缘的高度</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">CGFloat</span> ascentCallback(<span class=\"keyword\">void</span> *ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">30</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//回调方法，返回要替换的CTRun的宽</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">CGFloat</span> widthCallback(<span class=\"keyword\">void</span> *ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">30</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ImageDisplayView</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">CTRunDelegateRef</span> _delegate;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithFrame:(<span class=\"built_in\">CGRect</span>)frame</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> initWithFrame:frame];</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSString</span> * name = <span class=\"string\">@\"010\"</span>;</div><div class=\"line\">        <span class=\"keyword\">unichar</span> objectReplacementChar           = <span class=\"number\">0xFFFC</span>;<span class=\"comment\">//占位字符</span></div><div class=\"line\">        <span class=\"built_in\">NSString</span> *objectReplacementString       = [<span class=\"built_in\">NSString</span> stringWithCharacters:&amp;objectReplacementChar length:<span class=\"number\">1</span>];</div><div class=\"line\">        <span class=\"built_in\">NSMutableAttributedString</span> *attachText   = [[<span class=\"built_in\">NSMutableAttributedString</span> alloc]initWithString:objectReplacementString];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//创建CTRun代理回调</span></div><div class=\"line\">        <span class=\"built_in\">CTRunDelegateCallbacks</span> callbacks;</div><div class=\"line\">        callbacks.version       = kCTRunDelegateVersion1;</div><div class=\"line\">        callbacks.getAscent     = ascentCallback;</div><div class=\"line\">        callbacks.getDescent    = descentCallback;</div><div class=\"line\">        callbacks.getWidth      = widthCallback;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//给属性字符串添加代理回调</span></div><div class=\"line\">        <span class=\"built_in\">CTRunDelegateRef</span> delegate = <span class=\"built_in\">CTRunDelegateCreate</span>(&amp;callbacks, (<span class=\"keyword\">void</span> *)name);</div><div class=\"line\">        <span class=\"built_in\">NSDictionary</span> *attr = [<span class=\"built_in\">NSDictionary</span> dictionaryWithObjectsAndKeys:(__bridge <span class=\"keyword\">id</span>)delegate,kCTRunDelegateAttributeName, <span class=\"literal\">nil</span>];</div><div class=\"line\">        [attachText setAttributes:attr range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>)];</div><div class=\"line\">        <span class=\"keyword\">self</span>.attStr = attachText;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)drawRect:(<span class=\"built_in\">CGRect</span>)rect &#123;</div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">super</span> drawRect:rect];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">UIGraphicsGetCurrentContext</span>();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//变换坐标</span></div><div class=\"line\">    <span class=\"built_in\">CGContextSetTextMatrix</span>(context, <span class=\"built_in\">CGAffineTransformIdentity</span>);</div><div class=\"line\">    <span class=\"built_in\">CGContextTranslateCTM</span>(context, <span class=\"number\">0</span>, <span class=\"keyword\">self</span>.bounds.size.height);</div><div class=\"line\">    <span class=\"built_in\">CGContextScaleCTM</span>(context, <span class=\"number\">1.0</span>, <span class=\"number\">-1.0</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//设置文本绘制的路径</span></div><div class=\"line\">    <span class=\"built_in\">CGMutablePathRef</span> path = <span class=\"built_in\">CGPathCreateMutable</span>();</div><div class=\"line\">    <span class=\"built_in\">CGPathAddRect</span>(path, <span class=\"literal\">NULL</span>, <span class=\"keyword\">self</span>.bounds);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSMutableAttributedString</span> * attStr = [[<span class=\"built_in\">NSMutableAttributedString</span> alloc] initWithString:str5];</div><div class=\"line\">    [attStr insertAttributedString:<span class=\"keyword\">self</span>.attStr atIndex:<span class=\"number\">50</span>];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">CTFramesetterRef</span> framesetter = <span class=\"built_in\">CTFramesetterCreateWithAttributedString</span>((<span class=\"built_in\">CFAttributedStringRef</span>)attStr);</div><div class=\"line\">    <span class=\"built_in\">CTFrameRef</span> frame = <span class=\"built_in\">CTFramesetterCreateFrame</span>(framesetter, <span class=\"built_in\">CFRangeMake</span>(<span class=\"number\">0</span>, attStr.length), path, <span class=\"literal\">NULL</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//计算要替换的CTRun的具体位置</span></div><div class=\"line\">    <span class=\"built_in\">NSArray</span> * lines = (<span class=\"built_in\">NSArray</span> *)<span class=\"built_in\">CTFrameGetLines</span>(frame);</div><div class=\"line\">    <span class=\"built_in\">NSUInteger</span> lineCount = lines.count;</div><div class=\"line\">    <span class=\"built_in\">CGPoint</span> lineOrigins[lineCount];</div><div class=\"line\">    <span class=\"built_in\">CTFrameGetLineOrigins</span>(frame, <span class=\"built_in\">CFRangeMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>), lineOrigins);</div><div class=\"line\">    <span class=\"comment\">//循环遍历每一个CTLine中的每一个CTRun，找到要替换的那个CTRun，并且计算它的位置</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; lineCount; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">CTLineRef</span> line = (__bridge <span class=\"built_in\">CTLineRef</span>)lines[i];</div><div class=\"line\">        <span class=\"built_in\">CFArrayRef</span> runs = <span class=\"built_in\">CTLineGetGlyphRuns</span>(line);</div><div class=\"line\">        <span class=\"built_in\">CFIndex</span> runCount = <span class=\"built_in\">CFArrayGetCount</span>(runs);</div><div class=\"line\">        <span class=\"built_in\">CGPoint</span> lineOrigin = lineOrigins[i];</div><div class=\"line\">        <span class=\"built_in\">CGFloat</span> lineAscent;</div><div class=\"line\">        <span class=\"built_in\">CGFloat</span> lineDescent;</div><div class=\"line\">        <span class=\"built_in\">CTLineGetTypographicBounds</span>(line, &amp;lineAscent, &amp;lineDescent, <span class=\"literal\">NULL</span>);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">CFIndex</span> k = <span class=\"number\">0</span>; k &lt; runCount; k++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">CTRunRef</span> run = <span class=\"built_in\">CFArrayGetValueAtIndex</span>(runs, k);</div><div class=\"line\">            <span class=\"built_in\">NSDictionary</span> *runAttributes = (<span class=\"built_in\">NSDictionary</span> *)<span class=\"built_in\">CTRunGetAttributes</span>(run);</div><div class=\"line\">            <span class=\"built_in\">CTRunDelegateRef</span> delegate = (__bridge <span class=\"built_in\">CTRunDelegateRef</span>)[runAttributes valueForKey:(<span class=\"keyword\">id</span>)kCTRunDelegateAttributeName];</div><div class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"literal\">nil</span> == delegate)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"built_in\">CGFloat</span> xOffset = <span class=\"built_in\">CTLineGetOffsetForStringIndex</span>(line, <span class=\"built_in\">CTRunGetStringRange</span>(run).location, <span class=\"literal\">nil</span>);</div><div class=\"line\">            <span class=\"built_in\">CGRect</span> rect = <span class=\"built_in\">CGRectMake</span>(lineOrigin.x + xOffset, lineOrigin.y - lineDescent, <span class=\"number\">30</span>, <span class=\"number\">30</span>);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//绘制图片</span></div><div class=\"line\">            <span class=\"built_in\">CGContextDrawImage</span>(context, rect, [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"010\"</span>].CGImage);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">CTFrameDraw</span>(frame, context);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">CFRelease</span>(frame);</div><div class=\"line\">    <span class=\"built_in\">CFRelease</span>(path);</div><div class=\"line\">    <span class=\"built_in\">CFRelease</span>(framesetter);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>下面总结一下CoreText的优缺点：</p>\n<ul>\n<li>优点：功能强大，支持iOS3.2以后的所有系统</li>\n<li>缺点：纯C的接口，使用复杂，需要自己管理内存</li>\n</ul>\n<p>CoreText更加详细的介绍推荐大家可以看看唐巧大神的《iOS开发进阶》第十七章的内容。</p>\n"},{"layout":"post","title":"iOS中的富文本技术(1)TextKit简介","_content":"\n##前言\n 最近项目中用到了图文混排，所以就研究了一下iOS中的富文本，打算把研究的结果分享一下，也是对自己学习的一个总结。初步打算写两篇，这是第一篇，主要介绍iOS7新出的TextKit的简单实用。\n\n##简介\nTextKit是iOS7新推出的文字排版技术，使用TextKit可以很方便的实现富文本、表情混排和图文混排等效果。TextKit中的几个关键的类：\n* `NSAttributeString`和`NSMutableAttributeString`：属性字符串和可变属性字符串，这个TextKit中最基础的类，文字中的所有富文本属性都是通过属性字符串来表现出来的\n* `NSTextAttachment`：字符串的附件，将图片，可以将图片等内容当做一个附件插入到属性字符串中，可以实现表情混排，链接等效果\n\n##示例\n废话不多说，直接上代码，先看一下效果图：\n![这里写图片描述](http://img.blog.csdn.net/20150402235843040)\n\n```objectivec\n#import \"TextKitEmojiTextVC.h\"\n\nNSString * str = @\"asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费\";\n\n@interface TextKitEmojiTextVC ()<UITextViewDelegate>\n\n@property (nonatomic, strong) UITextView * textView;\n\n@end\n\n@implementation TextKitEmojiTextVC\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    self.title = @\"普通文字排版&表情混排\";\n\n\n    //初始化textView\n    self.edgesForExtendedLayout = UIRectEdgeNone;\n    self.textView = [[UITextView alloc] initWithFrame:CGRectMake(20, 20, [UIScreen mainScreen].bounds.size.width - 40, [UIScreen mainScreen].bounds.size.height - 40 - 44 - 20)];\n    self.textView.backgroundColor = [UIColor cyanColor];\n    self.textView.text = str;\n    self.textView.font = [UIFont systemFontOfSize:15];\n    self.textView.editable = NO;\n    self.textView.delegate = self;\n    [self.view addSubview:self.textView];\n\n    //设置常规属性\n    [self setupNormalAttribute];\n\n    //链接和表情\n    [self setupEmojiAndLink];\n\n}\n\n/**\n *  向文本中添加表情，链接等\n */\n- (void)setupEmojiAndLink\n{\n\n    NSMutableAttributedString * mutStr = [self.textView.attributedText mutableCopy];\n\n    //添加表情\n    UIImage * image1 = [UIImage imageNamed:@\"010\"];\n    NSTextAttachment * attachment1 = [[NSTextAttachment alloc] init];\n    attachment1.bounds = CGRectMake(0, 0, 30, 30);\n    attachment1.image = image1;\n    NSAttributedString * attachStr1 = [NSAttributedString attributedStringWithAttachment:attachment1];\n    [mutStr insertAttributedString:attachStr1 atIndex:50];\n\n    //添加表情\n    UIImage * image2 = [UIImage imageNamed:@\"011\"];\n    NSTextAttachment * attachment2 = [[NSTextAttachment alloc] init];\n    attachment2.bounds = CGRectMake(0, 0, 15, 15);\n    attachment2.image = image2;\n    NSAttributedString * attachStr2 = [NSAttributedString attributedStringWithAttachment:attachment2];\n    [mutStr insertAttributedString:attachStr2 atIndex:100];\n\n    //添加链接\n    NSURL * url = [NSURL URLWithString:@\"http://www.baidu.com\"];\n    [mutStr addAttribute:NSLinkAttributeName value:url range:NSMakeRange(70, 10)];\n\n    self.textView.attributedText = [mutStr copy];\n}\n\n/**\n *  设置常规属性\n */\n- (void)setupNormalAttribute\n{\n    NSMutableAttributedString * mutStr = [self.textView.attributedText mutableCopy];\n\n    //颜色\n    [mutStr addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(10, 10)];\n    //字体\n    [mutStr addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:25] range:NSMakeRange(20, 5)];\n    //下划线\n    [mutStr addAttribute:NSUnderlineStyleAttributeName value:@(NSUnderlineStyleSingle | NSUnderlinePatternDot) range:NSMakeRange(32, 8)];\n    //空心字\n    [mutStr addAttribute:NSStrokeWidthAttributeName value:@(2) range:NSMakeRange(42, 5)];\n    self.textView.attributedText = [mutStr copy];\n}\n\n/**\n *  点击图片触发代理事件\n */\n- (BOOL)textView:(UITextView *)textView shouldInteractWithTextAttachment:(NSTextAttachment *)textAttachment inRange:(NSRange)characterRange\n{\n    NSLog(@\"%@\", textAttachment);\n    return NO;\n}\n\n/**\n *  点击链接，触发代理事件\n */\n- (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange\n{\n    [[UIApplication sharedApplication] openURL:URL];\n    return YES;\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n@end\n```\n\n图片环绕效果图：\n![这里写图片描述](http://img.blog.csdn.net/20150403000308303)\n\n```objectivec\n#import \"TextKitImageTextVC.h\"\n\nNSString * str1 = @\"asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费\";\n\n@interface TextKitImageTextVC ()\n\n@property (nonatomic, strong) UITextView * textView;\n\n@end\n\n@implementation TextKitImageTextVC\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view.\n\n    self.title = @\"文字环绕\";\n\n    //初始化textLabel\n    self.edgesForExtendedLayout = UIRectEdgeNone;\n    self.textView = [[UITextView alloc] initWithFrame:CGRectMake(20, 20, [UIScreen mainScreen].bounds.size.width - 40, [UIScreen mainScreen].bounds.size.height - 40 - 44 - 20)];\n    self.textView.backgroundColor = [UIColor cyanColor];\n    self.textView.text = str1;\n    self.textView.font = [UIFont systemFontOfSize:15];\n    self.textView.editable = NO;\n    [self.view addSubview:self.textView];\n\n    //图文混排，设置图片的位置\n    UIImageView * imageView = [[UIImageView alloc] initWithFrame:CGRectMake(120, 120, 100, 110)];\n    imageView.image = [UIImage imageNamed:@\"011\"];\n    imageView.backgroundColor = [UIColor redColor];\n    [self.view addSubview:imageView];\n    CGRect rect = CGRectMake(100, 100, 100, 100);\n\n    //设置环绕的路径\n    UIBezierPath * path = [UIBezierPath bezierPathWithRect:rect];\n    self.textView.textContainer.exclusionPaths = @[path];\n\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n@end\n```\n\n##总结\nTextKit极大的简化了文字排版的复杂度，但是它的缺点也很明显，就是只能在iOS7之后的系统中使用，很多需要兼容iOS7以前的系统的应用都没法使用。不过随着技术的发展，相信它的应用也会越来越广泛。\n","source":"_posts/2015-10-04-iOS中的富文本技术(1)TextKit简介.md","raw":"---\nlayout: post\ntitle: \"iOS中的富文本技术(1)TextKit简介\"\ncategories: \"iOS开发\"\n---\n\n##前言\n 最近项目中用到了图文混排，所以就研究了一下iOS中的富文本，打算把研究的结果分享一下，也是对自己学习的一个总结。初步打算写两篇，这是第一篇，主要介绍iOS7新出的TextKit的简单实用。\n\n##简介\nTextKit是iOS7新推出的文字排版技术，使用TextKit可以很方便的实现富文本、表情混排和图文混排等效果。TextKit中的几个关键的类：\n* `NSAttributeString`和`NSMutableAttributeString`：属性字符串和可变属性字符串，这个TextKit中最基础的类，文字中的所有富文本属性都是通过属性字符串来表现出来的\n* `NSTextAttachment`：字符串的附件，将图片，可以将图片等内容当做一个附件插入到属性字符串中，可以实现表情混排，链接等效果\n\n##示例\n废话不多说，直接上代码，先看一下效果图：\n![这里写图片描述](http://img.blog.csdn.net/20150402235843040)\n\n```objectivec\n#import \"TextKitEmojiTextVC.h\"\n\nNSString * str = @\"asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费\";\n\n@interface TextKitEmojiTextVC ()<UITextViewDelegate>\n\n@property (nonatomic, strong) UITextView * textView;\n\n@end\n\n@implementation TextKitEmojiTextVC\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    self.title = @\"普通文字排版&表情混排\";\n\n\n    //初始化textView\n    self.edgesForExtendedLayout = UIRectEdgeNone;\n    self.textView = [[UITextView alloc] initWithFrame:CGRectMake(20, 20, [UIScreen mainScreen].bounds.size.width - 40, [UIScreen mainScreen].bounds.size.height - 40 - 44 - 20)];\n    self.textView.backgroundColor = [UIColor cyanColor];\n    self.textView.text = str;\n    self.textView.font = [UIFont systemFontOfSize:15];\n    self.textView.editable = NO;\n    self.textView.delegate = self;\n    [self.view addSubview:self.textView];\n\n    //设置常规属性\n    [self setupNormalAttribute];\n\n    //链接和表情\n    [self setupEmojiAndLink];\n\n}\n\n/**\n *  向文本中添加表情，链接等\n */\n- (void)setupEmojiAndLink\n{\n\n    NSMutableAttributedString * mutStr = [self.textView.attributedText mutableCopy];\n\n    //添加表情\n    UIImage * image1 = [UIImage imageNamed:@\"010\"];\n    NSTextAttachment * attachment1 = [[NSTextAttachment alloc] init];\n    attachment1.bounds = CGRectMake(0, 0, 30, 30);\n    attachment1.image = image1;\n    NSAttributedString * attachStr1 = [NSAttributedString attributedStringWithAttachment:attachment1];\n    [mutStr insertAttributedString:attachStr1 atIndex:50];\n\n    //添加表情\n    UIImage * image2 = [UIImage imageNamed:@\"011\"];\n    NSTextAttachment * attachment2 = [[NSTextAttachment alloc] init];\n    attachment2.bounds = CGRectMake(0, 0, 15, 15);\n    attachment2.image = image2;\n    NSAttributedString * attachStr2 = [NSAttributedString attributedStringWithAttachment:attachment2];\n    [mutStr insertAttributedString:attachStr2 atIndex:100];\n\n    //添加链接\n    NSURL * url = [NSURL URLWithString:@\"http://www.baidu.com\"];\n    [mutStr addAttribute:NSLinkAttributeName value:url range:NSMakeRange(70, 10)];\n\n    self.textView.attributedText = [mutStr copy];\n}\n\n/**\n *  设置常规属性\n */\n- (void)setupNormalAttribute\n{\n    NSMutableAttributedString * mutStr = [self.textView.attributedText mutableCopy];\n\n    //颜色\n    [mutStr addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(10, 10)];\n    //字体\n    [mutStr addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:25] range:NSMakeRange(20, 5)];\n    //下划线\n    [mutStr addAttribute:NSUnderlineStyleAttributeName value:@(NSUnderlineStyleSingle | NSUnderlinePatternDot) range:NSMakeRange(32, 8)];\n    //空心字\n    [mutStr addAttribute:NSStrokeWidthAttributeName value:@(2) range:NSMakeRange(42, 5)];\n    self.textView.attributedText = [mutStr copy];\n}\n\n/**\n *  点击图片触发代理事件\n */\n- (BOOL)textView:(UITextView *)textView shouldInteractWithTextAttachment:(NSTextAttachment *)textAttachment inRange:(NSRange)characterRange\n{\n    NSLog(@\"%@\", textAttachment);\n    return NO;\n}\n\n/**\n *  点击链接，触发代理事件\n */\n- (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange\n{\n    [[UIApplication sharedApplication] openURL:URL];\n    return YES;\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n@end\n```\n\n图片环绕效果图：\n![这里写图片描述](http://img.blog.csdn.net/20150403000308303)\n\n```objectivec\n#import \"TextKitImageTextVC.h\"\n\nNSString * str1 = @\"asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费\";\n\n@interface TextKitImageTextVC ()\n\n@property (nonatomic, strong) UITextView * textView;\n\n@end\n\n@implementation TextKitImageTextVC\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view.\n\n    self.title = @\"文字环绕\";\n\n    //初始化textLabel\n    self.edgesForExtendedLayout = UIRectEdgeNone;\n    self.textView = [[UITextView alloc] initWithFrame:CGRectMake(20, 20, [UIScreen mainScreen].bounds.size.width - 40, [UIScreen mainScreen].bounds.size.height - 40 - 44 - 20)];\n    self.textView.backgroundColor = [UIColor cyanColor];\n    self.textView.text = str1;\n    self.textView.font = [UIFont systemFontOfSize:15];\n    self.textView.editable = NO;\n    [self.view addSubview:self.textView];\n\n    //图文混排，设置图片的位置\n    UIImageView * imageView = [[UIImageView alloc] initWithFrame:CGRectMake(120, 120, 100, 110)];\n    imageView.image = [UIImage imageNamed:@\"011\"];\n    imageView.backgroundColor = [UIColor redColor];\n    [self.view addSubview:imageView];\n    CGRect rect = CGRectMake(100, 100, 100, 100);\n\n    //设置环绕的路径\n    UIBezierPath * path = [UIBezierPath bezierPathWithRect:rect];\n    self.textView.textContainer.exclusionPaths = @[path];\n\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n@end\n```\n\n##总结\nTextKit极大的简化了文字排版的复杂度，但是它的缺点也很明显，就是只能在iOS7之后的系统中使用，很多需要兼容iOS7以前的系统的应用都没法使用。不过随着技术的发展，相信它的应用也会越来越广泛。\n","slug":"iOS中的富文本技术(1)TextKit简介","published":1,"date":"2015-10-03T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oaa4000azrm0byz3ofdd","content":"<p>##前言<br> 最近项目中用到了图文混排，所以就研究了一下iOS中的富文本，打算把研究的结果分享一下，也是对自己学习的一个总结。初步打算写两篇，这是第一篇，主要介绍iOS7新出的TextKit的简单实用。</p>\n<p>##简介<br>TextKit是iOS7新推出的文字排版技术，使用TextKit可以很方便的实现富文本、表情混排和图文混排等效果。TextKit中的几个关键的类：</p>\n<ul>\n<li><code>NSAttributeString</code>和<code>NSMutableAttributeString</code>：属性字符串和可变属性字符串，这个TextKit中最基础的类，文字中的所有富文本属性都是通过属性字符串来表现出来的</li>\n<li><code>NSTextAttachment</code>：字符串的附件，将图片，可以将图片等内容当做一个附件插入到属性字符串中，可以实现表情混排，链接等效果</li>\n</ul>\n<p>##示例<br>废话不多说，直接上代码，先看一下效果图：<br><img src=\"http://img.blog.csdn.net/20150402235843040\" alt=\"这里写图片描述\"></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"TextKitEmojiTextVC.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSString</span> * str = <span class=\"string\">@\"asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">TextKitEmojiTextVC</span> ()&lt;<span class=\"title\">UITextViewDelegate</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UITextView</span> * textView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">TextKitEmojiTextVC</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.title = <span class=\"string\">@\"普通文字排版&amp;表情混排\"</span>;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//初始化textView</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.edgesForExtendedLayout = <span class=\"built_in\">UIRectEdgeNone</span>;</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView = [[<span class=\"built_in\">UITextView</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">20</span>, <span class=\"number\">20</span>, [<span class=\"built_in\">UIScreen</span> mainScreen].bounds.size.width - <span class=\"number\">40</span>, [<span class=\"built_in\">UIScreen</span> mainScreen].bounds.size.height - <span class=\"number\">40</span> - <span class=\"number\">44</span> - <span class=\"number\">20</span>)];</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.backgroundColor = [<span class=\"built_in\">UIColor</span> cyanColor];</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.text = str;</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.font = [<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">15</span>];</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.editable = <span class=\"literal\">NO</span>;</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.delegate = <span class=\"keyword\">self</span>;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:<span class=\"keyword\">self</span>.textView];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//设置常规属性</span></div><div class=\"line\">    [<span class=\"keyword\">self</span> setupNormalAttribute];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//链接和表情</span></div><div class=\"line\">    [<span class=\"keyword\">self</span> setupEmojiAndLink];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> *  向文本中添加表情，链接等</div><div class=\"line\"> */</div><div class=\"line\">- (<span class=\"keyword\">void</span>)setupEmojiAndLink</div><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSMutableAttributedString</span> * mutStr = [<span class=\"keyword\">self</span>.textView.attributedText mutableCopy];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//添加表情</span></div><div class=\"line\">    <span class=\"built_in\">UIImage</span> * image1 = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"010\"</span>];</div><div class=\"line\">    <span class=\"built_in\">NSTextAttachment</span> * attachment1 = [[<span class=\"built_in\">NSTextAttachment</span> alloc] init];</div><div class=\"line\">    attachment1.bounds = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">30</span>, <span class=\"number\">30</span>);</div><div class=\"line\">    attachment1.image = image1;</div><div class=\"line\">    <span class=\"built_in\">NSAttributedString</span> * attachStr1 = [<span class=\"built_in\">NSAttributedString</span> attributedStringWithAttachment:attachment1];</div><div class=\"line\">    [mutStr insertAttributedString:attachStr1 atIndex:<span class=\"number\">50</span>];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//添加表情</span></div><div class=\"line\">    <span class=\"built_in\">UIImage</span> * image2 = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"011\"</span>];</div><div class=\"line\">    <span class=\"built_in\">NSTextAttachment</span> * attachment2 = [[<span class=\"built_in\">NSTextAttachment</span> alloc] init];</div><div class=\"line\">    attachment2.bounds = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">15</span>, <span class=\"number\">15</span>);</div><div class=\"line\">    attachment2.image = image2;</div><div class=\"line\">    <span class=\"built_in\">NSAttributedString</span> * attachStr2 = [<span class=\"built_in\">NSAttributedString</span> attributedStringWithAttachment:attachment2];</div><div class=\"line\">    [mutStr insertAttributedString:attachStr2 atIndex:<span class=\"number\">100</span>];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//添加链接</span></div><div class=\"line\">    <span class=\"built_in\">NSURL</span> * url = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://www.baidu.com\"</span>];</div><div class=\"line\">    [mutStr addAttribute:<span class=\"built_in\">NSLinkAttributeName</span> value:url range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">70</span>, <span class=\"number\">10</span>)];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.attributedText = [mutStr <span class=\"keyword\">copy</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> *  设置常规属性</div><div class=\"line\"> */</div><div class=\"line\">- (<span class=\"keyword\">void</span>)setupNormalAttribute</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSMutableAttributedString</span> * mutStr = [<span class=\"keyword\">self</span>.textView.attributedText mutableCopy];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//颜色</span></div><div class=\"line\">    [mutStr addAttribute:<span class=\"built_in\">NSForegroundColorAttributeName</span> value:[<span class=\"built_in\">UIColor</span> redColor] range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">10</span>, <span class=\"number\">10</span>)];</div><div class=\"line\">    <span class=\"comment\">//字体</span></div><div class=\"line\">    [mutStr addAttribute:<span class=\"built_in\">NSFontAttributeName</span> value:[<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">25</span>] range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">20</span>, <span class=\"number\">5</span>)];</div><div class=\"line\">    <span class=\"comment\">//下划线</span></div><div class=\"line\">    [mutStr addAttribute:<span class=\"built_in\">NSUnderlineStyleAttributeName</span> value:@(<span class=\"built_in\">NSUnderlineStyleSingle</span> | <span class=\"built_in\">NSUnderlinePatternDot</span>) range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">32</span>, <span class=\"number\">8</span>)];</div><div class=\"line\">    <span class=\"comment\">//空心字</span></div><div class=\"line\">    [mutStr addAttribute:<span class=\"built_in\">NSStrokeWidthAttributeName</span> value:@(<span class=\"number\">2</span>) range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">42</span>, <span class=\"number\">5</span>)];</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.attributedText = [mutStr <span class=\"keyword\">copy</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> *  点击图片触发代理事件</div><div class=\"line\"> */</div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)textView:(<span class=\"built_in\">UITextView</span> *)textView shouldInteractWithTextAttachment:(<span class=\"built_in\">NSTextAttachment</span> *)textAttachment inRange:(<span class=\"built_in\">NSRange</span>)characterRange</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, textAttachment);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> *  点击链接，触发代理事件</div><div class=\"line\"> */</div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)textView:(<span class=\"built_in\">UITextView</span> *)textView shouldInteractWithURL:(<span class=\"built_in\">NSURL</span> *)URL inRange:(<span class=\"built_in\">NSRange</span>)characterRange</div><div class=\"line\">&#123;</div><div class=\"line\">    [[<span class=\"built_in\">UIApplication</span> sharedApplication] openURL:URL];</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)didReceiveMemoryWarning &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> didReceiveMemoryWarning];</div><div class=\"line\">    <span class=\"comment\">// Dispose of any resources that can be recreated.</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>图片环绕效果图：<br><img src=\"http://img.blog.csdn.net/20150403000308303\" alt=\"这里写图片描述\"></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"TextKitImageTextVC.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSString</span> * str1 = <span class=\"string\">@\"asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">TextKitImageTextVC</span> ()</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UITextView</span> * textView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">TextKitImageTextVC</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"comment\">// Do any additional setup after loading the view.</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.title = <span class=\"string\">@\"文字环绕\"</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//初始化textLabel</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.edgesForExtendedLayout = <span class=\"built_in\">UIRectEdgeNone</span>;</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView = [[<span class=\"built_in\">UITextView</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">20</span>, <span class=\"number\">20</span>, [<span class=\"built_in\">UIScreen</span> mainScreen].bounds.size.width - <span class=\"number\">40</span>, [<span class=\"built_in\">UIScreen</span> mainScreen].bounds.size.height - <span class=\"number\">40</span> - <span class=\"number\">44</span> - <span class=\"number\">20</span>)];</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.backgroundColor = [<span class=\"built_in\">UIColor</span> cyanColor];</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.text = str1;</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.font = [<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">15</span>];</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.editable = <span class=\"literal\">NO</span>;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:<span class=\"keyword\">self</span>.textView];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//图文混排，设置图片的位置</span></div><div class=\"line\">    <span class=\"built_in\">UIImageView</span> * imageView = [[<span class=\"built_in\">UIImageView</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">120</span>, <span class=\"number\">120</span>, <span class=\"number\">100</span>, <span class=\"number\">110</span>)];</div><div class=\"line\">    imageView.image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"011\"</span>];</div><div class=\"line\">    imageView.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:imageView];</div><div class=\"line\">    <span class=\"built_in\">CGRect</span> rect = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//设置环绕的路径</span></div><div class=\"line\">    <span class=\"built_in\">UIBezierPath</span> * path = [<span class=\"built_in\">UIBezierPath</span> bezierPathWithRect:rect];</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.textContainer.exclusionPaths = @[path];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)didReceiveMemoryWarning &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> didReceiveMemoryWarning];</div><div class=\"line\">    <span class=\"comment\">// Dispose of any resources that can be recreated.</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>##总结<br>TextKit极大的简化了文字排版的复杂度，但是它的缺点也很明显，就是只能在iOS7之后的系统中使用，很多需要兼容iOS7以前的系统的应用都没法使用。不过随着技术的发展，相信它的应用也会越来越广泛。</p>\n","excerpt":"","more":"<p>##前言<br> 最近项目中用到了图文混排，所以就研究了一下iOS中的富文本，打算把研究的结果分享一下，也是对自己学习的一个总结。初步打算写两篇，这是第一篇，主要介绍iOS7新出的TextKit的简单实用。</p>\n<p>##简介<br>TextKit是iOS7新推出的文字排版技术，使用TextKit可以很方便的实现富文本、表情混排和图文混排等效果。TextKit中的几个关键的类：</p>\n<ul>\n<li><code>NSAttributeString</code>和<code>NSMutableAttributeString</code>：属性字符串和可变属性字符串，这个TextKit中最基础的类，文字中的所有富文本属性都是通过属性字符串来表现出来的</li>\n<li><code>NSTextAttachment</code>：字符串的附件，将图片，可以将图片等内容当做一个附件插入到属性字符串中，可以实现表情混排，链接等效果</li>\n</ul>\n<p>##示例<br>废话不多说，直接上代码，先看一下效果图：<br><img src=\"http://img.blog.csdn.net/20150402235843040\" alt=\"这里写图片描述\"></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"TextKitEmojiTextVC.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSString</span> * str = <span class=\"string\">@\"asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">TextKitEmojiTextVC</span> ()&lt;<span class=\"title\">UITextViewDelegate</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UITextView</span> * textView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">TextKitEmojiTextVC</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.title = <span class=\"string\">@\"普通文字排版&amp;表情混排\"</span>;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//初始化textView</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.edgesForExtendedLayout = <span class=\"built_in\">UIRectEdgeNone</span>;</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView = [[<span class=\"built_in\">UITextView</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">20</span>, <span class=\"number\">20</span>, [<span class=\"built_in\">UIScreen</span> mainScreen].bounds.size.width - <span class=\"number\">40</span>, [<span class=\"built_in\">UIScreen</span> mainScreen].bounds.size.height - <span class=\"number\">40</span> - <span class=\"number\">44</span> - <span class=\"number\">20</span>)];</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.backgroundColor = [<span class=\"built_in\">UIColor</span> cyanColor];</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.text = str;</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.font = [<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">15</span>];</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.editable = <span class=\"literal\">NO</span>;</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.delegate = <span class=\"keyword\">self</span>;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:<span class=\"keyword\">self</span>.textView];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//设置常规属性</span></div><div class=\"line\">    [<span class=\"keyword\">self</span> setupNormalAttribute];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//链接和表情</span></div><div class=\"line\">    [<span class=\"keyword\">self</span> setupEmojiAndLink];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> *  向文本中添加表情，链接等</div><div class=\"line\"> */</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setupEmojiAndLink</div><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSMutableAttributedString</span> * mutStr = [<span class=\"keyword\">self</span>.textView.attributedText mutableCopy];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//添加表情</span></div><div class=\"line\">    <span class=\"built_in\">UIImage</span> * image1 = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"010\"</span>];</div><div class=\"line\">    <span class=\"built_in\">NSTextAttachment</span> * attachment1 = [[<span class=\"built_in\">NSTextAttachment</span> alloc] init];</div><div class=\"line\">    attachment1.bounds = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">30</span>, <span class=\"number\">30</span>);</div><div class=\"line\">    attachment1.image = image1;</div><div class=\"line\">    <span class=\"built_in\">NSAttributedString</span> * attachStr1 = [<span class=\"built_in\">NSAttributedString</span> attributedStringWithAttachment:attachment1];</div><div class=\"line\">    [mutStr insertAttributedString:attachStr1 atIndex:<span class=\"number\">50</span>];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//添加表情</span></div><div class=\"line\">    <span class=\"built_in\">UIImage</span> * image2 = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"011\"</span>];</div><div class=\"line\">    <span class=\"built_in\">NSTextAttachment</span> * attachment2 = [[<span class=\"built_in\">NSTextAttachment</span> alloc] init];</div><div class=\"line\">    attachment2.bounds = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">15</span>, <span class=\"number\">15</span>);</div><div class=\"line\">    attachment2.image = image2;</div><div class=\"line\">    <span class=\"built_in\">NSAttributedString</span> * attachStr2 = [<span class=\"built_in\">NSAttributedString</span> attributedStringWithAttachment:attachment2];</div><div class=\"line\">    [mutStr insertAttributedString:attachStr2 atIndex:<span class=\"number\">100</span>];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//添加链接</span></div><div class=\"line\">    <span class=\"built_in\">NSURL</span> * url = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://www.baidu.com\"</span>];</div><div class=\"line\">    [mutStr addAttribute:<span class=\"built_in\">NSLinkAttributeName</span> value:url range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">70</span>, <span class=\"number\">10</span>)];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.attributedText = [mutStr <span class=\"keyword\">copy</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> *  设置常规属性</div><div class=\"line\"> */</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setupNormalAttribute</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSMutableAttributedString</span> * mutStr = [<span class=\"keyword\">self</span>.textView.attributedText mutableCopy];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//颜色</span></div><div class=\"line\">    [mutStr addAttribute:<span class=\"built_in\">NSForegroundColorAttributeName</span> value:[<span class=\"built_in\">UIColor</span> redColor] range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">10</span>, <span class=\"number\">10</span>)];</div><div class=\"line\">    <span class=\"comment\">//字体</span></div><div class=\"line\">    [mutStr addAttribute:<span class=\"built_in\">NSFontAttributeName</span> value:[<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">25</span>] range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">20</span>, <span class=\"number\">5</span>)];</div><div class=\"line\">    <span class=\"comment\">//下划线</span></div><div class=\"line\">    [mutStr addAttribute:<span class=\"built_in\">NSUnderlineStyleAttributeName</span> value:@(<span class=\"built_in\">NSUnderlineStyleSingle</span> | <span class=\"built_in\">NSUnderlinePatternDot</span>) range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">32</span>, <span class=\"number\">8</span>)];</div><div class=\"line\">    <span class=\"comment\">//空心字</span></div><div class=\"line\">    [mutStr addAttribute:<span class=\"built_in\">NSStrokeWidthAttributeName</span> value:@(<span class=\"number\">2</span>) range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">42</span>, <span class=\"number\">5</span>)];</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.attributedText = [mutStr <span class=\"keyword\">copy</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> *  点击图片触发代理事件</div><div class=\"line\"> */</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)textView:(<span class=\"built_in\">UITextView</span> *)textView shouldInteractWithTextAttachment:(<span class=\"built_in\">NSTextAttachment</span> *)textAttachment inRange:(<span class=\"built_in\">NSRange</span>)characterRange</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, textAttachment);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> *  点击链接，触发代理事件</div><div class=\"line\"> */</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)textView:(<span class=\"built_in\">UITextView</span> *)textView shouldInteractWithURL:(<span class=\"built_in\">NSURL</span> *)URL inRange:(<span class=\"built_in\">NSRange</span>)characterRange</div><div class=\"line\">&#123;</div><div class=\"line\">    [[<span class=\"built_in\">UIApplication</span> sharedApplication] openURL:URL];</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)didReceiveMemoryWarning &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> didReceiveMemoryWarning];</div><div class=\"line\">    <span class=\"comment\">// Dispose of any resources that can be recreated.</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>图片环绕效果图：<br><img src=\"http://img.blog.csdn.net/20150403000308303\" alt=\"这里写图片描述\"></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"TextKitImageTextVC.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSString</span> * str1 = <span class=\"string\">@\"asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费asfasfa阿斯顿发生大发撒放大离开家撒旦法按时付款就阿里；双方均asfasdfasfdalkjsflakj阿斯顿发生大发撒旦法asdfasdfaasfdaasa撒旦法；拉斯克奖发了奥斯卡奖罚洛杉矶的法律；看见谁发的阿斯利康就发；了数据库等法律按实际开发；阿里就开始放到了；安家费阿里山科技发达了开始将对方拉开始交电费了卡双方的空间啊发送卡飞机阿里开始就放暑假了罚款就是浪费\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">TextKitImageTextVC</span> ()</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UITextView</span> * textView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">TextKitImageTextVC</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"comment\">// Do any additional setup after loading the view.</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.title = <span class=\"string\">@\"文字环绕\"</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//初始化textLabel</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.edgesForExtendedLayout = <span class=\"built_in\">UIRectEdgeNone</span>;</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView = [[<span class=\"built_in\">UITextView</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">20</span>, <span class=\"number\">20</span>, [<span class=\"built_in\">UIScreen</span> mainScreen].bounds.size.width - <span class=\"number\">40</span>, [<span class=\"built_in\">UIScreen</span> mainScreen].bounds.size.height - <span class=\"number\">40</span> - <span class=\"number\">44</span> - <span class=\"number\">20</span>)];</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.backgroundColor = [<span class=\"built_in\">UIColor</span> cyanColor];</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.text = str1;</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.font = [<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">15</span>];</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.editable = <span class=\"literal\">NO</span>;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:<span class=\"keyword\">self</span>.textView];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//图文混排，设置图片的位置</span></div><div class=\"line\">    <span class=\"built_in\">UIImageView</span> * imageView = [[<span class=\"built_in\">UIImageView</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">120</span>, <span class=\"number\">120</span>, <span class=\"number\">100</span>, <span class=\"number\">110</span>)];</div><div class=\"line\">    imageView.image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"011\"</span>];</div><div class=\"line\">    imageView.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:imageView];</div><div class=\"line\">    <span class=\"built_in\">CGRect</span> rect = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//设置环绕的路径</span></div><div class=\"line\">    <span class=\"built_in\">UIBezierPath</span> * path = [<span class=\"built_in\">UIBezierPath</span> bezierPathWithRect:rect];</div><div class=\"line\">    <span class=\"keyword\">self</span>.textView.textContainer.exclusionPaths = @[path];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)didReceiveMemoryWarning &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> didReceiveMemoryWarning];</div><div class=\"line\">    <span class=\"comment\">// Dispose of any resources that can be recreated.</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>##总结<br>TextKit极大的简化了文字排版的复杂度，但是它的缺点也很明显，就是只能在iOS7之后的系统中使用，很多需要兼容iOS7以前的系统的应用都没法使用。不过随着技术的发展，相信它的应用也会越来越广泛。</p>\n"},{"layout":"post","title":"iOS运行时初探 使用运行时机制向Category中添加属性","_content":"\n##前言\n了解OC的都应该知道，在一般情况下，我们是不能向Category中添加属性的，只能添加方法，但有些情况向，我们确实需要向Category中添加属性，而且很多系统的API也有一些在Category添加属性的情况，例如我们属性的`UITableView`的`section`和`row`属性，就是定义在一个名为`NSIndexPath`的分类里的，如下\n\n![这里写图片描述](http://img.blog.csdn.net/20150531230308155)\n\n那这到底是怎么实现的呢？\n\n##iOS运行时机制简介\niOS运行时机制，简单来说，就是苹果给开发这提供的一套在运行时动态创建类、添加属性/方法（不止这些，还有一些其他功能）的API，它是一套纯C语言的API，使用相应的API就可以通过Category给一个原本存在的类添加属性。\n\n##实例\n\n```objectivec\n#import <Foundation/Foundation.h>\n#import <objc/runtime.h>\n\n@interface NSObject (CategoryWithProperty)\n\n/**\n *  要在Category中扩展的属性\n */\n@property (nonatomic, strong) NSObject *property;\n\n@end\n\n@implementation NSObject (CategoryWithProperty)\n\n- (NSObject *)property {\n    return objc_getAssociatedObject(self, @selector(property));\n}\n\n- (void)setProperty:(NSObject *)value {\n    objc_setAssociatedObject(self, @selector(property), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n\n@end\n```\n\n这样就可以在Category中添加属性了。\n","source":"_posts/2015-10-04-iOS运行时初探-使用运行时机制向Category中添加属性.md","raw":"---\nlayout: post\ntitle: \"iOS运行时初探 使用运行时机制向Category中添加属性\"\ncategories: \"iOS开发\"\n---\n\n##前言\n了解OC的都应该知道，在一般情况下，我们是不能向Category中添加属性的，只能添加方法，但有些情况向，我们确实需要向Category中添加属性，而且很多系统的API也有一些在Category添加属性的情况，例如我们属性的`UITableView`的`section`和`row`属性，就是定义在一个名为`NSIndexPath`的分类里的，如下\n\n![这里写图片描述](http://img.blog.csdn.net/20150531230308155)\n\n那这到底是怎么实现的呢？\n\n##iOS运行时机制简介\niOS运行时机制，简单来说，就是苹果给开发这提供的一套在运行时动态创建类、添加属性/方法（不止这些，还有一些其他功能）的API，它是一套纯C语言的API，使用相应的API就可以通过Category给一个原本存在的类添加属性。\n\n##实例\n\n```objectivec\n#import <Foundation/Foundation.h>\n#import <objc/runtime.h>\n\n@interface NSObject (CategoryWithProperty)\n\n/**\n *  要在Category中扩展的属性\n */\n@property (nonatomic, strong) NSObject *property;\n\n@end\n\n@implementation NSObject (CategoryWithProperty)\n\n- (NSObject *)property {\n    return objc_getAssociatedObject(self, @selector(property));\n}\n\n- (void)setProperty:(NSObject *)value {\n    objc_setAssociatedObject(self, @selector(property), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n\n@end\n```\n\n这样就可以在Category中添加属性了。\n","slug":"iOS运行时初探-使用运行时机制向Category中添加属性","published":1,"date":"2015-10-03T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oaa6000dzrm02ltvaumm","content":"<p>##前言<br>了解OC的都应该知道，在一般情况下，我们是不能向Category中添加属性的，只能添加方法，但有些情况向，我们确实需要向Category中添加属性，而且很多系统的API也有一些在Category添加属性的情况，例如我们属性的<code>UITableView</code>的<code>section</code>和<code>row</code>属性，就是定义在一个名为<code>NSIndexPath</code>的分类里的，如下</p>\n<p><img src=\"http://img.blog.csdn.net/20150531230308155\" alt=\"这里写图片描述\"></p>\n<p>那这到底是怎么实现的呢？</p>\n<p>##iOS运行时机制简介<br>iOS运行时机制，简单来说，就是苹果给开发这提供的一套在运行时动态创建类、添加属性/方法（不止这些，还有一些其他功能）的API，它是一套纯C语言的API，使用相应的API就可以通过Category给一个原本存在的类添加属性。</p>\n<p>##实例</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSObject</span> (<span class=\"title\">CategoryWithProperty</span>)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> *  要在Category中扩展的属性</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSObject</span> *property;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSObject</span> (<span class=\"title\">CategoryWithProperty</span>)</span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">NSObject</span> *)property &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"keyword\">@selector</span>(property));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setProperty:(<span class=\"built_in\">NSObject</span> *)value &#123;</div><div class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"keyword\">@selector</span>(property), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>这样就可以在Category中添加属性了。</p>\n","excerpt":"","more":"<p>##前言<br>了解OC的都应该知道，在一般情况下，我们是不能向Category中添加属性的，只能添加方法，但有些情况向，我们确实需要向Category中添加属性，而且很多系统的API也有一些在Category添加属性的情况，例如我们属性的<code>UITableView</code>的<code>section</code>和<code>row</code>属性，就是定义在一个名为<code>NSIndexPath</code>的分类里的，如下</p>\n<p><img src=\"http://img.blog.csdn.net/20150531230308155\" alt=\"这里写图片描述\"></p>\n<p>那这到底是怎么实现的呢？</p>\n<p>##iOS运行时机制简介<br>iOS运行时机制，简单来说，就是苹果给开发这提供的一套在运行时动态创建类、添加属性/方法（不止这些，还有一些其他功能）的API，它是一套纯C语言的API，使用相应的API就可以通过Category给一个原本存在的类添加属性。</p>\n<p>##实例</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSObject</span> (<span class=\"title\">CategoryWithProperty</span>)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> *  要在Category中扩展的属性</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSObject</span> *property;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSObject</span> (<span class=\"title\">CategoryWithProperty</span>)</span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">NSObject</span> *)property &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"keyword\">@selector</span>(property));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setProperty:(<span class=\"built_in\">NSObject</span> *)value &#123;</div><div class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"keyword\">@selector</span>(property), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>这样就可以在Category中添加属性了。</p>\n"},{"layout":"post","title":"使用jekyll+Github Pages搭建个人博客","_content":"\n从2号决定要做博客，到现在，总共折腾了两天半，总算把这个博客整好了，这篇文章算我对这个过程的一个总结。\n\n## 准备工作\n\n1. 安装Git，熟悉Git的常用操作（必须）\n2. 注册一个Github账号，熟悉Github的操作（必须）\n3. 注册一个多说账号，可以为你的博客增加评论功能（可选）\n\n## 开始搭建个人博客\n\n1. 安装jekyll，这个网上教程很多，基本上就是先安装ruby，在安装gem，然后安装jekyll。此处就略过了，大家可以在网上找教程。\n推荐：[http://jekyll.bootcss.com/](http://jekyll.bootcss.com/)\n2. 寻找jekyll模板，当然，有能力的可以自己制作模板，推荐几个寻找模板的好地方：\n    * [jekyllthemes](http://jekyllthemes.org/)，我的模板就是在这找的\n    * [知乎：有推荐的简洁明快的jekyll模板吗？](http://www.zhihu.com/question/20223939)\n3. 把找好的模板源码下载下来，然后在Github上创建一个空项目，把模板源码上传上去，下面以我用的模板Pithy说明一下具体的过程：\n    * 下载模板源码，如下图点击Download下载源码并解压\n\n    ![image](http://7xn88v.com1.z0.glb.clouddn.com/2015-10-04_16-46-21.jpg)\n\n    * 登录Github，创建一个空项目，取名为：<你的用户名>.github.io\n    * 然后把这个空项目clone到本地，把下载好的模板源码拷进去，然后再push到Github上，完成后的效果如下图\n\n    ![image](http://7xn88v.com1.z0.glb.clouddn.com/2015-10-04_16-54-30.jpg)\n\n4. 修改模板内容，主要有以下几点\n    * 修改_config.yml，具体修改方法可以参照 [http://higrid.net/c-art-blog_jekyll.htm](http://higrid.net/c-art-blog_jekyll.htm#--3)\n    * 修改多说账号，这个一般在_layouts/post.html文件中，有的模板中集成了多说，你只需要更改一下shortname即可，有的模板中没有集成多说，添加如下图的代码即可\n\n    ![image](http://7xn88v.com1.z0.glb.clouddn.com/2015-10-04_17-10-06.jpg)\n\n    * 删除_posts文件夹下的内容，这个文件夹下存放的就是你要发表的博客，大多数模板在这个文件夹中都会有几篇博客，你可以删除他们，\n    添加你自己的博客，注意文件名的命名规范：yyyy-MM-dd-博客标题.md，博客的头（两个---之间的内容）可以参考模板自带的博客，\n    把title改为自己博客的title\n5. 测试博客，此时，博客就已经搭建好了，你可以在_posts文件夹中添加新的博客\n    * 打开终端，进入博客目录，输入命令`jekyll server -w`\n    * 打开浏览器，输入`http://localhost:4000/`，这样就可以看到你的博客啦\n\n    ![image](http://7xn88v.com1.z0.glb.clouddn.com/2015-10-04_17-25-46.jpg)\n6. 把刚才的修改push到Github上，这样你就有了一个域名为：<你的用户名>.github.io的博客\n\n## 其他的一些优化\n\n* 添加Rakefile\n    * 用常规的方法创建博客，需要在_posts文件夹下创建一个.md文件，还要符合相应的命名规范，还要手动添加文件的头，非常麻烦，\n        使用Rakefile可以直接通过命令`rake post title=\"<博客标题>\"`，直接创建一篇博客，非常便捷\n    * 很多模板不带有Rakefile, 你可以从[我的博客仓库](https://github.com/liujinlongxa/liujinlongxa.github.io)里下载Rakefile文件，\n    拷贝到自己博客的根目录下\n\n* 定制博客文件头：根据自己的需求，修改Rakefile，定制博客的头，下面是我定制的内容，默认支持标题和分类，命令格式:\n    `rake post title=\"<博客标题> categories=\"<博客分类>\"`\n\n```shell\n\n    # Usage: rake post title=\"A Title\" [categories=\"post categories\"] [date=\"2012-02-09\"]\n    desc \"Begin a new post in #{CONFIG['posts']}\"\n    task :post do\n      abort(\"rake aborted: '#{CONFIG['posts']}' directory not found.\") unless FileTest.directory?(CONFIG['posts'])\n      title = ENV[\"title\"] || \"无题\"\n      categories = ENV[\"categories\"] || \"其他\" # 添加分类参数，默认为“其他”分类\n      # slug = title.downcase.strip.gsub(' ', '-').gsub(/[^\\w-]/, '')\n      slug = title.gsub(' ', '') # 修改博客标题，使其支持中文\n      begin\n        date = (ENV['date'] ? Time.parse(ENV['date']) : Time.now).strftime('%Y-%m-%d')\n      rescue Exception => e\n        puts \"Error - date format must be YYYY-MM-DD, please check you typed it correctly!\"\n        exit -1\n      end\n      filename = File.join(CONFIG['posts'], \"#{date}-#{slug}.#{CONFIG['post_ext']}\")\n      if File.exist?(filename)\n        abort(\"rake aborted!\") if ask(\"#{filename} already exists. Do you want to overwrite?\", ['y', 'n']) == 'n'\n      end\n\n      puts \"Creating new post: #{filename}\"\n\n    # 下面就是具体的博客头的内容\n      open(filename, 'w') do |post|\n        post.puts \"---\"\n        post.puts \"layout: post\"\n        post.puts \"title: \\\"#{title.gsub(/-/,' ')}\\\"\"\n        post.puts \"categories: \\\"#{categories.gsub(/-/,' ')}\\\"\"\n        post.puts \"---\"\n      end\n    end # task :post\n```\n\n* 简化创建博客的命令：每次创建博客输入`rake post title=\"<博客标题> categories=\"<博客分类>\"`这么一长串命令还是有些繁琐，可以在`~/.zshrc`\n    文件（如果没有装Oh-my-zsh，应该是`~/.bashrc`）添加如下代码，这样，以后你就可以直接输入命令 `rpt \"<博客标题>\" \"<博客分类>\"`创建博客，\n    怎么样，是不是非常方便\n\n```shell\nrpt() {\n        rake post title=$1 categories=$2\n}\n```\n\n* 使用七牛存储图片。博客空间是有限的（200M），建议将博客中的图片上传到第三方图床上（这里推荐七牛），博客中直接使用图片的外链，\n节省博客空间。\n\n## 接下来要做的\n\n* 目前，我写博客使用的是Atom，平时都是用Xcode，这种编辑器还是第一次用，感觉它对jekyll的markdown支持的不是很好，特别是\n`% highlight objectiveC %`代码块，打算以后看看有什么解决办法，不行的话就换个编辑器\n* 当前博客使用的还是github的域名，打算以后买个独立域名\n* 最后，当然是开始写博客啦！！！！\n","source":"_posts/2015-10-04-使用jekyll+GithubPage搭建个人博客系统.md","raw":"---\nlayout: post\ntitle: \"使用jekyll+Github Pages搭建个人博客\"\ncategories: \"其他\"\n---\n\n从2号决定要做博客，到现在，总共折腾了两天半，总算把这个博客整好了，这篇文章算我对这个过程的一个总结。\n\n## 准备工作\n\n1. 安装Git，熟悉Git的常用操作（必须）\n2. 注册一个Github账号，熟悉Github的操作（必须）\n3. 注册一个多说账号，可以为你的博客增加评论功能（可选）\n\n## 开始搭建个人博客\n\n1. 安装jekyll，这个网上教程很多，基本上就是先安装ruby，在安装gem，然后安装jekyll。此处就略过了，大家可以在网上找教程。\n推荐：[http://jekyll.bootcss.com/](http://jekyll.bootcss.com/)\n2. 寻找jekyll模板，当然，有能力的可以自己制作模板，推荐几个寻找模板的好地方：\n    * [jekyllthemes](http://jekyllthemes.org/)，我的模板就是在这找的\n    * [知乎：有推荐的简洁明快的jekyll模板吗？](http://www.zhihu.com/question/20223939)\n3. 把找好的模板源码下载下来，然后在Github上创建一个空项目，把模板源码上传上去，下面以我用的模板Pithy说明一下具体的过程：\n    * 下载模板源码，如下图点击Download下载源码并解压\n\n    ![image](http://7xn88v.com1.z0.glb.clouddn.com/2015-10-04_16-46-21.jpg)\n\n    * 登录Github，创建一个空项目，取名为：<你的用户名>.github.io\n    * 然后把这个空项目clone到本地，把下载好的模板源码拷进去，然后再push到Github上，完成后的效果如下图\n\n    ![image](http://7xn88v.com1.z0.glb.clouddn.com/2015-10-04_16-54-30.jpg)\n\n4. 修改模板内容，主要有以下几点\n    * 修改_config.yml，具体修改方法可以参照 [http://higrid.net/c-art-blog_jekyll.htm](http://higrid.net/c-art-blog_jekyll.htm#--3)\n    * 修改多说账号，这个一般在_layouts/post.html文件中，有的模板中集成了多说，你只需要更改一下shortname即可，有的模板中没有集成多说，添加如下图的代码即可\n\n    ![image](http://7xn88v.com1.z0.glb.clouddn.com/2015-10-04_17-10-06.jpg)\n\n    * 删除_posts文件夹下的内容，这个文件夹下存放的就是你要发表的博客，大多数模板在这个文件夹中都会有几篇博客，你可以删除他们，\n    添加你自己的博客，注意文件名的命名规范：yyyy-MM-dd-博客标题.md，博客的头（两个---之间的内容）可以参考模板自带的博客，\n    把title改为自己博客的title\n5. 测试博客，此时，博客就已经搭建好了，你可以在_posts文件夹中添加新的博客\n    * 打开终端，进入博客目录，输入命令`jekyll server -w`\n    * 打开浏览器，输入`http://localhost:4000/`，这样就可以看到你的博客啦\n\n    ![image](http://7xn88v.com1.z0.glb.clouddn.com/2015-10-04_17-25-46.jpg)\n6. 把刚才的修改push到Github上，这样你就有了一个域名为：<你的用户名>.github.io的博客\n\n## 其他的一些优化\n\n* 添加Rakefile\n    * 用常规的方法创建博客，需要在_posts文件夹下创建一个.md文件，还要符合相应的命名规范，还要手动添加文件的头，非常麻烦，\n        使用Rakefile可以直接通过命令`rake post title=\"<博客标题>\"`，直接创建一篇博客，非常便捷\n    * 很多模板不带有Rakefile, 你可以从[我的博客仓库](https://github.com/liujinlongxa/liujinlongxa.github.io)里下载Rakefile文件，\n    拷贝到自己博客的根目录下\n\n* 定制博客文件头：根据自己的需求，修改Rakefile，定制博客的头，下面是我定制的内容，默认支持标题和分类，命令格式:\n    `rake post title=\"<博客标题> categories=\"<博客分类>\"`\n\n```shell\n\n    # Usage: rake post title=\"A Title\" [categories=\"post categories\"] [date=\"2012-02-09\"]\n    desc \"Begin a new post in #{CONFIG['posts']}\"\n    task :post do\n      abort(\"rake aborted: '#{CONFIG['posts']}' directory not found.\") unless FileTest.directory?(CONFIG['posts'])\n      title = ENV[\"title\"] || \"无题\"\n      categories = ENV[\"categories\"] || \"其他\" # 添加分类参数，默认为“其他”分类\n      # slug = title.downcase.strip.gsub(' ', '-').gsub(/[^\\w-]/, '')\n      slug = title.gsub(' ', '') # 修改博客标题，使其支持中文\n      begin\n        date = (ENV['date'] ? Time.parse(ENV['date']) : Time.now).strftime('%Y-%m-%d')\n      rescue Exception => e\n        puts \"Error - date format must be YYYY-MM-DD, please check you typed it correctly!\"\n        exit -1\n      end\n      filename = File.join(CONFIG['posts'], \"#{date}-#{slug}.#{CONFIG['post_ext']}\")\n      if File.exist?(filename)\n        abort(\"rake aborted!\") if ask(\"#{filename} already exists. Do you want to overwrite?\", ['y', 'n']) == 'n'\n      end\n\n      puts \"Creating new post: #{filename}\"\n\n    # 下面就是具体的博客头的内容\n      open(filename, 'w') do |post|\n        post.puts \"---\"\n        post.puts \"layout: post\"\n        post.puts \"title: \\\"#{title.gsub(/-/,' ')}\\\"\"\n        post.puts \"categories: \\\"#{categories.gsub(/-/,' ')}\\\"\"\n        post.puts \"---\"\n      end\n    end # task :post\n```\n\n* 简化创建博客的命令：每次创建博客输入`rake post title=\"<博客标题> categories=\"<博客分类>\"`这么一长串命令还是有些繁琐，可以在`~/.zshrc`\n    文件（如果没有装Oh-my-zsh，应该是`~/.bashrc`）添加如下代码，这样，以后你就可以直接输入命令 `rpt \"<博客标题>\" \"<博客分类>\"`创建博客，\n    怎么样，是不是非常方便\n\n```shell\nrpt() {\n        rake post title=$1 categories=$2\n}\n```\n\n* 使用七牛存储图片。博客空间是有限的（200M），建议将博客中的图片上传到第三方图床上（这里推荐七牛），博客中直接使用图片的外链，\n节省博客空间。\n\n## 接下来要做的\n\n* 目前，我写博客使用的是Atom，平时都是用Xcode，这种编辑器还是第一次用，感觉它对jekyll的markdown支持的不是很好，特别是\n`% highlight objectiveC %`代码块，打算以后看看有什么解决办法，不行的话就换个编辑器\n* 当前博客使用的还是github的域名，打算以后买个独立域名\n* 最后，当然是开始写博客啦！！！！\n","slug":"使用jekyll+GithubPage搭建个人博客系统","published":1,"date":"2015-10-03T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oaaa000fzrm0hyfb4zzl","content":"<p>从2号决定要做博客，到现在，总共折腾了两天半，总算把这个博客整好了，这篇文章算我对这个过程的一个总结。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ol>\n<li>安装Git，熟悉Git的常用操作（必须）</li>\n<li>注册一个Github账号，熟悉Github的操作（必须）</li>\n<li>注册一个多说账号，可以为你的博客增加评论功能（可选）</li>\n</ol>\n<h2 id=\"开始搭建个人博客\"><a href=\"#开始搭建个人博客\" class=\"headerlink\" title=\"开始搭建个人博客\"></a>开始搭建个人博客</h2><ol>\n<li>安装jekyll，这个网上教程很多，基本上就是先安装ruby，在安装gem，然后安装jekyll。此处就略过了，大家可以在网上找教程。<br>推荐：<a href=\"http://jekyll.bootcss.com/\" target=\"_blank\" rel=\"external\">http://jekyll.bootcss.com/</a></li>\n<li>寻找jekyll模板，当然，有能力的可以自己制作模板，推荐几个寻找模板的好地方：<ul>\n<li><a href=\"http://jekyllthemes.org/\" target=\"_blank\" rel=\"external\">jekyllthemes</a>，我的模板就是在这找的</li>\n<li><a href=\"http://www.zhihu.com/question/20223939\" target=\"_blank\" rel=\"external\">知乎：有推荐的简洁明快的jekyll模板吗？</a></li>\n</ul>\n</li>\n<li><p>把找好的模板源码下载下来，然后在Github上创建一个空项目，把模板源码上传上去，下面以我用的模板Pithy说明一下具体的过程：</p>\n<ul>\n<li><p>下载模板源码，如下图点击Download下载源码并解压</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/2015-10-04_16-46-21.jpg\" alt=\"image\"></p>\n</li>\n<li><p>登录Github，创建一个空项目，取名为：&lt;你的用户名&gt;.github.io</p>\n</li>\n<li><p>然后把这个空项目clone到本地，把下载好的模板源码拷进去，然后再push到Github上，完成后的效果如下图</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/2015-10-04_16-54-30.jpg\" alt=\"image\"></p>\n</li>\n</ul>\n</li>\n<li><p>修改模板内容，主要有以下几点</p>\n<ul>\n<li>修改_config.yml，具体修改方法可以参照 <a href=\"http://higrid.net/c-art-blog_jekyll.htm#--3\" target=\"_blank\" rel=\"external\">http://higrid.net/c-art-blog_jekyll.htm</a></li>\n<li><p>修改多说账号，这个一般在_layouts/post.html文件中，有的模板中集成了多说，你只需要更改一下shortname即可，有的模板中没有集成多说，添加如下图的代码即可</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/2015-10-04_17-10-06.jpg\" alt=\"image\"></p>\n</li>\n<li><p>删除_posts文件夹下的内容，这个文件夹下存放的就是你要发表的博客，大多数模板在这个文件夹中都会有几篇博客，你可以删除他们，<br>添加你自己的博客，注意文件名的命名规范：yyyy-MM-dd-博客标题.md，博客的头（两个—之间的内容）可以参考模板自带的博客，<br>把title改为自己博客的title</p>\n</li>\n</ul>\n</li>\n<li><p>测试博客，此时，博客就已经搭建好了，你可以在_posts文件夹中添加新的博客</p>\n<ul>\n<li>打开终端，进入博客目录，输入命令<code>jekyll server -w</code></li>\n<li><p>打开浏览器，输入<code>http://localhost:4000/</code>，这样就可以看到你的博客啦</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/2015-10-04_17-25-46.jpg\" alt=\"image\"></p>\n</li>\n</ul>\n</li>\n<li>把刚才的修改push到Github上，这样你就有了一个域名为：&lt;你的用户名&gt;.github.io的博客</li>\n</ol>\n<h2 id=\"其他的一些优化\"><a href=\"#其他的一些优化\" class=\"headerlink\" title=\"其他的一些优化\"></a>其他的一些优化</h2><ul>\n<li><p>添加Rakefile</p>\n<ul>\n<li>用常规的方法创建博客，需要在_posts文件夹下创建一个.md文件，还要符合相应的命名规范，还要手动添加文件的头，非常麻烦，<br>  使用Rakefile可以直接通过命令<code>rake post title=&quot;&lt;博客标题&gt;&quot;</code>，直接创建一篇博客，非常便捷</li>\n<li>很多模板不带有Rakefile, 你可以从<a href=\"https://github.com/liujinlongxa/liujinlongxa.github.io\" target=\"_blank\" rel=\"external\">我的博客仓库</a>里下载Rakefile文件，<br>拷贝到自己博客的根目录下</li>\n</ul>\n</li>\n<li><p>定制博客文件头：根据自己的需求，修改Rakefile，定制博客的头，下面是我定制的内容，默认支持标题和分类，命令格式:<br>  <code>rake post title=&quot;&lt;博客标题&gt; categories=&quot;&lt;博客分类&gt;&quot;</code></p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># Usage: rake post title=&quot;A Title&quot; [categories=&quot;post categories&quot;] [date=&quot;2012-02-09&quot;]</div><div class=\"line\">desc &quot;Begin a new post in #&#123;CONFIG[&apos;posts&apos;]&#125;&quot;</div><div class=\"line\">task :post do</div><div class=\"line\">  abort(&quot;rake aborted: &apos;#&#123;CONFIG[&apos;posts&apos;]&#125;&apos; directory not found.&quot;) unless FileTest.directory?(CONFIG[&apos;posts&apos;])</div><div class=\"line\">  title = ENV[&quot;title&quot;] || &quot;无题&quot;</div><div class=\"line\">  categories = ENV[&quot;categories&quot;] || &quot;其他&quot; # 添加分类参数，默认为“其他”分类</div><div class=\"line\">  # slug = title.downcase.strip.gsub(&apos; &apos;, &apos;-&apos;).gsub(/[^\\w-]/, &apos;&apos;)</div><div class=\"line\">  slug = title.gsub(&apos; &apos;, &apos;&apos;) # 修改博客标题，使其支持中文</div><div class=\"line\">  begin</div><div class=\"line\">    date = (ENV[&apos;date&apos;] ? Time.parse(ENV[&apos;date&apos;]) : Time.now).strftime(&apos;%Y-%m-%d&apos;)</div><div class=\"line\">  rescue Exception =&gt; e</div><div class=\"line\">    puts &quot;Error - date format must be YYYY-MM-DD, please check you typed it correctly!&quot;</div><div class=\"line\">    exit -1</div><div class=\"line\">  end</div><div class=\"line\">  filename = File.join(CONFIG[&apos;posts&apos;], &quot;#&#123;date&#125;-#&#123;slug&#125;.#&#123;CONFIG[&apos;post_ext&apos;]&#125;&quot;)</div><div class=\"line\">  if File.exist?(filename)</div><div class=\"line\">    abort(&quot;rake aborted!&quot;) if ask(&quot;#&#123;filename&#125; already exists. Do you want to overwrite?&quot;, [&apos;y&apos;, &apos;n&apos;]) == &apos;n&apos;</div><div class=\"line\">  end</div><div class=\"line\"></div><div class=\"line\">  puts &quot;Creating new post: #&#123;filename&#125;&quot;</div><div class=\"line\"></div><div class=\"line\"># 下面就是具体的博客头的内容</div><div class=\"line\">  open(filename, &apos;w&apos;) do |post|</div><div class=\"line\">    post.puts &quot;---&quot;</div><div class=\"line\">    post.puts &quot;layout: post&quot;</div><div class=\"line\">    post.puts &quot;title: \\&quot;#&#123;title.gsub(/-/,&apos; &apos;)&#125;\\&quot;&quot;</div><div class=\"line\">    post.puts &quot;categories: \\&quot;#&#123;categories.gsub(/-/,&apos; &apos;)&#125;\\&quot;&quot;</div><div class=\"line\">    post.puts &quot;---&quot;</div><div class=\"line\">  end</div><div class=\"line\">end # task :post</div></pre></td></tr></table></figure>\n<ul>\n<li>简化创建博客的命令：每次创建博客输入<code>rake post title=&quot;&lt;博客标题&gt; categories=&quot;&lt;博客分类&gt;&quot;</code>这么一长串命令还是有些繁琐，可以在<code>~/.zshrc</code><br>  文件（如果没有装Oh-my-zsh，应该是<code>~/.bashrc</code>）添加如下代码，这样，以后你就可以直接输入命令 <code>rpt &quot;&lt;博客标题&gt;&quot; &quot;&lt;博客分类&gt;&quot;</code>创建博客，<br>  怎么样，是不是非常方便</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">rpt() &#123;</div><div class=\"line\">        rake post title=$1 categories=$2</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>使用七牛存储图片。博客空间是有限的（200M），建议将博客中的图片上传到第三方图床上（这里推荐七牛），博客中直接使用图片的外链，<br>节省博客空间。</li>\n</ul>\n<h2 id=\"接下来要做的\"><a href=\"#接下来要做的\" class=\"headerlink\" title=\"接下来要做的\"></a>接下来要做的</h2><ul>\n<li>目前，我写博客使用的是Atom，平时都是用Xcode，这种编辑器还是第一次用，感觉它对jekyll的markdown支持的不是很好，特别是<br><code>% highlight objectiveC %</code>代码块，打算以后看看有什么解决办法，不行的话就换个编辑器</li>\n<li>当前博客使用的还是github的域名，打算以后买个独立域名</li>\n<li>最后，当然是开始写博客啦！！！！</li>\n</ul>\n","excerpt":"","more":"<p>从2号决定要做博客，到现在，总共折腾了两天半，总算把这个博客整好了，这篇文章算我对这个过程的一个总结。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ol>\n<li>安装Git，熟悉Git的常用操作（必须）</li>\n<li>注册一个Github账号，熟悉Github的操作（必须）</li>\n<li>注册一个多说账号，可以为你的博客增加评论功能（可选）</li>\n</ol>\n<h2 id=\"开始搭建个人博客\"><a href=\"#开始搭建个人博客\" class=\"headerlink\" title=\"开始搭建个人博客\"></a>开始搭建个人博客</h2><ol>\n<li>安装jekyll，这个网上教程很多，基本上就是先安装ruby，在安装gem，然后安装jekyll。此处就略过了，大家可以在网上找教程。<br>推荐：<a href=\"http://jekyll.bootcss.com/\">http://jekyll.bootcss.com/</a></li>\n<li>寻找jekyll模板，当然，有能力的可以自己制作模板，推荐几个寻找模板的好地方：<ul>\n<li><a href=\"http://jekyllthemes.org/\">jekyllthemes</a>，我的模板就是在这找的</li>\n<li><a href=\"http://www.zhihu.com/question/20223939\">知乎：有推荐的简洁明快的jekyll模板吗？</a></li>\n</ul>\n</li>\n<li><p>把找好的模板源码下载下来，然后在Github上创建一个空项目，把模板源码上传上去，下面以我用的模板Pithy说明一下具体的过程：</p>\n<ul>\n<li><p>下载模板源码，如下图点击Download下载源码并解压</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/2015-10-04_16-46-21.jpg\" alt=\"image\"></p>\n</li>\n<li><p>登录Github，创建一个空项目，取名为：&lt;你的用户名&gt;.github.io</p>\n</li>\n<li><p>然后把这个空项目clone到本地，把下载好的模板源码拷进去，然后再push到Github上，完成后的效果如下图</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/2015-10-04_16-54-30.jpg\" alt=\"image\"></p>\n</li>\n</ul>\n</li>\n<li><p>修改模板内容，主要有以下几点</p>\n<ul>\n<li>修改_config.yml，具体修改方法可以参照 <a href=\"http://higrid.net/c-art-blog_jekyll.htm#--3\">http://higrid.net/c-art-blog_jekyll.htm</a></li>\n<li><p>修改多说账号，这个一般在_layouts/post.html文件中，有的模板中集成了多说，你只需要更改一下shortname即可，有的模板中没有集成多说，添加如下图的代码即可</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/2015-10-04_17-10-06.jpg\" alt=\"image\"></p>\n</li>\n<li><p>删除_posts文件夹下的内容，这个文件夹下存放的就是你要发表的博客，大多数模板在这个文件夹中都会有几篇博客，你可以删除他们，<br>添加你自己的博客，注意文件名的命名规范：yyyy-MM-dd-博客标题.md，博客的头（两个—之间的内容）可以参考模板自带的博客，<br>把title改为自己博客的title</p>\n</li>\n</ul>\n</li>\n<li><p>测试博客，此时，博客就已经搭建好了，你可以在_posts文件夹中添加新的博客</p>\n<ul>\n<li>打开终端，进入博客目录，输入命令<code>jekyll server -w</code></li>\n<li><p>打开浏览器，输入<code>http://localhost:4000/</code>，这样就可以看到你的博客啦</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/2015-10-04_17-25-46.jpg\" alt=\"image\"></p>\n</li>\n</ul>\n</li>\n<li>把刚才的修改push到Github上，这样你就有了一个域名为：&lt;你的用户名&gt;.github.io的博客</li>\n</ol>\n<h2 id=\"其他的一些优化\"><a href=\"#其他的一些优化\" class=\"headerlink\" title=\"其他的一些优化\"></a>其他的一些优化</h2><ul>\n<li><p>添加Rakefile</p>\n<ul>\n<li>用常规的方法创建博客，需要在_posts文件夹下创建一个.md文件，还要符合相应的命名规范，还要手动添加文件的头，非常麻烦，<br>  使用Rakefile可以直接通过命令<code>rake post title=&quot;&lt;博客标题&gt;&quot;</code>，直接创建一篇博客，非常便捷</li>\n<li>很多模板不带有Rakefile, 你可以从<a href=\"https://github.com/liujinlongxa/liujinlongxa.github.io\">我的博客仓库</a>里下载Rakefile文件，<br>拷贝到自己博客的根目录下</li>\n</ul>\n</li>\n<li><p>定制博客文件头：根据自己的需求，修改Rakefile，定制博客的头，下面是我定制的内容，默认支持标题和分类，命令格式:<br>  <code>rake post title=&quot;&lt;博客标题&gt; categories=&quot;&lt;博客分类&gt;&quot;</code></p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># Usage: rake post title=&quot;A Title&quot; [categories=&quot;post categories&quot;] [date=&quot;2012-02-09&quot;]</div><div class=\"line\">desc &quot;Begin a new post in #&#123;CONFIG[&apos;posts&apos;]&#125;&quot;</div><div class=\"line\">task :post do</div><div class=\"line\">  abort(&quot;rake aborted: &apos;#&#123;CONFIG[&apos;posts&apos;]&#125;&apos; directory not found.&quot;) unless FileTest.directory?(CONFIG[&apos;posts&apos;])</div><div class=\"line\">  title = ENV[&quot;title&quot;] || &quot;无题&quot;</div><div class=\"line\">  categories = ENV[&quot;categories&quot;] || &quot;其他&quot; # 添加分类参数，默认为“其他”分类</div><div class=\"line\">  # slug = title.downcase.strip.gsub(&apos; &apos;, &apos;-&apos;).gsub(/[^\\w-]/, &apos;&apos;)</div><div class=\"line\">  slug = title.gsub(&apos; &apos;, &apos;&apos;) # 修改博客标题，使其支持中文</div><div class=\"line\">  begin</div><div class=\"line\">    date = (ENV[&apos;date&apos;] ? Time.parse(ENV[&apos;date&apos;]) : Time.now).strftime(&apos;%Y-%m-%d&apos;)</div><div class=\"line\">  rescue Exception =&gt; e</div><div class=\"line\">    puts &quot;Error - date format must be YYYY-MM-DD, please check you typed it correctly!&quot;</div><div class=\"line\">    exit -1</div><div class=\"line\">  end</div><div class=\"line\">  filename = File.join(CONFIG[&apos;posts&apos;], &quot;#&#123;date&#125;-#&#123;slug&#125;.#&#123;CONFIG[&apos;post_ext&apos;]&#125;&quot;)</div><div class=\"line\">  if File.exist?(filename)</div><div class=\"line\">    abort(&quot;rake aborted!&quot;) if ask(&quot;#&#123;filename&#125; already exists. Do you want to overwrite?&quot;, [&apos;y&apos;, &apos;n&apos;]) == &apos;n&apos;</div><div class=\"line\">  end</div><div class=\"line\"></div><div class=\"line\">  puts &quot;Creating new post: #&#123;filename&#125;&quot;</div><div class=\"line\"></div><div class=\"line\"># 下面就是具体的博客头的内容</div><div class=\"line\">  open(filename, &apos;w&apos;) do |post|</div><div class=\"line\">    post.puts &quot;---&quot;</div><div class=\"line\">    post.puts &quot;layout: post&quot;</div><div class=\"line\">    post.puts &quot;title: \\&quot;#&#123;title.gsub(/-/,&apos; &apos;)&#125;\\&quot;&quot;</div><div class=\"line\">    post.puts &quot;categories: \\&quot;#&#123;categories.gsub(/-/,&apos; &apos;)&#125;\\&quot;&quot;</div><div class=\"line\">    post.puts &quot;---&quot;</div><div class=\"line\">  end</div><div class=\"line\">end # task :post</div></pre></td></tr></table></figure>\n<ul>\n<li>简化创建博客的命令：每次创建博客输入<code>rake post title=&quot;&lt;博客标题&gt; categories=&quot;&lt;博客分类&gt;&quot;</code>这么一长串命令还是有些繁琐，可以在<code>~/.zshrc</code><br>  文件（如果没有装Oh-my-zsh，应该是<code>~/.bashrc</code>）添加如下代码，这样，以后你就可以直接输入命令 <code>rpt &quot;&lt;博客标题&gt;&quot; &quot;&lt;博客分类&gt;&quot;</code>创建博客，<br>  怎么样，是不是非常方便</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">rpt() &#123;</div><div class=\"line\">        rake post title=$1 categories=$2</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>使用七牛存储图片。博客空间是有限的（200M），建议将博客中的图片上传到第三方图床上（这里推荐七牛），博客中直接使用图片的外链，<br>节省博客空间。</li>\n</ul>\n<h2 id=\"接下来要做的\"><a href=\"#接下来要做的\" class=\"headerlink\" title=\"接下来要做的\"></a>接下来要做的</h2><ul>\n<li>目前，我写博客使用的是Atom，平时都是用Xcode，这种编辑器还是第一次用，感觉它对jekyll的markdown支持的不是很好，特别是<br><code>% highlight objectiveC %</code>代码块，打算以后看看有什么解决办法，不行的话就换个编辑器</li>\n<li>当前博客使用的还是github的域名，打算以后买个独立域名</li>\n<li>最后，当然是开始写博客啦！！！！</li>\n</ul>\n"},{"layout":"post","title":"《图解HTTP》读书笔记(1)","_content":"\n* toc\n{:toc}\n\n## 第一章 了解web及网络基础\n\n### TCP/IP协议族\n\n通常使用的网络（包括互联网）实在TCP/IP协议族的基础上运作的，而HTTP属于它内部的一个子集。\n\n**协议(protocol)** ： 不同硬件、操作系统之间的通信规则\n\n#### TCP/IP的分层管理\n\n发送端逐层向下传输，接收端逐层向上传输。发送端每经过一层传输，需要加上该层的头部信息，\n接收端需要进行拆包，去掉头部信息。\n\n* 应用层：决定了向用户提供应用服务时通信的活动。FTP，DNS，HTTP都属于这一层\n* 传输层：提供网络连接中两台计算机之间的数据传输。TCP和UDP属于这一层。\n* 网络层：又称网络互联层，处理网络上流动的数据包。\n* 链路层：又称数据链路层，处理链接网络的硬件部分。\n\n### 与HTTP关系密切的协议：IP，TCP和DNS\n\n#### 1.负责传输的IP协议\n\nIP协议（网际协议，Internet Protocol）属于网络层。IP协议和IP地址是不同的概念。\nIP协议的作用是把各种数据包传送给对方。传送需要满足两个条件，IP地址和MAC地址。\n\n* IP地址指明了节点被分配到的地址\n* MAC地址是指网卡所属的固定地址\n\n#### 2.保证可靠性的TCP协议\n\nTCP协议位于传输层，提供可靠的字节流服务。\n\n* 字节流服务：将大块数据分割成以报文段为单位的数据包进行管理\n* 可靠：通过一些手段确保信息准确无误的传输\n\n**三次握手** 确保通信的可靠性\n\n#### 3.负责域名解析的DNS服务\n\nDNS属于应用层协议，它提供域名到IP之间的解析服务。\n\n#### 4.URI和URL\n\n* URI：统一资源标识符，用字符串标识互联网上的某一资源\n    * URI的格式：`http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1`\n\n* URL：统一资源定位符，互联网上某一资源的位置，他是URI的子集\n\n## 第二章 简单的HTTP协议\n\n### 请求与响应\n\n每次HTTP通信都是客户端发起请求，服务器返回响应\n\n### HTTP是不保存状态的协议\n\nHTTP是无状态协议，它自身不对请求和响应之间的通信状态进行保存。为了实现状态保存，例如用户的登录状态保存，引入的Cookie技术。\n\n### HTTP方法\n\n* GET方法：获取资源\n* POST方法：传输实体主体\n* PUT方法：传输文件，存在安全问题，一般网站不使用该方法\n* HEAD方法：获取报文首部，与GET方法一样，只不过不返回报文主体部分\n* DELETE方法：删除文件，存在安全问题，一般网站不使用该方法\n* OPTIONS方法：询问支持的方法\n* TRACE方法：追踪路径，可查询发出的请求是怎么被加工修改、篡改的，可追踪代理服务器中转请求时对请求的修改，不常用\n* CONNECT方法：要求使用隧道协议链接代理，主要使用SSL和TLS协议把通信内容加密后经网络隧道传输。\n\n### 持久链接和管线化\n\n* **持久链接**\n所谓的持久链接就是在客户端和服务器建立TCP链接后，只要任何一方都没有提出中断链接，TCP链接就不会断。在HTTP1.0中，每个HTTP请求都要重新建立TCP链接，传输完成后，再断开\n链接，在HTTP1.1中，默认所有的请求都是持久链接，只需要链接一次，就可以一直保持这个链接，这样就大大减少了建立链接的开销，提高页面的显示速度。\n* **管线化**\n所谓的管线化就是发送一个请求后，不需要等到响应返回，就可以发送下一个请求\n\n### 使用Cookie的状态管理\n\nCookie会根据服务器发送响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie，当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值，\n这样服务器就会获取客户端的状态。\n","source":"_posts/2015-10-05-《图解HTTP》读书笔记(1).md","raw":"---\nlayout: post\ntitle: \"《图解HTTP》读书笔记(1)\"\ncategories: \"读书笔记\"\n---\n\n* toc\n{:toc}\n\n## 第一章 了解web及网络基础\n\n### TCP/IP协议族\n\n通常使用的网络（包括互联网）实在TCP/IP协议族的基础上运作的，而HTTP属于它内部的一个子集。\n\n**协议(protocol)** ： 不同硬件、操作系统之间的通信规则\n\n#### TCP/IP的分层管理\n\n发送端逐层向下传输，接收端逐层向上传输。发送端每经过一层传输，需要加上该层的头部信息，\n接收端需要进行拆包，去掉头部信息。\n\n* 应用层：决定了向用户提供应用服务时通信的活动。FTP，DNS，HTTP都属于这一层\n* 传输层：提供网络连接中两台计算机之间的数据传输。TCP和UDP属于这一层。\n* 网络层：又称网络互联层，处理网络上流动的数据包。\n* 链路层：又称数据链路层，处理链接网络的硬件部分。\n\n### 与HTTP关系密切的协议：IP，TCP和DNS\n\n#### 1.负责传输的IP协议\n\nIP协议（网际协议，Internet Protocol）属于网络层。IP协议和IP地址是不同的概念。\nIP协议的作用是把各种数据包传送给对方。传送需要满足两个条件，IP地址和MAC地址。\n\n* IP地址指明了节点被分配到的地址\n* MAC地址是指网卡所属的固定地址\n\n#### 2.保证可靠性的TCP协议\n\nTCP协议位于传输层，提供可靠的字节流服务。\n\n* 字节流服务：将大块数据分割成以报文段为单位的数据包进行管理\n* 可靠：通过一些手段确保信息准确无误的传输\n\n**三次握手** 确保通信的可靠性\n\n#### 3.负责域名解析的DNS服务\n\nDNS属于应用层协议，它提供域名到IP之间的解析服务。\n\n#### 4.URI和URL\n\n* URI：统一资源标识符，用字符串标识互联网上的某一资源\n    * URI的格式：`http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1`\n\n* URL：统一资源定位符，互联网上某一资源的位置，他是URI的子集\n\n## 第二章 简单的HTTP协议\n\n### 请求与响应\n\n每次HTTP通信都是客户端发起请求，服务器返回响应\n\n### HTTP是不保存状态的协议\n\nHTTP是无状态协议，它自身不对请求和响应之间的通信状态进行保存。为了实现状态保存，例如用户的登录状态保存，引入的Cookie技术。\n\n### HTTP方法\n\n* GET方法：获取资源\n* POST方法：传输实体主体\n* PUT方法：传输文件，存在安全问题，一般网站不使用该方法\n* HEAD方法：获取报文首部，与GET方法一样，只不过不返回报文主体部分\n* DELETE方法：删除文件，存在安全问题，一般网站不使用该方法\n* OPTIONS方法：询问支持的方法\n* TRACE方法：追踪路径，可查询发出的请求是怎么被加工修改、篡改的，可追踪代理服务器中转请求时对请求的修改，不常用\n* CONNECT方法：要求使用隧道协议链接代理，主要使用SSL和TLS协议把通信内容加密后经网络隧道传输。\n\n### 持久链接和管线化\n\n* **持久链接**\n所谓的持久链接就是在客户端和服务器建立TCP链接后，只要任何一方都没有提出中断链接，TCP链接就不会断。在HTTP1.0中，每个HTTP请求都要重新建立TCP链接，传输完成后，再断开\n链接，在HTTP1.1中，默认所有的请求都是持久链接，只需要链接一次，就可以一直保持这个链接，这样就大大减少了建立链接的开销，提高页面的显示速度。\n* **管线化**\n所谓的管线化就是发送一个请求后，不需要等到响应返回，就可以发送下一个请求\n\n### 使用Cookie的状态管理\n\nCookie会根据服务器发送响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie，当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值，\n这样服务器就会获取客户端的状态。\n","slug":"《图解HTTP》读书笔记(1)","published":1,"date":"2015-10-04T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oaad000hzrm0veaso4ym","content":"<ul>\n<li>toc<br>{:toc}</li>\n</ul>\n<h2 id=\"第一章-了解web及网络基础\"><a href=\"#第一章-了解web及网络基础\" class=\"headerlink\" title=\"第一章 了解web及网络基础\"></a>第一章 了解web及网络基础</h2><h3 id=\"TCP-IP协议族\"><a href=\"#TCP-IP协议族\" class=\"headerlink\" title=\"TCP/IP协议族\"></a>TCP/IP协议族</h3><p>通常使用的网络（包括互联网）实在TCP/IP协议族的基础上运作的，而HTTP属于它内部的一个子集。</p>\n<p><strong>协议(protocol)</strong> ： 不同硬件、操作系统之间的通信规则</p>\n<h4 id=\"TCP-IP的分层管理\"><a href=\"#TCP-IP的分层管理\" class=\"headerlink\" title=\"TCP/IP的分层管理\"></a>TCP/IP的分层管理</h4><p>发送端逐层向下传输，接收端逐层向上传输。发送端每经过一层传输，需要加上该层的头部信息，<br>接收端需要进行拆包，去掉头部信息。</p>\n<ul>\n<li>应用层：决定了向用户提供应用服务时通信的活动。FTP，DNS，HTTP都属于这一层</li>\n<li>传输层：提供网络连接中两台计算机之间的数据传输。TCP和UDP属于这一层。</li>\n<li>网络层：又称网络互联层，处理网络上流动的数据包。</li>\n<li>链路层：又称数据链路层，处理链接网络的硬件部分。</li>\n</ul>\n<h3 id=\"与HTTP关系密切的协议：IP，TCP和DNS\"><a href=\"#与HTTP关系密切的协议：IP，TCP和DNS\" class=\"headerlink\" title=\"与HTTP关系密切的协议：IP，TCP和DNS\"></a>与HTTP关系密切的协议：IP，TCP和DNS</h3><h4 id=\"1-负责传输的IP协议\"><a href=\"#1-负责传输的IP协议\" class=\"headerlink\" title=\"1.负责传输的IP协议\"></a>1.负责传输的IP协议</h4><p>IP协议（网际协议，Internet Protocol）属于网络层。IP协议和IP地址是不同的概念。<br>IP协议的作用是把各种数据包传送给对方。传送需要满足两个条件，IP地址和MAC地址。</p>\n<ul>\n<li>IP地址指明了节点被分配到的地址</li>\n<li>MAC地址是指网卡所属的固定地址</li>\n</ul>\n<h4 id=\"2-保证可靠性的TCP协议\"><a href=\"#2-保证可靠性的TCP协议\" class=\"headerlink\" title=\"2.保证可靠性的TCP协议\"></a>2.保证可靠性的TCP协议</h4><p>TCP协议位于传输层，提供可靠的字节流服务。</p>\n<ul>\n<li>字节流服务：将大块数据分割成以报文段为单位的数据包进行管理</li>\n<li>可靠：通过一些手段确保信息准确无误的传输</li>\n</ul>\n<p><strong>三次握手</strong> 确保通信的可靠性</p>\n<h4 id=\"3-负责域名解析的DNS服务\"><a href=\"#3-负责域名解析的DNS服务\" class=\"headerlink\" title=\"3.负责域名解析的DNS服务\"></a>3.负责域名解析的DNS服务</h4><p>DNS属于应用层协议，它提供域名到IP之间的解析服务。</p>\n<h4 id=\"4-URI和URL\"><a href=\"#4-URI和URL\" class=\"headerlink\" title=\"4.URI和URL\"></a>4.URI和URL</h4><ul>\n<li><p>URI：统一资源标识符，用字符串标识互联网上的某一资源</p>\n<ul>\n<li>URI的格式：<code>http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1</code></li>\n</ul>\n</li>\n<li><p>URL：统一资源定位符，互联网上某一资源的位置，他是URI的子集</p>\n</li>\n</ul>\n<h2 id=\"第二章-简单的HTTP协议\"><a href=\"#第二章-简单的HTTP协议\" class=\"headerlink\" title=\"第二章 简单的HTTP协议\"></a>第二章 简单的HTTP协议</h2><h3 id=\"请求与响应\"><a href=\"#请求与响应\" class=\"headerlink\" title=\"请求与响应\"></a>请求与响应</h3><p>每次HTTP通信都是客户端发起请求，服务器返回响应</p>\n<h3 id=\"HTTP是不保存状态的协议\"><a href=\"#HTTP是不保存状态的协议\" class=\"headerlink\" title=\"HTTP是不保存状态的协议\"></a>HTTP是不保存状态的协议</h3><p>HTTP是无状态协议，它自身不对请求和响应之间的通信状态进行保存。为了实现状态保存，例如用户的登录状态保存，引入的Cookie技术。</p>\n<h3 id=\"HTTP方法\"><a href=\"#HTTP方法\" class=\"headerlink\" title=\"HTTP方法\"></a>HTTP方法</h3><ul>\n<li>GET方法：获取资源</li>\n<li>POST方法：传输实体主体</li>\n<li>PUT方法：传输文件，存在安全问题，一般网站不使用该方法</li>\n<li>HEAD方法：获取报文首部，与GET方法一样，只不过不返回报文主体部分</li>\n<li>DELETE方法：删除文件，存在安全问题，一般网站不使用该方法</li>\n<li>OPTIONS方法：询问支持的方法</li>\n<li>TRACE方法：追踪路径，可查询发出的请求是怎么被加工修改、篡改的，可追踪代理服务器中转请求时对请求的修改，不常用</li>\n<li>CONNECT方法：要求使用隧道协议链接代理，主要使用SSL和TLS协议把通信内容加密后经网络隧道传输。</li>\n</ul>\n<h3 id=\"持久链接和管线化\"><a href=\"#持久链接和管线化\" class=\"headerlink\" title=\"持久链接和管线化\"></a>持久链接和管线化</h3><ul>\n<li><strong>持久链接</strong><br>所谓的持久链接就是在客户端和服务器建立TCP链接后，只要任何一方都没有提出中断链接，TCP链接就不会断。在HTTP1.0中，每个HTTP请求都要重新建立TCP链接，传输完成后，再断开<br>链接，在HTTP1.1中，默认所有的请求都是持久链接，只需要链接一次，就可以一直保持这个链接，这样就大大减少了建立链接的开销，提高页面的显示速度。</li>\n<li><strong>管线化</strong><br>所谓的管线化就是发送一个请求后，不需要等到响应返回，就可以发送下一个请求</li>\n</ul>\n<h3 id=\"使用Cookie的状态管理\"><a href=\"#使用Cookie的状态管理\" class=\"headerlink\" title=\"使用Cookie的状态管理\"></a>使用Cookie的状态管理</h3><p>Cookie会根据服务器发送响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie，当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值，<br>这样服务器就会获取客户端的状态。</p>\n","excerpt":"","more":"<ul>\n<li>toc<br>{:toc}</li>\n</ul>\n<h2 id=\"第一章-了解web及网络基础\"><a href=\"#第一章-了解web及网络基础\" class=\"headerlink\" title=\"第一章 了解web及网络基础\"></a>第一章 了解web及网络基础</h2><h3 id=\"TCP-IP协议族\"><a href=\"#TCP-IP协议族\" class=\"headerlink\" title=\"TCP/IP协议族\"></a>TCP/IP协议族</h3><p>通常使用的网络（包括互联网）实在TCP/IP协议族的基础上运作的，而HTTP属于它内部的一个子集。</p>\n<p><strong>协议(protocol)</strong> ： 不同硬件、操作系统之间的通信规则</p>\n<h4 id=\"TCP-IP的分层管理\"><a href=\"#TCP-IP的分层管理\" class=\"headerlink\" title=\"TCP/IP的分层管理\"></a>TCP/IP的分层管理</h4><p>发送端逐层向下传输，接收端逐层向上传输。发送端每经过一层传输，需要加上该层的头部信息，<br>接收端需要进行拆包，去掉头部信息。</p>\n<ul>\n<li>应用层：决定了向用户提供应用服务时通信的活动。FTP，DNS，HTTP都属于这一层</li>\n<li>传输层：提供网络连接中两台计算机之间的数据传输。TCP和UDP属于这一层。</li>\n<li>网络层：又称网络互联层，处理网络上流动的数据包。</li>\n<li>链路层：又称数据链路层，处理链接网络的硬件部分。</li>\n</ul>\n<h3 id=\"与HTTP关系密切的协议：IP，TCP和DNS\"><a href=\"#与HTTP关系密切的协议：IP，TCP和DNS\" class=\"headerlink\" title=\"与HTTP关系密切的协议：IP，TCP和DNS\"></a>与HTTP关系密切的协议：IP，TCP和DNS</h3><h4 id=\"1-负责传输的IP协议\"><a href=\"#1-负责传输的IP协议\" class=\"headerlink\" title=\"1.负责传输的IP协议\"></a>1.负责传输的IP协议</h4><p>IP协议（网际协议，Internet Protocol）属于网络层。IP协议和IP地址是不同的概念。<br>IP协议的作用是把各种数据包传送给对方。传送需要满足两个条件，IP地址和MAC地址。</p>\n<ul>\n<li>IP地址指明了节点被分配到的地址</li>\n<li>MAC地址是指网卡所属的固定地址</li>\n</ul>\n<h4 id=\"2-保证可靠性的TCP协议\"><a href=\"#2-保证可靠性的TCP协议\" class=\"headerlink\" title=\"2.保证可靠性的TCP协议\"></a>2.保证可靠性的TCP协议</h4><p>TCP协议位于传输层，提供可靠的字节流服务。</p>\n<ul>\n<li>字节流服务：将大块数据分割成以报文段为单位的数据包进行管理</li>\n<li>可靠：通过一些手段确保信息准确无误的传输</li>\n</ul>\n<p><strong>三次握手</strong> 确保通信的可靠性</p>\n<h4 id=\"3-负责域名解析的DNS服务\"><a href=\"#3-负责域名解析的DNS服务\" class=\"headerlink\" title=\"3.负责域名解析的DNS服务\"></a>3.负责域名解析的DNS服务</h4><p>DNS属于应用层协议，它提供域名到IP之间的解析服务。</p>\n<h4 id=\"4-URI和URL\"><a href=\"#4-URI和URL\" class=\"headerlink\" title=\"4.URI和URL\"></a>4.URI和URL</h4><ul>\n<li><p>URI：统一资源标识符，用字符串标识互联网上的某一资源</p>\n<ul>\n<li>URI的格式：<code>http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1</code></li>\n</ul>\n</li>\n<li><p>URL：统一资源定位符，互联网上某一资源的位置，他是URI的子集</p>\n</li>\n</ul>\n<h2 id=\"第二章-简单的HTTP协议\"><a href=\"#第二章-简单的HTTP协议\" class=\"headerlink\" title=\"第二章 简单的HTTP协议\"></a>第二章 简单的HTTP协议</h2><h3 id=\"请求与响应\"><a href=\"#请求与响应\" class=\"headerlink\" title=\"请求与响应\"></a>请求与响应</h3><p>每次HTTP通信都是客户端发起请求，服务器返回响应</p>\n<h3 id=\"HTTP是不保存状态的协议\"><a href=\"#HTTP是不保存状态的协议\" class=\"headerlink\" title=\"HTTP是不保存状态的协议\"></a>HTTP是不保存状态的协议</h3><p>HTTP是无状态协议，它自身不对请求和响应之间的通信状态进行保存。为了实现状态保存，例如用户的登录状态保存，引入的Cookie技术。</p>\n<h3 id=\"HTTP方法\"><a href=\"#HTTP方法\" class=\"headerlink\" title=\"HTTP方法\"></a>HTTP方法</h3><ul>\n<li>GET方法：获取资源</li>\n<li>POST方法：传输实体主体</li>\n<li>PUT方法：传输文件，存在安全问题，一般网站不使用该方法</li>\n<li>HEAD方法：获取报文首部，与GET方法一样，只不过不返回报文主体部分</li>\n<li>DELETE方法：删除文件，存在安全问题，一般网站不使用该方法</li>\n<li>OPTIONS方法：询问支持的方法</li>\n<li>TRACE方法：追踪路径，可查询发出的请求是怎么被加工修改、篡改的，可追踪代理服务器中转请求时对请求的修改，不常用</li>\n<li>CONNECT方法：要求使用隧道协议链接代理，主要使用SSL和TLS协议把通信内容加密后经网络隧道传输。</li>\n</ul>\n<h3 id=\"持久链接和管线化\"><a href=\"#持久链接和管线化\" class=\"headerlink\" title=\"持久链接和管线化\"></a>持久链接和管线化</h3><ul>\n<li><strong>持久链接</strong><br>所谓的持久链接就是在客户端和服务器建立TCP链接后，只要任何一方都没有提出中断链接，TCP链接就不会断。在HTTP1.0中，每个HTTP请求都要重新建立TCP链接，传输完成后，再断开<br>链接，在HTTP1.1中，默认所有的请求都是持久链接，只需要链接一次，就可以一直保持这个链接，这样就大大减少了建立链接的开销，提高页面的显示速度。</li>\n<li><strong>管线化</strong><br>所谓的管线化就是发送一个请求后，不需要等到响应返回，就可以发送下一个请求</li>\n</ul>\n<h3 id=\"使用Cookie的状态管理\"><a href=\"#使用Cookie的状态管理\" class=\"headerlink\" title=\"使用Cookie的状态管理\"></a>使用Cookie的状态管理</h3><p>Cookie会根据服务器发送响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie，当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值，<br>这样服务器就会获取客户端的状态。</p>\n"},{"layout":"post","title":"适配iOS9（ATS问题）","_content":"\n##前言\n今天下了XCode7 Beta版，跑了一下自家的APP，结果发现所有服务器请求都返回失败，明明网络正常，怎么会返回失败呢？起初我以为是AFNetworking的问题，于是我写了个demo，去掉AFNetworking，直接用NSURLSession请求数据，也是请求失败。于是乎一顿Google，原来是iOS9（XCode7的模拟器默认是iOS9）的新特性——ATS搞的鬼。\n\n##简介\nATS全称为App Transport Security，它是iOS9的一个新特性，旨在提高iOS设备与服务器交互的安全性。简单地说，ATS会阻止未注册的网络请求。你可以在info.plist文件中注册相应的host，这样该host的网络请求就不会被阻止。你也可以设置不阻止任何host的网络请求。\n\n##详细设置\n如果你想设置不阻止任何网络，只需要在info.plist文件中加入以下内容即可\n\n![这里写图片描述](http://img.blog.csdn.net/20150619164549061)\n\n如果你想设置只允许特定host的网络请求，在info.plist文件中加入以下内容\n\n![这里写图片描述](http://img.blog.csdn.net/20150619164722416)\n\n这样，你在发往`baike.baidu.com`这个host的请求就都不会被阻止了，你可以注册多个域名。\n\n##参考资料\n[What's New in iOS9](https://developer.apple.com/library/prerelease/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS9.html#//apple_ref/doc/uid/TP40016198-DontLinkElementID_13)\n[NSURLSession/NSURLConnection HTTP load failed](http://stackoverflow.com/questions/30739473/nsurlsession-nsurlconnection-http-load-failed)\n","source":"_posts/2015-10-04-适配iOS9（ATS问题）.md","raw":"---\nlayout: post\ntitle: \"适配iOS9（ATS问题）\"\ncategories: \"iOS开发\"\n---\n\n##前言\n今天下了XCode7 Beta版，跑了一下自家的APP，结果发现所有服务器请求都返回失败，明明网络正常，怎么会返回失败呢？起初我以为是AFNetworking的问题，于是我写了个demo，去掉AFNetworking，直接用NSURLSession请求数据，也是请求失败。于是乎一顿Google，原来是iOS9（XCode7的模拟器默认是iOS9）的新特性——ATS搞的鬼。\n\n##简介\nATS全称为App Transport Security，它是iOS9的一个新特性，旨在提高iOS设备与服务器交互的安全性。简单地说，ATS会阻止未注册的网络请求。你可以在info.plist文件中注册相应的host，这样该host的网络请求就不会被阻止。你也可以设置不阻止任何host的网络请求。\n\n##详细设置\n如果你想设置不阻止任何网络，只需要在info.plist文件中加入以下内容即可\n\n![这里写图片描述](http://img.blog.csdn.net/20150619164549061)\n\n如果你想设置只允许特定host的网络请求，在info.plist文件中加入以下内容\n\n![这里写图片描述](http://img.blog.csdn.net/20150619164722416)\n\n这样，你在发往`baike.baidu.com`这个host的请求就都不会被阻止了，你可以注册多个域名。\n\n##参考资料\n[What's New in iOS9](https://developer.apple.com/library/prerelease/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS9.html#//apple_ref/doc/uid/TP40016198-DontLinkElementID_13)\n[NSURLSession/NSURLConnection HTTP load failed](http://stackoverflow.com/questions/30739473/nsurlsession-nsurlconnection-http-load-failed)\n","slug":"适配iOS9（ATS问题）","published":1,"date":"2015-10-03T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oaah000lzrm0bf9gfmsh","content":"<p>##前言<br>今天下了XCode7 Beta版，跑了一下自家的APP，结果发现所有服务器请求都返回失败，明明网络正常，怎么会返回失败呢？起初我以为是AFNetworking的问题，于是我写了个demo，去掉AFNetworking，直接用NSURLSession请求数据，也是请求失败。于是乎一顿Google，原来是iOS9（XCode7的模拟器默认是iOS9）的新特性——ATS搞的鬼。</p>\n<p>##简介<br>ATS全称为App Transport Security，它是iOS9的一个新特性，旨在提高iOS设备与服务器交互的安全性。简单地说，ATS会阻止未注册的网络请求。你可以在info.plist文件中注册相应的host，这样该host的网络请求就不会被阻止。你也可以设置不阻止任何host的网络请求。</p>\n<p>##详细设置<br>如果你想设置不阻止任何网络，只需要在info.plist文件中加入以下内容即可</p>\n<p><img src=\"http://img.blog.csdn.net/20150619164549061\" alt=\"这里写图片描述\"></p>\n<p>如果你想设置只允许特定host的网络请求，在info.plist文件中加入以下内容</p>\n<p><img src=\"http://img.blog.csdn.net/20150619164722416\" alt=\"这里写图片描述\"></p>\n<p>这样，你在发往<code>baike.baidu.com</code>这个host的请求就都不会被阻止了，你可以注册多个域名。</p>\n<p>##参考资料<br><a href=\"https://developer.apple.com/library/prerelease/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS9.html#//apple_ref/doc/uid/TP40016198-DontLinkElementID_13\" target=\"_blank\" rel=\"external\">What’s New in iOS9</a><br><a href=\"http://stackoverflow.com/questions/30739473/nsurlsession-nsurlconnection-http-load-failed\" target=\"_blank\" rel=\"external\">NSURLSession/NSURLConnection HTTP load failed</a></p>\n","excerpt":"","more":"<p>##前言<br>今天下了XCode7 Beta版，跑了一下自家的APP，结果发现所有服务器请求都返回失败，明明网络正常，怎么会返回失败呢？起初我以为是AFNetworking的问题，于是我写了个demo，去掉AFNetworking，直接用NSURLSession请求数据，也是请求失败。于是乎一顿Google，原来是iOS9（XCode7的模拟器默认是iOS9）的新特性——ATS搞的鬼。</p>\n<p>##简介<br>ATS全称为App Transport Security，它是iOS9的一个新特性，旨在提高iOS设备与服务器交互的安全性。简单地说，ATS会阻止未注册的网络请求。你可以在info.plist文件中注册相应的host，这样该host的网络请求就不会被阻止。你也可以设置不阻止任何host的网络请求。</p>\n<p>##详细设置<br>如果你想设置不阻止任何网络，只需要在info.plist文件中加入以下内容即可</p>\n<p><img src=\"http://img.blog.csdn.net/20150619164549061\" alt=\"这里写图片描述\"></p>\n<p>如果你想设置只允许特定host的网络请求，在info.plist文件中加入以下内容</p>\n<p><img src=\"http://img.blog.csdn.net/20150619164722416\" alt=\"这里写图片描述\"></p>\n<p>这样，你在发往<code>baike.baidu.com</code>这个host的请求就都不会被阻止了，你可以注册多个域名。</p>\n<p>##参考资料<br><a href=\"https://developer.apple.com/library/prerelease/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS9.html#//apple_ref/doc/uid/TP40016198-DontLinkElementID_13\">What’s New in iOS9</a><br><a href=\"http://stackoverflow.com/questions/30739473/nsurlsession-nsurlconnection-http-load-failed\">NSURLSession/NSURLConnection HTTP load failed</a></p>\n"},{"layout":"post","title":"《图解HTTP》读书笔记(3)","_content":"\n* toc\n{:toc}\n\n## 第八章 确认访问身份的认证\n\n### 何为认证\n\n**认证** 即为了弄清坐在电脑前的用户的真实身份，需要对用户的信息进行核实的过程\n\n常见的几种认证方式：\n\n* BASIC认证（基本认证）\n* DIGEST认证（摘要认证）\n* SSL客户端认证\n* FormBase认证（基于表单的认证）\n\n### BASIC认证\n\n基本步骤\n\n1. 请求的资源需要BASIC认证时，服务器返回401，告知客户端需要认证信息\n2. 客户端在接收到401后，将用户名和密码组成`username:password`形式，并进行Base64编码，然后以`BASIC <编码后的字符串>`形式赋给请求头的\nAuthorization字段，然后再发送给服务器\n3. 服务器收到验证信息后，进行验证，如果验证通过，则返回200，并返回相应的资源\n\nBase64并非真正的加密，如果具有BASIC认证的请求被窃听，用户名和密钥泄露的几率还是很大的\n\n### DIGEST认证\n\nDIGEST认证使用质询/响应的方式进行认证，但不会像BASIC认证那样明文传输密码。因此DIGEST认证的安全等级要高于BASIC认证。\n\n### SSL客户端认证\n\nSSL客户端认证是借由HTTPS的客户端证书完成认证的方式。\n\n### 基于表单的认证\n\n表单认证即我们通常用的在网页上输入密码和账号的认证方式\n\n基本步骤：\n\n1. 客户端将用户填写的用户名和密码（会做加密处理）发送给服务器，通常使用POST请求\n2. 服务器在接收到用户名和密码后，会去和已经登录在服务器上的用户名和密码做匹配，如果匹配通过，则服务器会在Set-Cookie字段中加入用以\n识别用户的SessionID\n3. 客户端接收到SessionID会将其作为Cookie保存在本地，下次发送请求时会自动带上Cookie字段，这样服务器就能识别用户身份，不用重新登录认证了\n\n## 第九章 基于HTTP的功能追加协议\n\n随着时代的发展，HTTP协议上的限制和自身性能有限的缺点越来越明显，因此产生许多基于HTTP协议的功能追加协议\n\n### 消除HTTP瓶颈的SPDY\n\nGoogle发布了SPDY，旨在消除HTTP的性能瓶颈。\n\n**HTTP协议的瓶颈**\n\n1. 一条连接上只可以发送一个请求\n2. 请求只能从客户端开始，客户端不可以接收除响应以外的任何指令\n3. 请求/响应未经压缩就发送，首部信息越多延迟越大\n4. 每次互相发送相同的首部造成浪费\n5. 可任意选择数据压缩格式，非强制压缩发送\n\n**解决方式**\n\n* Ajax（异步Javascript与XML技术）的解决方法\n    * 只更新一部分页面，因此传输的数据量大大减少\n    * Ajax仍未解决HTTP协议本身存在的问题\n* Comet的解决方式\n    * 一旦服务器有内容更新，Comet不会让请求等待，而是直接给客户端返回响应，这是一种延迟应答，模拟实现服务器向客户端推送的功能\n    * 客户端发送请求后，不会立即得到响应，相应的请求会在服务器挂起，等到有内容更新时，响应才会返回客户端\n    * 服务器为了维持链接会消耗更多资源\n* SPDY的目标\n    * 从协议层面消除HTTP的瓶颈\n\n### SPDY的设计与功能\n\nSPDY没有完全改写HTTP协议，而是在TCP和HTTP之间加入了一个会话层。SPDY的功能\n\n* **多路复用** 单一的TCP链接可以处理多个HTTP请求\n* **赋予请求优先级** 给请求追加优先级，解决因带宽低而导致响应变慢的问题\n* **压缩HTTP首部**\n* **推送功能** 支持服务器主动向客户端推送数据的功能\n* **服务器提示功能** 服务器可主动提示客户端请求所需的资源\n\n### 使用浏览器进行双工通信的WebSocket\n\n一旦建立WebSocket链接，不论是服务器还是客户端，任何一方都可以直接向对方发送报文。\n\nWebSocket的特定：\n\n* 推送功能\n* 减少通信量，WebSocket的首部信息量很少\n\n### HTTP2.0\n\n## 第十章 构建Web内容的技术\n\n* HTML\n* CSS\n* 动态HTML\n* Web应用\n* XML\n* JSON\n\n## 第十一章 Web的攻击技术\n\n### 针对Web的攻击技术\n\n攻击模式\n\n* 主动攻击：SQL注入，OS命令注入\n* 被动攻击：\n\n攻击方式\n\n* 跨站脚本攻击\n* SQL注入攻击\n* OS命令注入攻击\n* HTTP首部注入攻击\n* 邮件首部注入攻击\n* 目录遍历攻击\n* 远程文件包含漏洞\n...\n\n\n\n\n-\n","source":"_posts/2015-10-07-《图解HTTP》读书笔记(3).md","raw":"---\nlayout: post\ntitle: \"《图解HTTP》读书笔记(3)\"\ncategories: \"读书笔记\"\n---\n\n* toc\n{:toc}\n\n## 第八章 确认访问身份的认证\n\n### 何为认证\n\n**认证** 即为了弄清坐在电脑前的用户的真实身份，需要对用户的信息进行核实的过程\n\n常见的几种认证方式：\n\n* BASIC认证（基本认证）\n* DIGEST认证（摘要认证）\n* SSL客户端认证\n* FormBase认证（基于表单的认证）\n\n### BASIC认证\n\n基本步骤\n\n1. 请求的资源需要BASIC认证时，服务器返回401，告知客户端需要认证信息\n2. 客户端在接收到401后，将用户名和密码组成`username:password`形式，并进行Base64编码，然后以`BASIC <编码后的字符串>`形式赋给请求头的\nAuthorization字段，然后再发送给服务器\n3. 服务器收到验证信息后，进行验证，如果验证通过，则返回200，并返回相应的资源\n\nBase64并非真正的加密，如果具有BASIC认证的请求被窃听，用户名和密钥泄露的几率还是很大的\n\n### DIGEST认证\n\nDIGEST认证使用质询/响应的方式进行认证，但不会像BASIC认证那样明文传输密码。因此DIGEST认证的安全等级要高于BASIC认证。\n\n### SSL客户端认证\n\nSSL客户端认证是借由HTTPS的客户端证书完成认证的方式。\n\n### 基于表单的认证\n\n表单认证即我们通常用的在网页上输入密码和账号的认证方式\n\n基本步骤：\n\n1. 客户端将用户填写的用户名和密码（会做加密处理）发送给服务器，通常使用POST请求\n2. 服务器在接收到用户名和密码后，会去和已经登录在服务器上的用户名和密码做匹配，如果匹配通过，则服务器会在Set-Cookie字段中加入用以\n识别用户的SessionID\n3. 客户端接收到SessionID会将其作为Cookie保存在本地，下次发送请求时会自动带上Cookie字段，这样服务器就能识别用户身份，不用重新登录认证了\n\n## 第九章 基于HTTP的功能追加协议\n\n随着时代的发展，HTTP协议上的限制和自身性能有限的缺点越来越明显，因此产生许多基于HTTP协议的功能追加协议\n\n### 消除HTTP瓶颈的SPDY\n\nGoogle发布了SPDY，旨在消除HTTP的性能瓶颈。\n\n**HTTP协议的瓶颈**\n\n1. 一条连接上只可以发送一个请求\n2. 请求只能从客户端开始，客户端不可以接收除响应以外的任何指令\n3. 请求/响应未经压缩就发送，首部信息越多延迟越大\n4. 每次互相发送相同的首部造成浪费\n5. 可任意选择数据压缩格式，非强制压缩发送\n\n**解决方式**\n\n* Ajax（异步Javascript与XML技术）的解决方法\n    * 只更新一部分页面，因此传输的数据量大大减少\n    * Ajax仍未解决HTTP协议本身存在的问题\n* Comet的解决方式\n    * 一旦服务器有内容更新，Comet不会让请求等待，而是直接给客户端返回响应，这是一种延迟应答，模拟实现服务器向客户端推送的功能\n    * 客户端发送请求后，不会立即得到响应，相应的请求会在服务器挂起，等到有内容更新时，响应才会返回客户端\n    * 服务器为了维持链接会消耗更多资源\n* SPDY的目标\n    * 从协议层面消除HTTP的瓶颈\n\n### SPDY的设计与功能\n\nSPDY没有完全改写HTTP协议，而是在TCP和HTTP之间加入了一个会话层。SPDY的功能\n\n* **多路复用** 单一的TCP链接可以处理多个HTTP请求\n* **赋予请求优先级** 给请求追加优先级，解决因带宽低而导致响应变慢的问题\n* **压缩HTTP首部**\n* **推送功能** 支持服务器主动向客户端推送数据的功能\n* **服务器提示功能** 服务器可主动提示客户端请求所需的资源\n\n### 使用浏览器进行双工通信的WebSocket\n\n一旦建立WebSocket链接，不论是服务器还是客户端，任何一方都可以直接向对方发送报文。\n\nWebSocket的特定：\n\n* 推送功能\n* 减少通信量，WebSocket的首部信息量很少\n\n### HTTP2.0\n\n## 第十章 构建Web内容的技术\n\n* HTML\n* CSS\n* 动态HTML\n* Web应用\n* XML\n* JSON\n\n## 第十一章 Web的攻击技术\n\n### 针对Web的攻击技术\n\n攻击模式\n\n* 主动攻击：SQL注入，OS命令注入\n* 被动攻击：\n\n攻击方式\n\n* 跨站脚本攻击\n* SQL注入攻击\n* OS命令注入攻击\n* HTTP首部注入攻击\n* 邮件首部注入攻击\n* 目录遍历攻击\n* 远程文件包含漏洞\n...\n\n\n\n\n-\n","slug":"《图解HTTP》读书笔记(3)","published":1,"date":"2015-10-06T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oaaj000ozrm0wugshho6","content":"<ul>\n<li>toc<br>{:toc}</li>\n</ul>\n<h2 id=\"第八章-确认访问身份的认证\"><a href=\"#第八章-确认访问身份的认证\" class=\"headerlink\" title=\"第八章 确认访问身份的认证\"></a>第八章 确认访问身份的认证</h2><h3 id=\"何为认证\"><a href=\"#何为认证\" class=\"headerlink\" title=\"何为认证\"></a>何为认证</h3><p><strong>认证</strong> 即为了弄清坐在电脑前的用户的真实身份，需要对用户的信息进行核实的过程</p>\n<p>常见的几种认证方式：</p>\n<ul>\n<li>BASIC认证（基本认证）</li>\n<li>DIGEST认证（摘要认证）</li>\n<li>SSL客户端认证</li>\n<li>FormBase认证（基于表单的认证）</li>\n</ul>\n<h3 id=\"BASIC认证\"><a href=\"#BASIC认证\" class=\"headerlink\" title=\"BASIC认证\"></a>BASIC认证</h3><p>基本步骤</p>\n<ol>\n<li>请求的资源需要BASIC认证时，服务器返回401，告知客户端需要认证信息</li>\n<li>客户端在接收到401后，将用户名和密码组成<code>username:password</code>形式，并进行Base64编码，然后以<code>BASIC &lt;编码后的字符串&gt;</code>形式赋给请求头的<br>Authorization字段，然后再发送给服务器</li>\n<li>服务器收到验证信息后，进行验证，如果验证通过，则返回200，并返回相应的资源</li>\n</ol>\n<p>Base64并非真正的加密，如果具有BASIC认证的请求被窃听，用户名和密钥泄露的几率还是很大的</p>\n<h3 id=\"DIGEST认证\"><a href=\"#DIGEST认证\" class=\"headerlink\" title=\"DIGEST认证\"></a>DIGEST认证</h3><p>DIGEST认证使用质询/响应的方式进行认证，但不会像BASIC认证那样明文传输密码。因此DIGEST认证的安全等级要高于BASIC认证。</p>\n<h3 id=\"SSL客户端认证\"><a href=\"#SSL客户端认证\" class=\"headerlink\" title=\"SSL客户端认证\"></a>SSL客户端认证</h3><p>SSL客户端认证是借由HTTPS的客户端证书完成认证的方式。</p>\n<h3 id=\"基于表单的认证\"><a href=\"#基于表单的认证\" class=\"headerlink\" title=\"基于表单的认证\"></a>基于表单的认证</h3><p>表单认证即我们通常用的在网页上输入密码和账号的认证方式</p>\n<p>基本步骤：</p>\n<ol>\n<li>客户端将用户填写的用户名和密码（会做加密处理）发送给服务器，通常使用POST请求</li>\n<li>服务器在接收到用户名和密码后，会去和已经登录在服务器上的用户名和密码做匹配，如果匹配通过，则服务器会在Set-Cookie字段中加入用以<br>识别用户的SessionID</li>\n<li>客户端接收到SessionID会将其作为Cookie保存在本地，下次发送请求时会自动带上Cookie字段，这样服务器就能识别用户身份，不用重新登录认证了</li>\n</ol>\n<h2 id=\"第九章-基于HTTP的功能追加协议\"><a href=\"#第九章-基于HTTP的功能追加协议\" class=\"headerlink\" title=\"第九章 基于HTTP的功能追加协议\"></a>第九章 基于HTTP的功能追加协议</h2><p>随着时代的发展，HTTP协议上的限制和自身性能有限的缺点越来越明显，因此产生许多基于HTTP协议的功能追加协议</p>\n<h3 id=\"消除HTTP瓶颈的SPDY\"><a href=\"#消除HTTP瓶颈的SPDY\" class=\"headerlink\" title=\"消除HTTP瓶颈的SPDY\"></a>消除HTTP瓶颈的SPDY</h3><p>Google发布了SPDY，旨在消除HTTP的性能瓶颈。</p>\n<p><strong>HTTP协议的瓶颈</strong></p>\n<ol>\n<li>一条连接上只可以发送一个请求</li>\n<li>请求只能从客户端开始，客户端不可以接收除响应以外的任何指令</li>\n<li>请求/响应未经压缩就发送，首部信息越多延迟越大</li>\n<li>每次互相发送相同的首部造成浪费</li>\n<li>可任意选择数据压缩格式，非强制压缩发送</li>\n</ol>\n<p><strong>解决方式</strong></p>\n<ul>\n<li>Ajax（异步Javascript与XML技术）的解决方法<ul>\n<li>只更新一部分页面，因此传输的数据量大大减少</li>\n<li>Ajax仍未解决HTTP协议本身存在的问题</li>\n</ul>\n</li>\n<li>Comet的解决方式<ul>\n<li>一旦服务器有内容更新，Comet不会让请求等待，而是直接给客户端返回响应，这是一种延迟应答，模拟实现服务器向客户端推送的功能</li>\n<li>客户端发送请求后，不会立即得到响应，相应的请求会在服务器挂起，等到有内容更新时，响应才会返回客户端</li>\n<li>服务器为了维持链接会消耗更多资源</li>\n</ul>\n</li>\n<li>SPDY的目标<ul>\n<li>从协议层面消除HTTP的瓶颈</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"SPDY的设计与功能\"><a href=\"#SPDY的设计与功能\" class=\"headerlink\" title=\"SPDY的设计与功能\"></a>SPDY的设计与功能</h3><p>SPDY没有完全改写HTTP协议，而是在TCP和HTTP之间加入了一个会话层。SPDY的功能</p>\n<ul>\n<li><strong>多路复用</strong> 单一的TCP链接可以处理多个HTTP请求</li>\n<li><strong>赋予请求优先级</strong> 给请求追加优先级，解决因带宽低而导致响应变慢的问题</li>\n<li><strong>压缩HTTP首部</strong></li>\n<li><strong>推送功能</strong> 支持服务器主动向客户端推送数据的功能</li>\n<li><strong>服务器提示功能</strong> 服务器可主动提示客户端请求所需的资源</li>\n</ul>\n<h3 id=\"使用浏览器进行双工通信的WebSocket\"><a href=\"#使用浏览器进行双工通信的WebSocket\" class=\"headerlink\" title=\"使用浏览器进行双工通信的WebSocket\"></a>使用浏览器进行双工通信的WebSocket</h3><p>一旦建立WebSocket链接，不论是服务器还是客户端，任何一方都可以直接向对方发送报文。</p>\n<p>WebSocket的特定：</p>\n<ul>\n<li>推送功能</li>\n<li>减少通信量，WebSocket的首部信息量很少</li>\n</ul>\n<h3 id=\"HTTP2-0\"><a href=\"#HTTP2-0\" class=\"headerlink\" title=\"HTTP2.0\"></a>HTTP2.0</h3><h2 id=\"第十章-构建Web内容的技术\"><a href=\"#第十章-构建Web内容的技术\" class=\"headerlink\" title=\"第十章 构建Web内容的技术\"></a>第十章 构建Web内容的技术</h2><ul>\n<li>HTML</li>\n<li>CSS</li>\n<li>动态HTML</li>\n<li>Web应用</li>\n<li>XML</li>\n<li>JSON</li>\n</ul>\n<h2 id=\"第十一章-Web的攻击技术\"><a href=\"#第十一章-Web的攻击技术\" class=\"headerlink\" title=\"第十一章 Web的攻击技术\"></a>第十一章 Web的攻击技术</h2><h3 id=\"针对Web的攻击技术\"><a href=\"#针对Web的攻击技术\" class=\"headerlink\" title=\"针对Web的攻击技术\"></a>针对Web的攻击技术</h3><p>攻击模式</p>\n<ul>\n<li>主动攻击：SQL注入，OS命令注入</li>\n<li>被动攻击：</li>\n</ul>\n<p>攻击方式</p>\n<ul>\n<li>跨站脚本攻击</li>\n<li>SQL注入攻击</li>\n<li>OS命令注入攻击</li>\n<li>HTTP首部注入攻击</li>\n<li>邮件首部注入攻击</li>\n<li>目录遍历攻击</li>\n<li>远程文件包含漏洞<br>…</li>\n</ul>\n<p>-</p>\n","excerpt":"","more":"<ul>\n<li>toc<br>{:toc}</li>\n</ul>\n<h2 id=\"第八章-确认访问身份的认证\"><a href=\"#第八章-确认访问身份的认证\" class=\"headerlink\" title=\"第八章 确认访问身份的认证\"></a>第八章 确认访问身份的认证</h2><h3 id=\"何为认证\"><a href=\"#何为认证\" class=\"headerlink\" title=\"何为认证\"></a>何为认证</h3><p><strong>认证</strong> 即为了弄清坐在电脑前的用户的真实身份，需要对用户的信息进行核实的过程</p>\n<p>常见的几种认证方式：</p>\n<ul>\n<li>BASIC认证（基本认证）</li>\n<li>DIGEST认证（摘要认证）</li>\n<li>SSL客户端认证</li>\n<li>FormBase认证（基于表单的认证）</li>\n</ul>\n<h3 id=\"BASIC认证\"><a href=\"#BASIC认证\" class=\"headerlink\" title=\"BASIC认证\"></a>BASIC认证</h3><p>基本步骤</p>\n<ol>\n<li>请求的资源需要BASIC认证时，服务器返回401，告知客户端需要认证信息</li>\n<li>客户端在接收到401后，将用户名和密码组成<code>username:password</code>形式，并进行Base64编码，然后以<code>BASIC &lt;编码后的字符串&gt;</code>形式赋给请求头的<br>Authorization字段，然后再发送给服务器</li>\n<li>服务器收到验证信息后，进行验证，如果验证通过，则返回200，并返回相应的资源</li>\n</ol>\n<p>Base64并非真正的加密，如果具有BASIC认证的请求被窃听，用户名和密钥泄露的几率还是很大的</p>\n<h3 id=\"DIGEST认证\"><a href=\"#DIGEST认证\" class=\"headerlink\" title=\"DIGEST认证\"></a>DIGEST认证</h3><p>DIGEST认证使用质询/响应的方式进行认证，但不会像BASIC认证那样明文传输密码。因此DIGEST认证的安全等级要高于BASIC认证。</p>\n<h3 id=\"SSL客户端认证\"><a href=\"#SSL客户端认证\" class=\"headerlink\" title=\"SSL客户端认证\"></a>SSL客户端认证</h3><p>SSL客户端认证是借由HTTPS的客户端证书完成认证的方式。</p>\n<h3 id=\"基于表单的认证\"><a href=\"#基于表单的认证\" class=\"headerlink\" title=\"基于表单的认证\"></a>基于表单的认证</h3><p>表单认证即我们通常用的在网页上输入密码和账号的认证方式</p>\n<p>基本步骤：</p>\n<ol>\n<li>客户端将用户填写的用户名和密码（会做加密处理）发送给服务器，通常使用POST请求</li>\n<li>服务器在接收到用户名和密码后，会去和已经登录在服务器上的用户名和密码做匹配，如果匹配通过，则服务器会在Set-Cookie字段中加入用以<br>识别用户的SessionID</li>\n<li>客户端接收到SessionID会将其作为Cookie保存在本地，下次发送请求时会自动带上Cookie字段，这样服务器就能识别用户身份，不用重新登录认证了</li>\n</ol>\n<h2 id=\"第九章-基于HTTP的功能追加协议\"><a href=\"#第九章-基于HTTP的功能追加协议\" class=\"headerlink\" title=\"第九章 基于HTTP的功能追加协议\"></a>第九章 基于HTTP的功能追加协议</h2><p>随着时代的发展，HTTP协议上的限制和自身性能有限的缺点越来越明显，因此产生许多基于HTTP协议的功能追加协议</p>\n<h3 id=\"消除HTTP瓶颈的SPDY\"><a href=\"#消除HTTP瓶颈的SPDY\" class=\"headerlink\" title=\"消除HTTP瓶颈的SPDY\"></a>消除HTTP瓶颈的SPDY</h3><p>Google发布了SPDY，旨在消除HTTP的性能瓶颈。</p>\n<p><strong>HTTP协议的瓶颈</strong></p>\n<ol>\n<li>一条连接上只可以发送一个请求</li>\n<li>请求只能从客户端开始，客户端不可以接收除响应以外的任何指令</li>\n<li>请求/响应未经压缩就发送，首部信息越多延迟越大</li>\n<li>每次互相发送相同的首部造成浪费</li>\n<li>可任意选择数据压缩格式，非强制压缩发送</li>\n</ol>\n<p><strong>解决方式</strong></p>\n<ul>\n<li>Ajax（异步Javascript与XML技术）的解决方法<ul>\n<li>只更新一部分页面，因此传输的数据量大大减少</li>\n<li>Ajax仍未解决HTTP协议本身存在的问题</li>\n</ul>\n</li>\n<li>Comet的解决方式<ul>\n<li>一旦服务器有内容更新，Comet不会让请求等待，而是直接给客户端返回响应，这是一种延迟应答，模拟实现服务器向客户端推送的功能</li>\n<li>客户端发送请求后，不会立即得到响应，相应的请求会在服务器挂起，等到有内容更新时，响应才会返回客户端</li>\n<li>服务器为了维持链接会消耗更多资源</li>\n</ul>\n</li>\n<li>SPDY的目标<ul>\n<li>从协议层面消除HTTP的瓶颈</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"SPDY的设计与功能\"><a href=\"#SPDY的设计与功能\" class=\"headerlink\" title=\"SPDY的设计与功能\"></a>SPDY的设计与功能</h3><p>SPDY没有完全改写HTTP协议，而是在TCP和HTTP之间加入了一个会话层。SPDY的功能</p>\n<ul>\n<li><strong>多路复用</strong> 单一的TCP链接可以处理多个HTTP请求</li>\n<li><strong>赋予请求优先级</strong> 给请求追加优先级，解决因带宽低而导致响应变慢的问题</li>\n<li><strong>压缩HTTP首部</strong></li>\n<li><strong>推送功能</strong> 支持服务器主动向客户端推送数据的功能</li>\n<li><strong>服务器提示功能</strong> 服务器可主动提示客户端请求所需的资源</li>\n</ul>\n<h3 id=\"使用浏览器进行双工通信的WebSocket\"><a href=\"#使用浏览器进行双工通信的WebSocket\" class=\"headerlink\" title=\"使用浏览器进行双工通信的WebSocket\"></a>使用浏览器进行双工通信的WebSocket</h3><p>一旦建立WebSocket链接，不论是服务器还是客户端，任何一方都可以直接向对方发送报文。</p>\n<p>WebSocket的特定：</p>\n<ul>\n<li>推送功能</li>\n<li>减少通信量，WebSocket的首部信息量很少</li>\n</ul>\n<h3 id=\"HTTP2-0\"><a href=\"#HTTP2-0\" class=\"headerlink\" title=\"HTTP2.0\"></a>HTTP2.0</h3><h2 id=\"第十章-构建Web内容的技术\"><a href=\"#第十章-构建Web内容的技术\" class=\"headerlink\" title=\"第十章 构建Web内容的技术\"></a>第十章 构建Web内容的技术</h2><ul>\n<li>HTML</li>\n<li>CSS</li>\n<li>动态HTML</li>\n<li>Web应用</li>\n<li>XML</li>\n<li>JSON</li>\n</ul>\n<h2 id=\"第十一章-Web的攻击技术\"><a href=\"#第十一章-Web的攻击技术\" class=\"headerlink\" title=\"第十一章 Web的攻击技术\"></a>第十一章 Web的攻击技术</h2><h3 id=\"针对Web的攻击技术\"><a href=\"#针对Web的攻击技术\" class=\"headerlink\" title=\"针对Web的攻击技术\"></a>针对Web的攻击技术</h3><p>攻击模式</p>\n<ul>\n<li>主动攻击：SQL注入，OS命令注入</li>\n<li>被动攻击：</li>\n</ul>\n<p>攻击方式</p>\n<ul>\n<li>跨站脚本攻击</li>\n<li>SQL注入攻击</li>\n<li>OS命令注入攻击</li>\n<li>HTTP首部注入攻击</li>\n<li>邮件首部注入攻击</li>\n<li>目录遍历攻击</li>\n<li>远程文件包含漏洞<br>…</li>\n</ul>\n<p>-</p>\n"},{"layout":"post","title":"《图解HTTP》读书笔记(2)","_content":"\n* toc\n{:toc}\n\n## 第三章 HTTP报文内的HTTP信息\n\n### HTTP报文\n\nHTTP报文分为请求报文和响应报文两种，主要是由报文首部和报文主体两部分组成。\n\n### 编码提升传输速率\n\n为了提升传输速率，HTTP协议通常会对要传输的实体进行压缩，即内容编码。\n内容编码致指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。常见的编码有：\n\n* gzip (GNU zip)\n* compress (UNIX系统标准压缩)\n* deflate (zlib)\n* identity (不进行编码)\n\n**分块编码** 对于实体数据过大时，通常会把实体数据进行分块传输。分块编码会将实体主体分成多个部分快，客户端在接收到之后自行解码拼接。\n\n### 发送多种数据类型\n\n一个HTTP请求中可能还有文字，图片，视频等多种不同的数据类型，HTTP协议通过多部分对象集合，使得一份报文中可以含有多类型实体。通常实在上传图片或文本时使用。\n\n多部分对象集合包含的对象：\n\n* multipart/form-data : 表单文件上传\n* multipart/byteranges : 状态码为206，响应报文中包含了多个范围的内容\n\n多部分对象集合中的每个部分都含有首部字段，另外，还可以在某个部分中嵌套使用对象集合。\n\n### 获取部分内容的范围请求\n\n执行范围请求，需要在首部加上Range字段，例如\n\n* `Range: bytes=500-1000`，表示只请求500-1000的字节范围的数据。\n* `Range: bytes=1000-`，表示请求1000字节以后的全部数据\n* `Range: bytes=-300, 500-1000`，表示请求0-300和500-1000两部分数据\n\n请求成功，服务器会返回`206 Partial Content`状态码，表示请求部分数据成功，如何数据已经全部请求完成，则返回200\n\n例如：一个资源大小为200 bytes，HTTP请求的Range字段为`Range: bytes=-300`，则一次请求就可以请求到全部数据，因此返回200，不会返回206\n\n范围请求通常用于断点下载等操作。\n\n### 内容协商返回最合适的内容\n\n同一个页面服务器可能存在多份，比如英文页面，中文页面等。服务器会根据请求报文中的某些字段（语言，字符集，编码方式等）作为判断基准，返回最合适的页面。\n\n相关的首部字段有\n\n* Accept\n* Accept-Charset\n* Accept-Encoding\n* Accept-Language\n* Content-Language\n\n## 第四章 返回结果的HTTP状态码\n\n状态码的职责是当客户端发送请求时，描述返回的请求结果。状态码和状态不一致的现象也很常见。\n\n### 2XX OK\n\n* **200 OK** 正常处理，HEAD请求成功，不返回内容实体，状态码也是200\n* **204 No Content** 请求已处理成功，但没有资源返回\n* **206 Partial Content** 请求成功，返回资源的某一部分\n\n### 3XX 重定向\n\n* **301 Moved Permanently** 永久重定向，资源的URI已经更新\n* **302 Found** 临时重定向，URI已经更新，希望本次使用新的URI进行请求\n* **303 See Other** 资源的URI已经更新，请使用GET方法从新的URI获取资源。302和303功能类似，但303明确告诉客户端应该使用GET方法请求另一个URI。实际应用中，当301，302，303状态码返回时，几乎所有的浏览器都会把POST改为GET，\n然后重新请求。\n* **304 Not Modified** 资源已找到，但未符合条件请求。**条件请求** 是指在首部添加`If-Match, If-Modified-Since, If-None-Match,If-Range,-IfUnmodified-Since`\n中的任何一个\n* **307 TemporaryRedirect** 临时重定向。与302有相同的含义。\n\n### 4XX 客户端错误\n\n* **400 Bad Request** 请求报文中存在语法错误，服务器无法理解。\n* **401 Unauthorized** 发送的请求需要通过HTTP认证。当浏览器接受到401时，会弹出认证窗口，让用户填写用户名和密码\n* **403 Forbidden** 不允许访问该资源\n* **404 Not Found** 没有找到请求的资源\n\n### 5XX 服务器错误\n\n* **500 Internal Server Error** 服务器发生错误\n* **503 Service Unavailable** 表示服务器暂时处于超负载或正在停机维护，现在无法处理请求。\n\n## 第五章 与HTTP协作的Web服务器\n\n### 用单台虚拟主机实现多个域名\n\n同一台服务器可以搭建多个Web站点，这是利用了虚拟主机的功能。但是这就会导致多个域名在经过DNS解析后映射到了同一个IP地址。为了确定到底是访问那个域名，\nHTTP请求中，必须在首部的Host字段完整的指定主机名或域名的URI\n\n### 通信数据转发程序：代理，网关，隧道\n\n* **代理**：代理是一种有转发功能的应用程序，他接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端\n    * 代理不会改变请求的URI，会直接发送给前方持有资源的目标服务器，即源服务器。\n    * 在HTTP请求中可以级联多台代理服务器\n    * 代理服务器的用途：\n        * 利用缓存技术减少网络带宽流量\n        * 组织内部针对特定网站的访问控制\n    * 代理的种类\n        * 缓存代理：将源服务器的资源副本保存在代理服务器上，这样当代理再次接到相同的请求是，就不需要从源服务器那里再次获取资源了\n        * 透明代理和非透明代理：不对报文进行加工，成为透明代理，否则成为非透明代理\n* **网关**：转发其他服务器通信数据的服务器\n    * 网关与代理类似，但它可以提供非HTTP服务，即经过网关可以向非HTTP服务器请求数据\n    * 利用网关能提高通信的安全性\n* **隧道**：在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序\n    * 隧道可按要求建立起一条与其他服务器的通信线路，届时可以使用SSL等加密手段进行通信。\n    * 隧道的目的是确保通信的安全性\n    * 隧道本身不会解析HTTP请求，不会到HTTP请求进行修改\n\n### 保存资源的缓存\n\n缓存是指资源的副本，利用缓存可以减少对源服务器的访问，从而节省通信流量和通信时间。\n\n缓存服务器是代理服务器的一种，用于实现缓存。除了缓存服务器外，也可以包缓存保存在客户端的浏览器中。缓存都是有有效期的，\n过了有效期就应该重新向源服务器请求最新的资源。\n\n## 第六章 HTTP首部\n\n### HTTP报文首部字段\n\n* 字段结构：`首部字段名:字段值`，例如`Content-Type: text/html`，单个字段也可以有多个只，例如`Keep-Alive: timeout=15, max=10`\n* 如果首部字段重复，即出现两个同名的字段，则有的浏览器处理第一次出现的字段，有的浏览器处理最后一次出现的首部字段，这个在规范中没有明确指出。\n* 4种HTTP首部字段类型\n    * 通用首部字段：请求报文和响应报文都会使用的字段\n    * 请求首部字段：请求报文中使用的首部字段\n    * 响应首部字段：响应报文中使用的首部字段\n    * 实体首部字段：实体部分使用的首部字段\n\n### 通用首部字段\n\n* Cache-Control：指定缓存的工作机制\n* Connection：控制不在转发给代理的首部字段，管理持久链接\n* Date：表明创建HTTP报文的时间\n* Pragma：指定是否允许代理服务器返回缓存资源，这是历史遗留字段，\n* Trailer：说明在报文主体后会记录哪些首部字段，应用于分块传输编码\n* Transfer-Encoding：规定了传输报文主体时采用的编码方式\n* Upgrade：用于检测HTTP协议及其他协议是否可使用更高版本进行通信，该字段仅限于客户端与邻接服务器，因此需要在Connection中指定Upgrade\n* Via：追踪客户端与服务器之间请求和响应的传输路径\n* Warning：告知用于一些与缓存相关的问题的警告\n*\n\n### 请求首部字段\n\n* Accept：通知服务器应该返回的资源类型以及类型的优先级，格式为`type/subtype`，例如`text/html, image/jpeg`\n* Accept-Charset：通知服务器客户端支持的字符集及优先级\n* Accept-Encoding：通知服务器客户端支持的内容编码及优先级\n* Accept-Language：通知服务器客户端支持的语言及优先级\n* Authorization：客户端的认证信息\n* Form：告知服务器客户端的用户的电子邮箱地址，也可把电子邮箱记录在User-Agent中\n* Host：告知服务器资源所处的主机名和端口号\n* If-Match：告知服务器匹配资源所有的实体标记(ETag)，只有资源的ETag与该字段值匹配，服务器才会返回请求，否则返回412\n* If-Modified-Since：指定更新日期，如果在指定的日期之后资源有更新，则服务器处理请求，返回资源，否则返回304\n* If-None-Match：与If-Match相反，只有资源的ETag与该字段值不匹配，服务器才会返回请求，否则返回412\n* If-Range：告知服务器若If-Range的字段值（ETag或时间）和请求资源的ETag值或时间相一致时，作为范围请求处理，否则返回全体资源\n* If-Unmodified-Since：与If-Modified-Since相反，如果在指定的日期之后资源无更新，则服务器处理请求，返回资源，否则返回412\n* Max-Forwards：指定可经过的服务器最大数目，\n* Proxy-Authorization：代理认证信息，与Authorization不同之处在于他是客户端与代理服务器之间的认证，而Authorization是客户端与源服务器之间的认证信息\n* Range：请求资源的范围\n* Referer：告知服务器请求的原始资源的URI\n* TE：告知服务器客户端能够处理的响应的编码方式及优先级\n* User-Agent：告知服务器浏览器的种类和用户名称等信息\n\n### 响应首部字段\n\n* Accept-Range：告知客户端服务器是否能处理范围请求，可以处理则字段值为bytes，反之则为none\n* Age：告知客户端该响应是在多久前创建的，如果是缓存服务器，则必须加上Age字段，告知客户端该资源是多久前从源服务器获取的\n* ETag：告知客户端实体的标识\n    * 强ETag值：无论实体发生多么细微的变化，都会改变ETag的值\n    * 弱ETag值：只有资源发生根本改变，产生差异时才会改变ETag值\n* Location：告知客户端重定向的地址\n* Proxy-Authenticate：告知客户端适用于代理服务器的认证方案\n* Retry-After：告知客户端多久之后再次发送请求，主要配合503响应或3XX响应\n* Server：告知客户端HTTP服务器的应用程序信息\n* Vary：源服务器告知代理服务器，必须具有同Vary指定的字段相同的同的值的请求才能直接返回缓存，否则必须从源服务器上获取资源\n* WWW-Authenticate：告知客户端适用于服务器的认证方案\n\n### 实体首部字段\n\n* Allow：告知客户端服务器能够支持的所有HTTP方法\n* Content-Encoding：告知客户端服务器对实体的主体部分选用的编码方式\n* Content-Language：告知客户端实体主体使用的自然语言\n* Content-Length：告知客户端实体主体的大小（字节）\n* Content-Location：报文主体返回资源对应的URI\n* Content-MD5：报文主体部分的MD5值，用于校验主体部分是否完整\n* Content-Range：告知客户端返回的实体是整个资源的那一部分，格式`500-1000/1000`\n* Content-Type：说明实体内对象的类型\n* Expires：告知客户端或代理服务器资源失效的日期\n* Last-Modified：指明资源最终修改的时间\n\n### 为Cookie服务器的首部字段\n\n* Set-Cookie：告知客户端各种状态信息以及Cookie的设置信息\n* Cookie：告知服务器当前客户端的各种状态信息\n\n### 其他首部字段\n\n* X-Frame-Options：控制网站内容在其他Web网站的Frame标签内显示的问题，可防止点击劫持攻击\n* X-XSS-Protection：控制浏览器XSS防护机制的开关\n* DNT：告知服务器客户端拒绝提供个人信息\n* P3P：让Web网站上的个人隐私变成一种仅供程序可理解的形式\n\n## 第七章 确保Web安全的HTTPS\n\n### HTTP的缺点\n\n* **通信使用明文可能会被窃听**\n    * TCP/IP是可能被窃听的网络\n    * 使用加密处理防止被窃听\n        * 通信加密：对整个通信线路加密，通过SSL或TSL加密HTTP的通信内容，与SSL组合使用的HTTP成为HTTPS（超文本传输安全协议）\n        * 内容加密：对实体内容加密，客户端服务器要有相应的加密和解密机制\n* **不验证通信方的身份就可能遭遇伪装**\n    * 任何人都可能发起请求\n    * 查明对手的证书\n        * SSL不仅提供加密处理，还使用了证书手段，用于确定对方的身份\n        * 证书由值得信任的第三方机构颁发，用于证明服务器和客户端是实际存在的\n* **无法证明报文完整性，可能已遭篡改**\n\n### HTTP+加密+认证+完整性保护=HTTPS\n\n* HTTP加上加密处理和认证以及完整性保护就是HTTPS\n* HTTPS是身披SSL外壳的HTTP\n    * HTTPS并非一种新的协议，只是HTTP通信接口部分用SSL和TLS协议代替而已\n    * SSL是独立于HTTP的协议，所以不光是HTTP协议，其他运行在应用层的协议也可以配合SSL协议使用，SSL是当今世界应用最为广泛的网络安全技术\n* 加密技术\n    * 共享密钥：即加密和解密使用同一个密钥的方式，也称为对称密钥加密\n        * 优点：速度快\n        * 缺点：密钥可能被劫持\n    * 公开密钥：使用两个密钥，公有密钥和私有密钥，公有密钥加密，私有密钥解密，又称为非对称加密\n        * 优点：安全性高，密钥不会被劫持\n        * 缺点：处理速度慢\n* HTTPS采用混合加密机制，即共享密钥和公开密钥混合的方式，一般情况下是使用公开密钥的方式传输共享密钥的密钥，当共享密钥的密钥被安全送达后，就可以\n使用共享密钥来加密普通数据。\n\n### 证明公开密钥正确性的证书\n\n* 问题：如何确保公开密钥中的共有密钥在传输过程中不被篡改\n* 解决方案：使用数字证书确保共有密钥的正确性\n* 基本流程：\n    1. 服务器从数字证书认证机构那里申请公钥证书，公钥证书包含服务器的公开密钥和数字证书认证机构的数字签名。\n    2. 申请到公钥证书之后把这份公钥证书发送给用户\n    3. 用户在拿到公钥证书后使用数字证书认证机构的公开密钥（一般浏览器都会内置常用认证机构的公开密钥）对证书进行验证\n    4. 一旦认证通过就表示公钥证书中的服务器公钥是真实可靠的。\n* 其他的一些概念\n    * EV SSL证书：用来证明服务器是否符合规范，服务器背后的运营企业是否真实存在的证书\n    * 客户端证书：用来证明客户端实际存在的证书\n    * 自签名证书：使用OpenSSL可以构建自己的证书认证机构，自己给自己颁发服务器证书，该证书一般不被浏览器信赖\n\n### HTTPS的安全通信机制\n\n* SSL和TLS：TLS是在SSL基础上开发的协议。\n* HTTPS会比相应的HTTP请求要慢，因为要做加密处理。所以除非敏感信息，否则一般情况下使用HTTP就可以了。\n","source":"_posts/2015-10-06-《图解HTTP》读书笔记(2).md","raw":"---\nlayout: post\ntitle: \"《图解HTTP》读书笔记(2)\"\ncategories: \"读书笔记\"\n---\n\n* toc\n{:toc}\n\n## 第三章 HTTP报文内的HTTP信息\n\n### HTTP报文\n\nHTTP报文分为请求报文和响应报文两种，主要是由报文首部和报文主体两部分组成。\n\n### 编码提升传输速率\n\n为了提升传输速率，HTTP协议通常会对要传输的实体进行压缩，即内容编码。\n内容编码致指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。常见的编码有：\n\n* gzip (GNU zip)\n* compress (UNIX系统标准压缩)\n* deflate (zlib)\n* identity (不进行编码)\n\n**分块编码** 对于实体数据过大时，通常会把实体数据进行分块传输。分块编码会将实体主体分成多个部分快，客户端在接收到之后自行解码拼接。\n\n### 发送多种数据类型\n\n一个HTTP请求中可能还有文字，图片，视频等多种不同的数据类型，HTTP协议通过多部分对象集合，使得一份报文中可以含有多类型实体。通常实在上传图片或文本时使用。\n\n多部分对象集合包含的对象：\n\n* multipart/form-data : 表单文件上传\n* multipart/byteranges : 状态码为206，响应报文中包含了多个范围的内容\n\n多部分对象集合中的每个部分都含有首部字段，另外，还可以在某个部分中嵌套使用对象集合。\n\n### 获取部分内容的范围请求\n\n执行范围请求，需要在首部加上Range字段，例如\n\n* `Range: bytes=500-1000`，表示只请求500-1000的字节范围的数据。\n* `Range: bytes=1000-`，表示请求1000字节以后的全部数据\n* `Range: bytes=-300, 500-1000`，表示请求0-300和500-1000两部分数据\n\n请求成功，服务器会返回`206 Partial Content`状态码，表示请求部分数据成功，如何数据已经全部请求完成，则返回200\n\n例如：一个资源大小为200 bytes，HTTP请求的Range字段为`Range: bytes=-300`，则一次请求就可以请求到全部数据，因此返回200，不会返回206\n\n范围请求通常用于断点下载等操作。\n\n### 内容协商返回最合适的内容\n\n同一个页面服务器可能存在多份，比如英文页面，中文页面等。服务器会根据请求报文中的某些字段（语言，字符集，编码方式等）作为判断基准，返回最合适的页面。\n\n相关的首部字段有\n\n* Accept\n* Accept-Charset\n* Accept-Encoding\n* Accept-Language\n* Content-Language\n\n## 第四章 返回结果的HTTP状态码\n\n状态码的职责是当客户端发送请求时，描述返回的请求结果。状态码和状态不一致的现象也很常见。\n\n### 2XX OK\n\n* **200 OK** 正常处理，HEAD请求成功，不返回内容实体，状态码也是200\n* **204 No Content** 请求已处理成功，但没有资源返回\n* **206 Partial Content** 请求成功，返回资源的某一部分\n\n### 3XX 重定向\n\n* **301 Moved Permanently** 永久重定向，资源的URI已经更新\n* **302 Found** 临时重定向，URI已经更新，希望本次使用新的URI进行请求\n* **303 See Other** 资源的URI已经更新，请使用GET方法从新的URI获取资源。302和303功能类似，但303明确告诉客户端应该使用GET方法请求另一个URI。实际应用中，当301，302，303状态码返回时，几乎所有的浏览器都会把POST改为GET，\n然后重新请求。\n* **304 Not Modified** 资源已找到，但未符合条件请求。**条件请求** 是指在首部添加`If-Match, If-Modified-Since, If-None-Match,If-Range,-IfUnmodified-Since`\n中的任何一个\n* **307 TemporaryRedirect** 临时重定向。与302有相同的含义。\n\n### 4XX 客户端错误\n\n* **400 Bad Request** 请求报文中存在语法错误，服务器无法理解。\n* **401 Unauthorized** 发送的请求需要通过HTTP认证。当浏览器接受到401时，会弹出认证窗口，让用户填写用户名和密码\n* **403 Forbidden** 不允许访问该资源\n* **404 Not Found** 没有找到请求的资源\n\n### 5XX 服务器错误\n\n* **500 Internal Server Error** 服务器发生错误\n* **503 Service Unavailable** 表示服务器暂时处于超负载或正在停机维护，现在无法处理请求。\n\n## 第五章 与HTTP协作的Web服务器\n\n### 用单台虚拟主机实现多个域名\n\n同一台服务器可以搭建多个Web站点，这是利用了虚拟主机的功能。但是这就会导致多个域名在经过DNS解析后映射到了同一个IP地址。为了确定到底是访问那个域名，\nHTTP请求中，必须在首部的Host字段完整的指定主机名或域名的URI\n\n### 通信数据转发程序：代理，网关，隧道\n\n* **代理**：代理是一种有转发功能的应用程序，他接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端\n    * 代理不会改变请求的URI，会直接发送给前方持有资源的目标服务器，即源服务器。\n    * 在HTTP请求中可以级联多台代理服务器\n    * 代理服务器的用途：\n        * 利用缓存技术减少网络带宽流量\n        * 组织内部针对特定网站的访问控制\n    * 代理的种类\n        * 缓存代理：将源服务器的资源副本保存在代理服务器上，这样当代理再次接到相同的请求是，就不需要从源服务器那里再次获取资源了\n        * 透明代理和非透明代理：不对报文进行加工，成为透明代理，否则成为非透明代理\n* **网关**：转发其他服务器通信数据的服务器\n    * 网关与代理类似，但它可以提供非HTTP服务，即经过网关可以向非HTTP服务器请求数据\n    * 利用网关能提高通信的安全性\n* **隧道**：在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序\n    * 隧道可按要求建立起一条与其他服务器的通信线路，届时可以使用SSL等加密手段进行通信。\n    * 隧道的目的是确保通信的安全性\n    * 隧道本身不会解析HTTP请求，不会到HTTP请求进行修改\n\n### 保存资源的缓存\n\n缓存是指资源的副本，利用缓存可以减少对源服务器的访问，从而节省通信流量和通信时间。\n\n缓存服务器是代理服务器的一种，用于实现缓存。除了缓存服务器外，也可以包缓存保存在客户端的浏览器中。缓存都是有有效期的，\n过了有效期就应该重新向源服务器请求最新的资源。\n\n## 第六章 HTTP首部\n\n### HTTP报文首部字段\n\n* 字段结构：`首部字段名:字段值`，例如`Content-Type: text/html`，单个字段也可以有多个只，例如`Keep-Alive: timeout=15, max=10`\n* 如果首部字段重复，即出现两个同名的字段，则有的浏览器处理第一次出现的字段，有的浏览器处理最后一次出现的首部字段，这个在规范中没有明确指出。\n* 4种HTTP首部字段类型\n    * 通用首部字段：请求报文和响应报文都会使用的字段\n    * 请求首部字段：请求报文中使用的首部字段\n    * 响应首部字段：响应报文中使用的首部字段\n    * 实体首部字段：实体部分使用的首部字段\n\n### 通用首部字段\n\n* Cache-Control：指定缓存的工作机制\n* Connection：控制不在转发给代理的首部字段，管理持久链接\n* Date：表明创建HTTP报文的时间\n* Pragma：指定是否允许代理服务器返回缓存资源，这是历史遗留字段，\n* Trailer：说明在报文主体后会记录哪些首部字段，应用于分块传输编码\n* Transfer-Encoding：规定了传输报文主体时采用的编码方式\n* Upgrade：用于检测HTTP协议及其他协议是否可使用更高版本进行通信，该字段仅限于客户端与邻接服务器，因此需要在Connection中指定Upgrade\n* Via：追踪客户端与服务器之间请求和响应的传输路径\n* Warning：告知用于一些与缓存相关的问题的警告\n*\n\n### 请求首部字段\n\n* Accept：通知服务器应该返回的资源类型以及类型的优先级，格式为`type/subtype`，例如`text/html, image/jpeg`\n* Accept-Charset：通知服务器客户端支持的字符集及优先级\n* Accept-Encoding：通知服务器客户端支持的内容编码及优先级\n* Accept-Language：通知服务器客户端支持的语言及优先级\n* Authorization：客户端的认证信息\n* Form：告知服务器客户端的用户的电子邮箱地址，也可把电子邮箱记录在User-Agent中\n* Host：告知服务器资源所处的主机名和端口号\n* If-Match：告知服务器匹配资源所有的实体标记(ETag)，只有资源的ETag与该字段值匹配，服务器才会返回请求，否则返回412\n* If-Modified-Since：指定更新日期，如果在指定的日期之后资源有更新，则服务器处理请求，返回资源，否则返回304\n* If-None-Match：与If-Match相反，只有资源的ETag与该字段值不匹配，服务器才会返回请求，否则返回412\n* If-Range：告知服务器若If-Range的字段值（ETag或时间）和请求资源的ETag值或时间相一致时，作为范围请求处理，否则返回全体资源\n* If-Unmodified-Since：与If-Modified-Since相反，如果在指定的日期之后资源无更新，则服务器处理请求，返回资源，否则返回412\n* Max-Forwards：指定可经过的服务器最大数目，\n* Proxy-Authorization：代理认证信息，与Authorization不同之处在于他是客户端与代理服务器之间的认证，而Authorization是客户端与源服务器之间的认证信息\n* Range：请求资源的范围\n* Referer：告知服务器请求的原始资源的URI\n* TE：告知服务器客户端能够处理的响应的编码方式及优先级\n* User-Agent：告知服务器浏览器的种类和用户名称等信息\n\n### 响应首部字段\n\n* Accept-Range：告知客户端服务器是否能处理范围请求，可以处理则字段值为bytes，反之则为none\n* Age：告知客户端该响应是在多久前创建的，如果是缓存服务器，则必须加上Age字段，告知客户端该资源是多久前从源服务器获取的\n* ETag：告知客户端实体的标识\n    * 强ETag值：无论实体发生多么细微的变化，都会改变ETag的值\n    * 弱ETag值：只有资源发生根本改变，产生差异时才会改变ETag值\n* Location：告知客户端重定向的地址\n* Proxy-Authenticate：告知客户端适用于代理服务器的认证方案\n* Retry-After：告知客户端多久之后再次发送请求，主要配合503响应或3XX响应\n* Server：告知客户端HTTP服务器的应用程序信息\n* Vary：源服务器告知代理服务器，必须具有同Vary指定的字段相同的同的值的请求才能直接返回缓存，否则必须从源服务器上获取资源\n* WWW-Authenticate：告知客户端适用于服务器的认证方案\n\n### 实体首部字段\n\n* Allow：告知客户端服务器能够支持的所有HTTP方法\n* Content-Encoding：告知客户端服务器对实体的主体部分选用的编码方式\n* Content-Language：告知客户端实体主体使用的自然语言\n* Content-Length：告知客户端实体主体的大小（字节）\n* Content-Location：报文主体返回资源对应的URI\n* Content-MD5：报文主体部分的MD5值，用于校验主体部分是否完整\n* Content-Range：告知客户端返回的实体是整个资源的那一部分，格式`500-1000/1000`\n* Content-Type：说明实体内对象的类型\n* Expires：告知客户端或代理服务器资源失效的日期\n* Last-Modified：指明资源最终修改的时间\n\n### 为Cookie服务器的首部字段\n\n* Set-Cookie：告知客户端各种状态信息以及Cookie的设置信息\n* Cookie：告知服务器当前客户端的各种状态信息\n\n### 其他首部字段\n\n* X-Frame-Options：控制网站内容在其他Web网站的Frame标签内显示的问题，可防止点击劫持攻击\n* X-XSS-Protection：控制浏览器XSS防护机制的开关\n* DNT：告知服务器客户端拒绝提供个人信息\n* P3P：让Web网站上的个人隐私变成一种仅供程序可理解的形式\n\n## 第七章 确保Web安全的HTTPS\n\n### HTTP的缺点\n\n* **通信使用明文可能会被窃听**\n    * TCP/IP是可能被窃听的网络\n    * 使用加密处理防止被窃听\n        * 通信加密：对整个通信线路加密，通过SSL或TSL加密HTTP的通信内容，与SSL组合使用的HTTP成为HTTPS（超文本传输安全协议）\n        * 内容加密：对实体内容加密，客户端服务器要有相应的加密和解密机制\n* **不验证通信方的身份就可能遭遇伪装**\n    * 任何人都可能发起请求\n    * 查明对手的证书\n        * SSL不仅提供加密处理，还使用了证书手段，用于确定对方的身份\n        * 证书由值得信任的第三方机构颁发，用于证明服务器和客户端是实际存在的\n* **无法证明报文完整性，可能已遭篡改**\n\n### HTTP+加密+认证+完整性保护=HTTPS\n\n* HTTP加上加密处理和认证以及完整性保护就是HTTPS\n* HTTPS是身披SSL外壳的HTTP\n    * HTTPS并非一种新的协议，只是HTTP通信接口部分用SSL和TLS协议代替而已\n    * SSL是独立于HTTP的协议，所以不光是HTTP协议，其他运行在应用层的协议也可以配合SSL协议使用，SSL是当今世界应用最为广泛的网络安全技术\n* 加密技术\n    * 共享密钥：即加密和解密使用同一个密钥的方式，也称为对称密钥加密\n        * 优点：速度快\n        * 缺点：密钥可能被劫持\n    * 公开密钥：使用两个密钥，公有密钥和私有密钥，公有密钥加密，私有密钥解密，又称为非对称加密\n        * 优点：安全性高，密钥不会被劫持\n        * 缺点：处理速度慢\n* HTTPS采用混合加密机制，即共享密钥和公开密钥混合的方式，一般情况下是使用公开密钥的方式传输共享密钥的密钥，当共享密钥的密钥被安全送达后，就可以\n使用共享密钥来加密普通数据。\n\n### 证明公开密钥正确性的证书\n\n* 问题：如何确保公开密钥中的共有密钥在传输过程中不被篡改\n* 解决方案：使用数字证书确保共有密钥的正确性\n* 基本流程：\n    1. 服务器从数字证书认证机构那里申请公钥证书，公钥证书包含服务器的公开密钥和数字证书认证机构的数字签名。\n    2. 申请到公钥证书之后把这份公钥证书发送给用户\n    3. 用户在拿到公钥证书后使用数字证书认证机构的公开密钥（一般浏览器都会内置常用认证机构的公开密钥）对证书进行验证\n    4. 一旦认证通过就表示公钥证书中的服务器公钥是真实可靠的。\n* 其他的一些概念\n    * EV SSL证书：用来证明服务器是否符合规范，服务器背后的运营企业是否真实存在的证书\n    * 客户端证书：用来证明客户端实际存在的证书\n    * 自签名证书：使用OpenSSL可以构建自己的证书认证机构，自己给自己颁发服务器证书，该证书一般不被浏览器信赖\n\n### HTTPS的安全通信机制\n\n* SSL和TLS：TLS是在SSL基础上开发的协议。\n* HTTPS会比相应的HTTP请求要慢，因为要做加密处理。所以除非敏感信息，否则一般情况下使用HTTP就可以了。\n","slug":"《图解HTTP》读书笔记(2)","published":1,"date":"2015-10-05T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oaam000rzrm06wjsvsdf","content":"<ul>\n<li>toc<br>{:toc}</li>\n</ul>\n<h2 id=\"第三章-HTTP报文内的HTTP信息\"><a href=\"#第三章-HTTP报文内的HTTP信息\" class=\"headerlink\" title=\"第三章 HTTP报文内的HTTP信息\"></a>第三章 HTTP报文内的HTTP信息</h2><h3 id=\"HTTP报文\"><a href=\"#HTTP报文\" class=\"headerlink\" title=\"HTTP报文\"></a>HTTP报文</h3><p>HTTP报文分为请求报文和响应报文两种，主要是由报文首部和报文主体两部分组成。</p>\n<h3 id=\"编码提升传输速率\"><a href=\"#编码提升传输速率\" class=\"headerlink\" title=\"编码提升传输速率\"></a>编码提升传输速率</h3><p>为了提升传输速率，HTTP协议通常会对要传输的实体进行压缩，即内容编码。<br>内容编码致指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。常见的编码有：</p>\n<ul>\n<li>gzip (GNU zip)</li>\n<li>compress (UNIX系统标准压缩)</li>\n<li>deflate (zlib)</li>\n<li>identity (不进行编码)</li>\n</ul>\n<p><strong>分块编码</strong> 对于实体数据过大时，通常会把实体数据进行分块传输。分块编码会将实体主体分成多个部分快，客户端在接收到之后自行解码拼接。</p>\n<h3 id=\"发送多种数据类型\"><a href=\"#发送多种数据类型\" class=\"headerlink\" title=\"发送多种数据类型\"></a>发送多种数据类型</h3><p>一个HTTP请求中可能还有文字，图片，视频等多种不同的数据类型，HTTP协议通过多部分对象集合，使得一份报文中可以含有多类型实体。通常实在上传图片或文本时使用。</p>\n<p>多部分对象集合包含的对象：</p>\n<ul>\n<li>multipart/form-data : 表单文件上传</li>\n<li>multipart/byteranges : 状态码为206，响应报文中包含了多个范围的内容</li>\n</ul>\n<p>多部分对象集合中的每个部分都含有首部字段，另外，还可以在某个部分中嵌套使用对象集合。</p>\n<h3 id=\"获取部分内容的范围请求\"><a href=\"#获取部分内容的范围请求\" class=\"headerlink\" title=\"获取部分内容的范围请求\"></a>获取部分内容的范围请求</h3><p>执行范围请求，需要在首部加上Range字段，例如</p>\n<ul>\n<li><code>Range: bytes=500-1000</code>，表示只请求500-1000的字节范围的数据。</li>\n<li><code>Range: bytes=1000-</code>，表示请求1000字节以后的全部数据</li>\n<li><code>Range: bytes=-300, 500-1000</code>，表示请求0-300和500-1000两部分数据</li>\n</ul>\n<p>请求成功，服务器会返回<code>206 Partial Content</code>状态码，表示请求部分数据成功，如何数据已经全部请求完成，则返回200</p>\n<p>例如：一个资源大小为200 bytes，HTTP请求的Range字段为<code>Range: bytes=-300</code>，则一次请求就可以请求到全部数据，因此返回200，不会返回206</p>\n<p>范围请求通常用于断点下载等操作。</p>\n<h3 id=\"内容协商返回最合适的内容\"><a href=\"#内容协商返回最合适的内容\" class=\"headerlink\" title=\"内容协商返回最合适的内容\"></a>内容协商返回最合适的内容</h3><p>同一个页面服务器可能存在多份，比如英文页面，中文页面等。服务器会根据请求报文中的某些字段（语言，字符集，编码方式等）作为判断基准，返回最合适的页面。</p>\n<p>相关的首部字段有</p>\n<ul>\n<li>Accept</li>\n<li>Accept-Charset</li>\n<li>Accept-Encoding</li>\n<li>Accept-Language</li>\n<li>Content-Language</li>\n</ul>\n<h2 id=\"第四章-返回结果的HTTP状态码\"><a href=\"#第四章-返回结果的HTTP状态码\" class=\"headerlink\" title=\"第四章 返回结果的HTTP状态码\"></a>第四章 返回结果的HTTP状态码</h2><p>状态码的职责是当客户端发送请求时，描述返回的请求结果。状态码和状态不一致的现象也很常见。</p>\n<h3 id=\"2XX-OK\"><a href=\"#2XX-OK\" class=\"headerlink\" title=\"2XX OK\"></a>2XX OK</h3><ul>\n<li><strong>200 OK</strong> 正常处理，HEAD请求成功，不返回内容实体，状态码也是200</li>\n<li><strong>204 No Content</strong> 请求已处理成功，但没有资源返回</li>\n<li><strong>206 Partial Content</strong> 请求成功，返回资源的某一部分</li>\n</ul>\n<h3 id=\"3XX-重定向\"><a href=\"#3XX-重定向\" class=\"headerlink\" title=\"3XX 重定向\"></a>3XX 重定向</h3><ul>\n<li><strong>301 Moved Permanently</strong> 永久重定向，资源的URI已经更新</li>\n<li><strong>302 Found</strong> 临时重定向，URI已经更新，希望本次使用新的URI进行请求</li>\n<li><strong>303 See Other</strong> 资源的URI已经更新，请使用GET方法从新的URI获取资源。302和303功能类似，但303明确告诉客户端应该使用GET方法请求另一个URI。实际应用中，当301，302，303状态码返回时，几乎所有的浏览器都会把POST改为GET，<br>然后重新请求。</li>\n<li><strong>304 Not Modified</strong> 资源已找到，但未符合条件请求。<strong>条件请求</strong> 是指在首部添加<code>If-Match, If-Modified-Since, If-None-Match,If-Range,-IfUnmodified-Since</code><br>中的任何一个</li>\n<li><strong>307 TemporaryRedirect</strong> 临时重定向。与302有相同的含义。</li>\n</ul>\n<h3 id=\"4XX-客户端错误\"><a href=\"#4XX-客户端错误\" class=\"headerlink\" title=\"4XX 客户端错误\"></a>4XX 客户端错误</h3><ul>\n<li><strong>400 Bad Request</strong> 请求报文中存在语法错误，服务器无法理解。</li>\n<li><strong>401 Unauthorized</strong> 发送的请求需要通过HTTP认证。当浏览器接受到401时，会弹出认证窗口，让用户填写用户名和密码</li>\n<li><strong>403 Forbidden</strong> 不允许访问该资源</li>\n<li><strong>404 Not Found</strong> 没有找到请求的资源</li>\n</ul>\n<h3 id=\"5XX-服务器错误\"><a href=\"#5XX-服务器错误\" class=\"headerlink\" title=\"5XX 服务器错误\"></a>5XX 服务器错误</h3><ul>\n<li><strong>500 Internal Server Error</strong> 服务器发生错误</li>\n<li><strong>503 Service Unavailable</strong> 表示服务器暂时处于超负载或正在停机维护，现在无法处理请求。</li>\n</ul>\n<h2 id=\"第五章-与HTTP协作的Web服务器\"><a href=\"#第五章-与HTTP协作的Web服务器\" class=\"headerlink\" title=\"第五章 与HTTP协作的Web服务器\"></a>第五章 与HTTP协作的Web服务器</h2><h3 id=\"用单台虚拟主机实现多个域名\"><a href=\"#用单台虚拟主机实现多个域名\" class=\"headerlink\" title=\"用单台虚拟主机实现多个域名\"></a>用单台虚拟主机实现多个域名</h3><p>同一台服务器可以搭建多个Web站点，这是利用了虚拟主机的功能。但是这就会导致多个域名在经过DNS解析后映射到了同一个IP地址。为了确定到底是访问那个域名，<br>HTTP请求中，必须在首部的Host字段完整的指定主机名或域名的URI</p>\n<h3 id=\"通信数据转发程序：代理，网关，隧道\"><a href=\"#通信数据转发程序：代理，网关，隧道\" class=\"headerlink\" title=\"通信数据转发程序：代理，网关，隧道\"></a>通信数据转发程序：代理，网关，隧道</h3><ul>\n<li><strong>代理</strong>：代理是一种有转发功能的应用程序，他接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端<ul>\n<li>代理不会改变请求的URI，会直接发送给前方持有资源的目标服务器，即源服务器。</li>\n<li>在HTTP请求中可以级联多台代理服务器</li>\n<li>代理服务器的用途：<ul>\n<li>利用缓存技术减少网络带宽流量</li>\n<li>组织内部针对特定网站的访问控制</li>\n</ul>\n</li>\n<li>代理的种类<ul>\n<li>缓存代理：将源服务器的资源副本保存在代理服务器上，这样当代理再次接到相同的请求是，就不需要从源服务器那里再次获取资源了</li>\n<li>透明代理和非透明代理：不对报文进行加工，成为透明代理，否则成为非透明代理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>网关</strong>：转发其他服务器通信数据的服务器<ul>\n<li>网关与代理类似，但它可以提供非HTTP服务，即经过网关可以向非HTTP服务器请求数据</li>\n<li>利用网关能提高通信的安全性</li>\n</ul>\n</li>\n<li><strong>隧道</strong>：在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序<ul>\n<li>隧道可按要求建立起一条与其他服务器的通信线路，届时可以使用SSL等加密手段进行通信。</li>\n<li>隧道的目的是确保通信的安全性</li>\n<li>隧道本身不会解析HTTP请求，不会到HTTP请求进行修改</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"保存资源的缓存\"><a href=\"#保存资源的缓存\" class=\"headerlink\" title=\"保存资源的缓存\"></a>保存资源的缓存</h3><p>缓存是指资源的副本，利用缓存可以减少对源服务器的访问，从而节省通信流量和通信时间。</p>\n<p>缓存服务器是代理服务器的一种，用于实现缓存。除了缓存服务器外，也可以包缓存保存在客户端的浏览器中。缓存都是有有效期的，<br>过了有效期就应该重新向源服务器请求最新的资源。</p>\n<h2 id=\"第六章-HTTP首部\"><a href=\"#第六章-HTTP首部\" class=\"headerlink\" title=\"第六章 HTTP首部\"></a>第六章 HTTP首部</h2><h3 id=\"HTTP报文首部字段\"><a href=\"#HTTP报文首部字段\" class=\"headerlink\" title=\"HTTP报文首部字段\"></a>HTTP报文首部字段</h3><ul>\n<li>字段结构：<code>首部字段名:字段值</code>，例如<code>Content-Type: text/html</code>，单个字段也可以有多个只，例如<code>Keep-Alive: timeout=15, max=10</code></li>\n<li>如果首部字段重复，即出现两个同名的字段，则有的浏览器处理第一次出现的字段，有的浏览器处理最后一次出现的首部字段，这个在规范中没有明确指出。</li>\n<li>4种HTTP首部字段类型<ul>\n<li>通用首部字段：请求报文和响应报文都会使用的字段</li>\n<li>请求首部字段：请求报文中使用的首部字段</li>\n<li>响应首部字段：响应报文中使用的首部字段</li>\n<li>实体首部字段：实体部分使用的首部字段</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"通用首部字段\"><a href=\"#通用首部字段\" class=\"headerlink\" title=\"通用首部字段\"></a>通用首部字段</h3><ul>\n<li>Cache-Control：指定缓存的工作机制</li>\n<li>Connection：控制不在转发给代理的首部字段，管理持久链接</li>\n<li>Date：表明创建HTTP报文的时间</li>\n<li>Pragma：指定是否允许代理服务器返回缓存资源，这是历史遗留字段，</li>\n<li>Trailer：说明在报文主体后会记录哪些首部字段，应用于分块传输编码</li>\n<li>Transfer-Encoding：规定了传输报文主体时采用的编码方式</li>\n<li>Upgrade：用于检测HTTP协议及其他协议是否可使用更高版本进行通信，该字段仅限于客户端与邻接服务器，因此需要在Connection中指定Upgrade</li>\n<li>Via：追踪客户端与服务器之间请求和响应的传输路径</li>\n<li>Warning：告知用于一些与缓存相关的问题的警告<br>*</li>\n</ul>\n<h3 id=\"请求首部字段\"><a href=\"#请求首部字段\" class=\"headerlink\" title=\"请求首部字段\"></a>请求首部字段</h3><ul>\n<li>Accept：通知服务器应该返回的资源类型以及类型的优先级，格式为<code>type/subtype</code>，例如<code>text/html, image/jpeg</code></li>\n<li>Accept-Charset：通知服务器客户端支持的字符集及优先级</li>\n<li>Accept-Encoding：通知服务器客户端支持的内容编码及优先级</li>\n<li>Accept-Language：通知服务器客户端支持的语言及优先级</li>\n<li>Authorization：客户端的认证信息</li>\n<li>Form：告知服务器客户端的用户的电子邮箱地址，也可把电子邮箱记录在User-Agent中</li>\n<li>Host：告知服务器资源所处的主机名和端口号</li>\n<li>If-Match：告知服务器匹配资源所有的实体标记(ETag)，只有资源的ETag与该字段值匹配，服务器才会返回请求，否则返回412</li>\n<li>If-Modified-Since：指定更新日期，如果在指定的日期之后资源有更新，则服务器处理请求，返回资源，否则返回304</li>\n<li>If-None-Match：与If-Match相反，只有资源的ETag与该字段值不匹配，服务器才会返回请求，否则返回412</li>\n<li>If-Range：告知服务器若If-Range的字段值（ETag或时间）和请求资源的ETag值或时间相一致时，作为范围请求处理，否则返回全体资源</li>\n<li>If-Unmodified-Since：与If-Modified-Since相反，如果在指定的日期之后资源无更新，则服务器处理请求，返回资源，否则返回412</li>\n<li>Max-Forwards：指定可经过的服务器最大数目，</li>\n<li>Proxy-Authorization：代理认证信息，与Authorization不同之处在于他是客户端与代理服务器之间的认证，而Authorization是客户端与源服务器之间的认证信息</li>\n<li>Range：请求资源的范围</li>\n<li>Referer：告知服务器请求的原始资源的URI</li>\n<li>TE：告知服务器客户端能够处理的响应的编码方式及优先级</li>\n<li>User-Agent：告知服务器浏览器的种类和用户名称等信息</li>\n</ul>\n<h3 id=\"响应首部字段\"><a href=\"#响应首部字段\" class=\"headerlink\" title=\"响应首部字段\"></a>响应首部字段</h3><ul>\n<li>Accept-Range：告知客户端服务器是否能处理范围请求，可以处理则字段值为bytes，反之则为none</li>\n<li>Age：告知客户端该响应是在多久前创建的，如果是缓存服务器，则必须加上Age字段，告知客户端该资源是多久前从源服务器获取的</li>\n<li>ETag：告知客户端实体的标识<ul>\n<li>强ETag值：无论实体发生多么细微的变化，都会改变ETag的值</li>\n<li>弱ETag值：只有资源发生根本改变，产生差异时才会改变ETag值</li>\n</ul>\n</li>\n<li>Location：告知客户端重定向的地址</li>\n<li>Proxy-Authenticate：告知客户端适用于代理服务器的认证方案</li>\n<li>Retry-After：告知客户端多久之后再次发送请求，主要配合503响应或3XX响应</li>\n<li>Server：告知客户端HTTP服务器的应用程序信息</li>\n<li>Vary：源服务器告知代理服务器，必须具有同Vary指定的字段相同的同的值的请求才能直接返回缓存，否则必须从源服务器上获取资源</li>\n<li>WWW-Authenticate：告知客户端适用于服务器的认证方案</li>\n</ul>\n<h3 id=\"实体首部字段\"><a href=\"#实体首部字段\" class=\"headerlink\" title=\"实体首部字段\"></a>实体首部字段</h3><ul>\n<li>Allow：告知客户端服务器能够支持的所有HTTP方法</li>\n<li>Content-Encoding：告知客户端服务器对实体的主体部分选用的编码方式</li>\n<li>Content-Language：告知客户端实体主体使用的自然语言</li>\n<li>Content-Length：告知客户端实体主体的大小（字节）</li>\n<li>Content-Location：报文主体返回资源对应的URI</li>\n<li>Content-MD5：报文主体部分的MD5值，用于校验主体部分是否完整</li>\n<li>Content-Range：告知客户端返回的实体是整个资源的那一部分，格式<code>500-1000/1000</code></li>\n<li>Content-Type：说明实体内对象的类型</li>\n<li>Expires：告知客户端或代理服务器资源失效的日期</li>\n<li>Last-Modified：指明资源最终修改的时间</li>\n</ul>\n<h3 id=\"为Cookie服务器的首部字段\"><a href=\"#为Cookie服务器的首部字段\" class=\"headerlink\" title=\"为Cookie服务器的首部字段\"></a>为Cookie服务器的首部字段</h3><ul>\n<li>Set-Cookie：告知客户端各种状态信息以及Cookie的设置信息</li>\n<li>Cookie：告知服务器当前客户端的各种状态信息</li>\n</ul>\n<h3 id=\"其他首部字段\"><a href=\"#其他首部字段\" class=\"headerlink\" title=\"其他首部字段\"></a>其他首部字段</h3><ul>\n<li>X-Frame-Options：控制网站内容在其他Web网站的Frame标签内显示的问题，可防止点击劫持攻击</li>\n<li>X-XSS-Protection：控制浏览器XSS防护机制的开关</li>\n<li>DNT：告知服务器客户端拒绝提供个人信息</li>\n<li>P3P：让Web网站上的个人隐私变成一种仅供程序可理解的形式</li>\n</ul>\n<h2 id=\"第七章-确保Web安全的HTTPS\"><a href=\"#第七章-确保Web安全的HTTPS\" class=\"headerlink\" title=\"第七章 确保Web安全的HTTPS\"></a>第七章 确保Web安全的HTTPS</h2><h3 id=\"HTTP的缺点\"><a href=\"#HTTP的缺点\" class=\"headerlink\" title=\"HTTP的缺点\"></a>HTTP的缺点</h3><ul>\n<li><strong>通信使用明文可能会被窃听</strong><ul>\n<li>TCP/IP是可能被窃听的网络</li>\n<li>使用加密处理防止被窃听<ul>\n<li>通信加密：对整个通信线路加密，通过SSL或TSL加密HTTP的通信内容，与SSL组合使用的HTTP成为HTTPS（超文本传输安全协议）</li>\n<li>内容加密：对实体内容加密，客户端服务器要有相应的加密和解密机制</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>不验证通信方的身份就可能遭遇伪装</strong><ul>\n<li>任何人都可能发起请求</li>\n<li>查明对手的证书<ul>\n<li>SSL不仅提供加密处理，还使用了证书手段，用于确定对方的身份</li>\n<li>证书由值得信任的第三方机构颁发，用于证明服务器和客户端是实际存在的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>无法证明报文完整性，可能已遭篡改</strong></li>\n</ul>\n<h3 id=\"HTTP-加密-认证-完整性保护-HTTPS\"><a href=\"#HTTP-加密-认证-完整性保护-HTTPS\" class=\"headerlink\" title=\"HTTP+加密+认证+完整性保护=HTTPS\"></a>HTTP+加密+认证+完整性保护=HTTPS</h3><ul>\n<li>HTTP加上加密处理和认证以及完整性保护就是HTTPS</li>\n<li>HTTPS是身披SSL外壳的HTTP<ul>\n<li>HTTPS并非一种新的协议，只是HTTP通信接口部分用SSL和TLS协议代替而已</li>\n<li>SSL是独立于HTTP的协议，所以不光是HTTP协议，其他运行在应用层的协议也可以配合SSL协议使用，SSL是当今世界应用最为广泛的网络安全技术</li>\n</ul>\n</li>\n<li>加密技术<ul>\n<li>共享密钥：即加密和解密使用同一个密钥的方式，也称为对称密钥加密<ul>\n<li>优点：速度快</li>\n<li>缺点：密钥可能被劫持</li>\n</ul>\n</li>\n<li>公开密钥：使用两个密钥，公有密钥和私有密钥，公有密钥加密，私有密钥解密，又称为非对称加密<ul>\n<li>优点：安全性高，密钥不会被劫持</li>\n<li>缺点：处理速度慢</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>HTTPS采用混合加密机制，即共享密钥和公开密钥混合的方式，一般情况下是使用公开密钥的方式传输共享密钥的密钥，当共享密钥的密钥被安全送达后，就可以<br>使用共享密钥来加密普通数据。</li>\n</ul>\n<h3 id=\"证明公开密钥正确性的证书\"><a href=\"#证明公开密钥正确性的证书\" class=\"headerlink\" title=\"证明公开密钥正确性的证书\"></a>证明公开密钥正确性的证书</h3><ul>\n<li>问题：如何确保公开密钥中的共有密钥在传输过程中不被篡改</li>\n<li>解决方案：使用数字证书确保共有密钥的正确性</li>\n<li>基本流程：<ol>\n<li>服务器从数字证书认证机构那里申请公钥证书，公钥证书包含服务器的公开密钥和数字证书认证机构的数字签名。</li>\n<li>申请到公钥证书之后把这份公钥证书发送给用户</li>\n<li>用户在拿到公钥证书后使用数字证书认证机构的公开密钥（一般浏览器都会内置常用认证机构的公开密钥）对证书进行验证</li>\n<li>一旦认证通过就表示公钥证书中的服务器公钥是真实可靠的。</li>\n</ol>\n</li>\n<li>其他的一些概念<ul>\n<li>EV SSL证书：用来证明服务器是否符合规范，服务器背后的运营企业是否真实存在的证书</li>\n<li>客户端证书：用来证明客户端实际存在的证书</li>\n<li>自签名证书：使用OpenSSL可以构建自己的证书认证机构，自己给自己颁发服务器证书，该证书一般不被浏览器信赖</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HTTPS的安全通信机制\"><a href=\"#HTTPS的安全通信机制\" class=\"headerlink\" title=\"HTTPS的安全通信机制\"></a>HTTPS的安全通信机制</h3><ul>\n<li>SSL和TLS：TLS是在SSL基础上开发的协议。</li>\n<li>HTTPS会比相应的HTTP请求要慢，因为要做加密处理。所以除非敏感信息，否则一般情况下使用HTTP就可以了。</li>\n</ul>\n","excerpt":"","more":"<ul>\n<li>toc<br>{:toc}</li>\n</ul>\n<h2 id=\"第三章-HTTP报文内的HTTP信息\"><a href=\"#第三章-HTTP报文内的HTTP信息\" class=\"headerlink\" title=\"第三章 HTTP报文内的HTTP信息\"></a>第三章 HTTP报文内的HTTP信息</h2><h3 id=\"HTTP报文\"><a href=\"#HTTP报文\" class=\"headerlink\" title=\"HTTP报文\"></a>HTTP报文</h3><p>HTTP报文分为请求报文和响应报文两种，主要是由报文首部和报文主体两部分组成。</p>\n<h3 id=\"编码提升传输速率\"><a href=\"#编码提升传输速率\" class=\"headerlink\" title=\"编码提升传输速率\"></a>编码提升传输速率</h3><p>为了提升传输速率，HTTP协议通常会对要传输的实体进行压缩，即内容编码。<br>内容编码致指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。常见的编码有：</p>\n<ul>\n<li>gzip (GNU zip)</li>\n<li>compress (UNIX系统标准压缩)</li>\n<li>deflate (zlib)</li>\n<li>identity (不进行编码)</li>\n</ul>\n<p><strong>分块编码</strong> 对于实体数据过大时，通常会把实体数据进行分块传输。分块编码会将实体主体分成多个部分快，客户端在接收到之后自行解码拼接。</p>\n<h3 id=\"发送多种数据类型\"><a href=\"#发送多种数据类型\" class=\"headerlink\" title=\"发送多种数据类型\"></a>发送多种数据类型</h3><p>一个HTTP请求中可能还有文字，图片，视频等多种不同的数据类型，HTTP协议通过多部分对象集合，使得一份报文中可以含有多类型实体。通常实在上传图片或文本时使用。</p>\n<p>多部分对象集合包含的对象：</p>\n<ul>\n<li>multipart/form-data : 表单文件上传</li>\n<li>multipart/byteranges : 状态码为206，响应报文中包含了多个范围的内容</li>\n</ul>\n<p>多部分对象集合中的每个部分都含有首部字段，另外，还可以在某个部分中嵌套使用对象集合。</p>\n<h3 id=\"获取部分内容的范围请求\"><a href=\"#获取部分内容的范围请求\" class=\"headerlink\" title=\"获取部分内容的范围请求\"></a>获取部分内容的范围请求</h3><p>执行范围请求，需要在首部加上Range字段，例如</p>\n<ul>\n<li><code>Range: bytes=500-1000</code>，表示只请求500-1000的字节范围的数据。</li>\n<li><code>Range: bytes=1000-</code>，表示请求1000字节以后的全部数据</li>\n<li><code>Range: bytes=-300, 500-1000</code>，表示请求0-300和500-1000两部分数据</li>\n</ul>\n<p>请求成功，服务器会返回<code>206 Partial Content</code>状态码，表示请求部分数据成功，如何数据已经全部请求完成，则返回200</p>\n<p>例如：一个资源大小为200 bytes，HTTP请求的Range字段为<code>Range: bytes=-300</code>，则一次请求就可以请求到全部数据，因此返回200，不会返回206</p>\n<p>范围请求通常用于断点下载等操作。</p>\n<h3 id=\"内容协商返回最合适的内容\"><a href=\"#内容协商返回最合适的内容\" class=\"headerlink\" title=\"内容协商返回最合适的内容\"></a>内容协商返回最合适的内容</h3><p>同一个页面服务器可能存在多份，比如英文页面，中文页面等。服务器会根据请求报文中的某些字段（语言，字符集，编码方式等）作为判断基准，返回最合适的页面。</p>\n<p>相关的首部字段有</p>\n<ul>\n<li>Accept</li>\n<li>Accept-Charset</li>\n<li>Accept-Encoding</li>\n<li>Accept-Language</li>\n<li>Content-Language</li>\n</ul>\n<h2 id=\"第四章-返回结果的HTTP状态码\"><a href=\"#第四章-返回结果的HTTP状态码\" class=\"headerlink\" title=\"第四章 返回结果的HTTP状态码\"></a>第四章 返回结果的HTTP状态码</h2><p>状态码的职责是当客户端发送请求时，描述返回的请求结果。状态码和状态不一致的现象也很常见。</p>\n<h3 id=\"2XX-OK\"><a href=\"#2XX-OK\" class=\"headerlink\" title=\"2XX OK\"></a>2XX OK</h3><ul>\n<li><strong>200 OK</strong> 正常处理，HEAD请求成功，不返回内容实体，状态码也是200</li>\n<li><strong>204 No Content</strong> 请求已处理成功，但没有资源返回</li>\n<li><strong>206 Partial Content</strong> 请求成功，返回资源的某一部分</li>\n</ul>\n<h3 id=\"3XX-重定向\"><a href=\"#3XX-重定向\" class=\"headerlink\" title=\"3XX 重定向\"></a>3XX 重定向</h3><ul>\n<li><strong>301 Moved Permanently</strong> 永久重定向，资源的URI已经更新</li>\n<li><strong>302 Found</strong> 临时重定向，URI已经更新，希望本次使用新的URI进行请求</li>\n<li><strong>303 See Other</strong> 资源的URI已经更新，请使用GET方法从新的URI获取资源。302和303功能类似，但303明确告诉客户端应该使用GET方法请求另一个URI。实际应用中，当301，302，303状态码返回时，几乎所有的浏览器都会把POST改为GET，<br>然后重新请求。</li>\n<li><strong>304 Not Modified</strong> 资源已找到，但未符合条件请求。<strong>条件请求</strong> 是指在首部添加<code>If-Match, If-Modified-Since, If-None-Match,If-Range,-IfUnmodified-Since</code><br>中的任何一个</li>\n<li><strong>307 TemporaryRedirect</strong> 临时重定向。与302有相同的含义。</li>\n</ul>\n<h3 id=\"4XX-客户端错误\"><a href=\"#4XX-客户端错误\" class=\"headerlink\" title=\"4XX 客户端错误\"></a>4XX 客户端错误</h3><ul>\n<li><strong>400 Bad Request</strong> 请求报文中存在语法错误，服务器无法理解。</li>\n<li><strong>401 Unauthorized</strong> 发送的请求需要通过HTTP认证。当浏览器接受到401时，会弹出认证窗口，让用户填写用户名和密码</li>\n<li><strong>403 Forbidden</strong> 不允许访问该资源</li>\n<li><strong>404 Not Found</strong> 没有找到请求的资源</li>\n</ul>\n<h3 id=\"5XX-服务器错误\"><a href=\"#5XX-服务器错误\" class=\"headerlink\" title=\"5XX 服务器错误\"></a>5XX 服务器错误</h3><ul>\n<li><strong>500 Internal Server Error</strong> 服务器发生错误</li>\n<li><strong>503 Service Unavailable</strong> 表示服务器暂时处于超负载或正在停机维护，现在无法处理请求。</li>\n</ul>\n<h2 id=\"第五章-与HTTP协作的Web服务器\"><a href=\"#第五章-与HTTP协作的Web服务器\" class=\"headerlink\" title=\"第五章 与HTTP协作的Web服务器\"></a>第五章 与HTTP协作的Web服务器</h2><h3 id=\"用单台虚拟主机实现多个域名\"><a href=\"#用单台虚拟主机实现多个域名\" class=\"headerlink\" title=\"用单台虚拟主机实现多个域名\"></a>用单台虚拟主机实现多个域名</h3><p>同一台服务器可以搭建多个Web站点，这是利用了虚拟主机的功能。但是这就会导致多个域名在经过DNS解析后映射到了同一个IP地址。为了确定到底是访问那个域名，<br>HTTP请求中，必须在首部的Host字段完整的指定主机名或域名的URI</p>\n<h3 id=\"通信数据转发程序：代理，网关，隧道\"><a href=\"#通信数据转发程序：代理，网关，隧道\" class=\"headerlink\" title=\"通信数据转发程序：代理，网关，隧道\"></a>通信数据转发程序：代理，网关，隧道</h3><ul>\n<li><strong>代理</strong>：代理是一种有转发功能的应用程序，他接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端<ul>\n<li>代理不会改变请求的URI，会直接发送给前方持有资源的目标服务器，即源服务器。</li>\n<li>在HTTP请求中可以级联多台代理服务器</li>\n<li>代理服务器的用途：<ul>\n<li>利用缓存技术减少网络带宽流量</li>\n<li>组织内部针对特定网站的访问控制</li>\n</ul>\n</li>\n<li>代理的种类<ul>\n<li>缓存代理：将源服务器的资源副本保存在代理服务器上，这样当代理再次接到相同的请求是，就不需要从源服务器那里再次获取资源了</li>\n<li>透明代理和非透明代理：不对报文进行加工，成为透明代理，否则成为非透明代理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>网关</strong>：转发其他服务器通信数据的服务器<ul>\n<li>网关与代理类似，但它可以提供非HTTP服务，即经过网关可以向非HTTP服务器请求数据</li>\n<li>利用网关能提高通信的安全性</li>\n</ul>\n</li>\n<li><strong>隧道</strong>：在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序<ul>\n<li>隧道可按要求建立起一条与其他服务器的通信线路，届时可以使用SSL等加密手段进行通信。</li>\n<li>隧道的目的是确保通信的安全性</li>\n<li>隧道本身不会解析HTTP请求，不会到HTTP请求进行修改</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"保存资源的缓存\"><a href=\"#保存资源的缓存\" class=\"headerlink\" title=\"保存资源的缓存\"></a>保存资源的缓存</h3><p>缓存是指资源的副本，利用缓存可以减少对源服务器的访问，从而节省通信流量和通信时间。</p>\n<p>缓存服务器是代理服务器的一种，用于实现缓存。除了缓存服务器外，也可以包缓存保存在客户端的浏览器中。缓存都是有有效期的，<br>过了有效期就应该重新向源服务器请求最新的资源。</p>\n<h2 id=\"第六章-HTTP首部\"><a href=\"#第六章-HTTP首部\" class=\"headerlink\" title=\"第六章 HTTP首部\"></a>第六章 HTTP首部</h2><h3 id=\"HTTP报文首部字段\"><a href=\"#HTTP报文首部字段\" class=\"headerlink\" title=\"HTTP报文首部字段\"></a>HTTP报文首部字段</h3><ul>\n<li>字段结构：<code>首部字段名:字段值</code>，例如<code>Content-Type: text/html</code>，单个字段也可以有多个只，例如<code>Keep-Alive: timeout=15, max=10</code></li>\n<li>如果首部字段重复，即出现两个同名的字段，则有的浏览器处理第一次出现的字段，有的浏览器处理最后一次出现的首部字段，这个在规范中没有明确指出。</li>\n<li>4种HTTP首部字段类型<ul>\n<li>通用首部字段：请求报文和响应报文都会使用的字段</li>\n<li>请求首部字段：请求报文中使用的首部字段</li>\n<li>响应首部字段：响应报文中使用的首部字段</li>\n<li>实体首部字段：实体部分使用的首部字段</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"通用首部字段\"><a href=\"#通用首部字段\" class=\"headerlink\" title=\"通用首部字段\"></a>通用首部字段</h3><ul>\n<li>Cache-Control：指定缓存的工作机制</li>\n<li>Connection：控制不在转发给代理的首部字段，管理持久链接</li>\n<li>Date：表明创建HTTP报文的时间</li>\n<li>Pragma：指定是否允许代理服务器返回缓存资源，这是历史遗留字段，</li>\n<li>Trailer：说明在报文主体后会记录哪些首部字段，应用于分块传输编码</li>\n<li>Transfer-Encoding：规定了传输报文主体时采用的编码方式</li>\n<li>Upgrade：用于检测HTTP协议及其他协议是否可使用更高版本进行通信，该字段仅限于客户端与邻接服务器，因此需要在Connection中指定Upgrade</li>\n<li>Via：追踪客户端与服务器之间请求和响应的传输路径</li>\n<li>Warning：告知用于一些与缓存相关的问题的警告<br>*</li>\n</ul>\n<h3 id=\"请求首部字段\"><a href=\"#请求首部字段\" class=\"headerlink\" title=\"请求首部字段\"></a>请求首部字段</h3><ul>\n<li>Accept：通知服务器应该返回的资源类型以及类型的优先级，格式为<code>type/subtype</code>，例如<code>text/html, image/jpeg</code></li>\n<li>Accept-Charset：通知服务器客户端支持的字符集及优先级</li>\n<li>Accept-Encoding：通知服务器客户端支持的内容编码及优先级</li>\n<li>Accept-Language：通知服务器客户端支持的语言及优先级</li>\n<li>Authorization：客户端的认证信息</li>\n<li>Form：告知服务器客户端的用户的电子邮箱地址，也可把电子邮箱记录在User-Agent中</li>\n<li>Host：告知服务器资源所处的主机名和端口号</li>\n<li>If-Match：告知服务器匹配资源所有的实体标记(ETag)，只有资源的ETag与该字段值匹配，服务器才会返回请求，否则返回412</li>\n<li>If-Modified-Since：指定更新日期，如果在指定的日期之后资源有更新，则服务器处理请求，返回资源，否则返回304</li>\n<li>If-None-Match：与If-Match相反，只有资源的ETag与该字段值不匹配，服务器才会返回请求，否则返回412</li>\n<li>If-Range：告知服务器若If-Range的字段值（ETag或时间）和请求资源的ETag值或时间相一致时，作为范围请求处理，否则返回全体资源</li>\n<li>If-Unmodified-Since：与If-Modified-Since相反，如果在指定的日期之后资源无更新，则服务器处理请求，返回资源，否则返回412</li>\n<li>Max-Forwards：指定可经过的服务器最大数目，</li>\n<li>Proxy-Authorization：代理认证信息，与Authorization不同之处在于他是客户端与代理服务器之间的认证，而Authorization是客户端与源服务器之间的认证信息</li>\n<li>Range：请求资源的范围</li>\n<li>Referer：告知服务器请求的原始资源的URI</li>\n<li>TE：告知服务器客户端能够处理的响应的编码方式及优先级</li>\n<li>User-Agent：告知服务器浏览器的种类和用户名称等信息</li>\n</ul>\n<h3 id=\"响应首部字段\"><a href=\"#响应首部字段\" class=\"headerlink\" title=\"响应首部字段\"></a>响应首部字段</h3><ul>\n<li>Accept-Range：告知客户端服务器是否能处理范围请求，可以处理则字段值为bytes，反之则为none</li>\n<li>Age：告知客户端该响应是在多久前创建的，如果是缓存服务器，则必须加上Age字段，告知客户端该资源是多久前从源服务器获取的</li>\n<li>ETag：告知客户端实体的标识<ul>\n<li>强ETag值：无论实体发生多么细微的变化，都会改变ETag的值</li>\n<li>弱ETag值：只有资源发生根本改变，产生差异时才会改变ETag值</li>\n</ul>\n</li>\n<li>Location：告知客户端重定向的地址</li>\n<li>Proxy-Authenticate：告知客户端适用于代理服务器的认证方案</li>\n<li>Retry-After：告知客户端多久之后再次发送请求，主要配合503响应或3XX响应</li>\n<li>Server：告知客户端HTTP服务器的应用程序信息</li>\n<li>Vary：源服务器告知代理服务器，必须具有同Vary指定的字段相同的同的值的请求才能直接返回缓存，否则必须从源服务器上获取资源</li>\n<li>WWW-Authenticate：告知客户端适用于服务器的认证方案</li>\n</ul>\n<h3 id=\"实体首部字段\"><a href=\"#实体首部字段\" class=\"headerlink\" title=\"实体首部字段\"></a>实体首部字段</h3><ul>\n<li>Allow：告知客户端服务器能够支持的所有HTTP方法</li>\n<li>Content-Encoding：告知客户端服务器对实体的主体部分选用的编码方式</li>\n<li>Content-Language：告知客户端实体主体使用的自然语言</li>\n<li>Content-Length：告知客户端实体主体的大小（字节）</li>\n<li>Content-Location：报文主体返回资源对应的URI</li>\n<li>Content-MD5：报文主体部分的MD5值，用于校验主体部分是否完整</li>\n<li>Content-Range：告知客户端返回的实体是整个资源的那一部分，格式<code>500-1000/1000</code></li>\n<li>Content-Type：说明实体内对象的类型</li>\n<li>Expires：告知客户端或代理服务器资源失效的日期</li>\n<li>Last-Modified：指明资源最终修改的时间</li>\n</ul>\n<h3 id=\"为Cookie服务器的首部字段\"><a href=\"#为Cookie服务器的首部字段\" class=\"headerlink\" title=\"为Cookie服务器的首部字段\"></a>为Cookie服务器的首部字段</h3><ul>\n<li>Set-Cookie：告知客户端各种状态信息以及Cookie的设置信息</li>\n<li>Cookie：告知服务器当前客户端的各种状态信息</li>\n</ul>\n<h3 id=\"其他首部字段\"><a href=\"#其他首部字段\" class=\"headerlink\" title=\"其他首部字段\"></a>其他首部字段</h3><ul>\n<li>X-Frame-Options：控制网站内容在其他Web网站的Frame标签内显示的问题，可防止点击劫持攻击</li>\n<li>X-XSS-Protection：控制浏览器XSS防护机制的开关</li>\n<li>DNT：告知服务器客户端拒绝提供个人信息</li>\n<li>P3P：让Web网站上的个人隐私变成一种仅供程序可理解的形式</li>\n</ul>\n<h2 id=\"第七章-确保Web安全的HTTPS\"><a href=\"#第七章-确保Web安全的HTTPS\" class=\"headerlink\" title=\"第七章 确保Web安全的HTTPS\"></a>第七章 确保Web安全的HTTPS</h2><h3 id=\"HTTP的缺点\"><a href=\"#HTTP的缺点\" class=\"headerlink\" title=\"HTTP的缺点\"></a>HTTP的缺点</h3><ul>\n<li><strong>通信使用明文可能会被窃听</strong><ul>\n<li>TCP/IP是可能被窃听的网络</li>\n<li>使用加密处理防止被窃听<ul>\n<li>通信加密：对整个通信线路加密，通过SSL或TSL加密HTTP的通信内容，与SSL组合使用的HTTP成为HTTPS（超文本传输安全协议）</li>\n<li>内容加密：对实体内容加密，客户端服务器要有相应的加密和解密机制</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>不验证通信方的身份就可能遭遇伪装</strong><ul>\n<li>任何人都可能发起请求</li>\n<li>查明对手的证书<ul>\n<li>SSL不仅提供加密处理，还使用了证书手段，用于确定对方的身份</li>\n<li>证书由值得信任的第三方机构颁发，用于证明服务器和客户端是实际存在的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>无法证明报文完整性，可能已遭篡改</strong></li>\n</ul>\n<h3 id=\"HTTP-加密-认证-完整性保护-HTTPS\"><a href=\"#HTTP-加密-认证-完整性保护-HTTPS\" class=\"headerlink\" title=\"HTTP+加密+认证+完整性保护=HTTPS\"></a>HTTP+加密+认证+完整性保护=HTTPS</h3><ul>\n<li>HTTP加上加密处理和认证以及完整性保护就是HTTPS</li>\n<li>HTTPS是身披SSL外壳的HTTP<ul>\n<li>HTTPS并非一种新的协议，只是HTTP通信接口部分用SSL和TLS协议代替而已</li>\n<li>SSL是独立于HTTP的协议，所以不光是HTTP协议，其他运行在应用层的协议也可以配合SSL协议使用，SSL是当今世界应用最为广泛的网络安全技术</li>\n</ul>\n</li>\n<li>加密技术<ul>\n<li>共享密钥：即加密和解密使用同一个密钥的方式，也称为对称密钥加密<ul>\n<li>优点：速度快</li>\n<li>缺点：密钥可能被劫持</li>\n</ul>\n</li>\n<li>公开密钥：使用两个密钥，公有密钥和私有密钥，公有密钥加密，私有密钥解密，又称为非对称加密<ul>\n<li>优点：安全性高，密钥不会被劫持</li>\n<li>缺点：处理速度慢</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>HTTPS采用混合加密机制，即共享密钥和公开密钥混合的方式，一般情况下是使用公开密钥的方式传输共享密钥的密钥，当共享密钥的密钥被安全送达后，就可以<br>使用共享密钥来加密普通数据。</li>\n</ul>\n<h3 id=\"证明公开密钥正确性的证书\"><a href=\"#证明公开密钥正确性的证书\" class=\"headerlink\" title=\"证明公开密钥正确性的证书\"></a>证明公开密钥正确性的证书</h3><ul>\n<li>问题：如何确保公开密钥中的共有密钥在传输过程中不被篡改</li>\n<li>解决方案：使用数字证书确保共有密钥的正确性</li>\n<li>基本流程：<ol>\n<li>服务器从数字证书认证机构那里申请公钥证书，公钥证书包含服务器的公开密钥和数字证书认证机构的数字签名。</li>\n<li>申请到公钥证书之后把这份公钥证书发送给用户</li>\n<li>用户在拿到公钥证书后使用数字证书认证机构的公开密钥（一般浏览器都会内置常用认证机构的公开密钥）对证书进行验证</li>\n<li>一旦认证通过就表示公钥证书中的服务器公钥是真实可靠的。</li>\n</ol>\n</li>\n<li>其他的一些概念<ul>\n<li>EV SSL证书：用来证明服务器是否符合规范，服务器背后的运营企业是否真实存在的证书</li>\n<li>客户端证书：用来证明客户端实际存在的证书</li>\n<li>自签名证书：使用OpenSSL可以构建自己的证书认证机构，自己给自己颁发服务器证书，该证书一般不被浏览器信赖</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HTTPS的安全通信机制\"><a href=\"#HTTPS的安全通信机制\" class=\"headerlink\" title=\"HTTPS的安全通信机制\"></a>HTTPS的安全通信机制</h3><ul>\n<li>SSL和TLS：TLS是在SSL基础上开发的协议。</li>\n<li>HTTPS会比相应的HTTP请求要慢，因为要做加密处理。所以除非敏感信息，否则一般情况下使用HTTP就可以了。</li>\n</ul>\n"},{"layout":"post","title":"最近开发中遇到的一些问题","_content":"\n本文主要记录了我近期在开发中遇到的一些问题以及解决方法。\n\n## 问题1: TTTAttributedLabel卡顿\n\n**问题描述** 项目中用到了TTTAttributedLabel，用于实现在Label中点击链接跳转，在实际使用过程中，出现了如果Label内容很多，通过UIScrollView滑动Label时非常卡\n的问题。\n\n**解决方案** TTTAttributedLabel中有一个`extendsLinkTouchArea`属性，指示是否在一个较大的范围内检测链接的Label的Touch事件，默认是YES，设置成NO，表示不检测，\n这样可以提高TTTAttributedLabel的性能\n\n## 问题2: `dyld: Symbol not found: _CTRadioAccessTechnologyEdge`问题\n\n**问题描述** 项目中了Reachability用于检测3G/4G/Wifi，之前一直使用正常，最近突然不知什么原因在iOS6上出现了如下图的问题，重新添加CoreTelephone框架也没有用。\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-15%20at%2009.33.53.png)\n\n**解决方案** 需要将CoreTelephone框架的状态设置为Optional，如下图，这样就不会有上述问题了。\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-16%20at%2022.15.38.png)\n\n具体原因我也不是非常清楚，如果有哪位朋友清楚欢迎分享。\n","source":"_posts/2015-10-16-最近开发中遇到的一些问题.md","raw":"---\nlayout: post\ntitle: \"最近开发中遇到的一些问题\"\ncategories: \"iOS开发\"\n---\n\n本文主要记录了我近期在开发中遇到的一些问题以及解决方法。\n\n## 问题1: TTTAttributedLabel卡顿\n\n**问题描述** 项目中用到了TTTAttributedLabel，用于实现在Label中点击链接跳转，在实际使用过程中，出现了如果Label内容很多，通过UIScrollView滑动Label时非常卡\n的问题。\n\n**解决方案** TTTAttributedLabel中有一个`extendsLinkTouchArea`属性，指示是否在一个较大的范围内检测链接的Label的Touch事件，默认是YES，设置成NO，表示不检测，\n这样可以提高TTTAttributedLabel的性能\n\n## 问题2: `dyld: Symbol not found: _CTRadioAccessTechnologyEdge`问题\n\n**问题描述** 项目中了Reachability用于检测3G/4G/Wifi，之前一直使用正常，最近突然不知什么原因在iOS6上出现了如下图的问题，重新添加CoreTelephone框架也没有用。\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-15%20at%2009.33.53.png)\n\n**解决方案** 需要将CoreTelephone框架的状态设置为Optional，如下图，这样就不会有上述问题了。\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-16%20at%2022.15.38.png)\n\n具体原因我也不是非常清楚，如果有哪位朋友清楚欢迎分享。\n","slug":"最近开发中遇到的一些问题","published":1,"date":"2015-10-15T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oaap000tzrm0xcn38j1e","content":"<p>本文主要记录了我近期在开发中遇到的一些问题以及解决方法。</p>\n<h2 id=\"问题1-TTTAttributedLabel卡顿\"><a href=\"#问题1-TTTAttributedLabel卡顿\" class=\"headerlink\" title=\"问题1: TTTAttributedLabel卡顿\"></a>问题1: TTTAttributedLabel卡顿</h2><p><strong>问题描述</strong> 项目中用到了TTTAttributedLabel，用于实现在Label中点击链接跳转，在实际使用过程中，出现了如果Label内容很多，通过UIScrollView滑动Label时非常卡<br>的问题。</p>\n<p><strong>解决方案</strong> TTTAttributedLabel中有一个<code>extendsLinkTouchArea</code>属性，指示是否在一个较大的范围内检测链接的Label的Touch事件，默认是YES，设置成NO，表示不检测，<br>这样可以提高TTTAttributedLabel的性能</p>\n<h2 id=\"问题2-dyld-Symbol-not-found-CTRadioAccessTechnologyEdge问题\"><a href=\"#问题2-dyld-Symbol-not-found-CTRadioAccessTechnologyEdge问题\" class=\"headerlink\" title=\"问题2: dyld: Symbol not found: _CTRadioAccessTechnologyEdge问题\"></a>问题2: <code>dyld: Symbol not found: _CTRadioAccessTechnologyEdge</code>问题</h2><p><strong>问题描述</strong> 项目中了Reachability用于检测3G/4G/Wifi，之前一直使用正常，最近突然不知什么原因在iOS6上出现了如下图的问题，重新添加CoreTelephone框架也没有用。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-15%20at%2009.33.53.png\" alt=\"image\"></p>\n<p><strong>解决方案</strong> 需要将CoreTelephone框架的状态设置为Optional，如下图，这样就不会有上述问题了。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-16%20at%2022.15.38.png\" alt=\"image\"></p>\n<p>具体原因我也不是非常清楚，如果有哪位朋友清楚欢迎分享。</p>\n","excerpt":"","more":"<p>本文主要记录了我近期在开发中遇到的一些问题以及解决方法。</p>\n<h2 id=\"问题1-TTTAttributedLabel卡顿\"><a href=\"#问题1-TTTAttributedLabel卡顿\" class=\"headerlink\" title=\"问题1: TTTAttributedLabel卡顿\"></a>问题1: TTTAttributedLabel卡顿</h2><p><strong>问题描述</strong> 项目中用到了TTTAttributedLabel，用于实现在Label中点击链接跳转，在实际使用过程中，出现了如果Label内容很多，通过UIScrollView滑动Label时非常卡<br>的问题。</p>\n<p><strong>解决方案</strong> TTTAttributedLabel中有一个<code>extendsLinkTouchArea</code>属性，指示是否在一个较大的范围内检测链接的Label的Touch事件，默认是YES，设置成NO，表示不检测，<br>这样可以提高TTTAttributedLabel的性能</p>\n<h2 id=\"问题2-dyld-Symbol-not-found-CTRadioAccessTechnologyEdge问题\"><a href=\"#问题2-dyld-Symbol-not-found-CTRadioAccessTechnologyEdge问题\" class=\"headerlink\" title=\"问题2: dyld: Symbol not found: _CTRadioAccessTechnologyEdge问题\"></a>问题2: <code>dyld: Symbol not found: _CTRadioAccessTechnologyEdge</code>问题</h2><p><strong>问题描述</strong> 项目中了Reachability用于检测3G/4G/Wifi，之前一直使用正常，最近突然不知什么原因在iOS6上出现了如下图的问题，重新添加CoreTelephone框架也没有用。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-15%20at%2009.33.53.png\" alt=\"image\"></p>\n<p><strong>解决方案</strong> 需要将CoreTelephone框架的状态设置为Optional，如下图，这样就不会有上述问题了。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-16%20at%2022.15.38.png\" alt=\"image\"></p>\n<p>具体原因我也不是非常清楚，如果有哪位朋友清楚欢迎分享。</p>\n"},{"layout":"post","title":"UIScrollView与Autolayout","_content":"\n在Autolayout中应用UIScrollView一直以来都是一个难点或易错点，本文是我在参考了很多资料后，总结的两种在Autolayout中正确使用UIScrollView的方法。本文主要以两个\nDemo为例，讲解一下如何在Autolayout中应用UIScrollView，希望对大家能有帮助。\n\n先看一下最终的效果吧！\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/AutolayoutDemo.gif)\n\n## 使用Storyboard布局\n\n首先创建一个Single View Application项目，然后在Storyboard中完成如下布局。\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.29.54.png)\n\n第三个Controller就是我们要实现的界面（以下简称主界面），然后向主界面中拖入一个UIScrollView和一个UIView（姑且叫做A），并且设置UIScrollView的约束如下：\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.38.34.png)\n\n设置A的约束如下，注意不要添加底边距，或者高度约束\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.45.57.png)\n\n**注意，这个A和UIScrollView是同一级的，并不是父子视图的关系。A主要是用来辅助计算UIScrollView中内容的高度的。**\n\n此时设置完成后会有约束冲突（A缺少高度约束），先不用在意。接着向UIScrollView中拖入一个UIView（姑且叫做B），然后设置B的宽度和高度约束与A相等，如下图，可以在左侧\n导航视图中拖线设置。\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.56.15.png)\n\n然后设置B的边界约束如下：\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.38.34.png)\n\n设置完成后，此时的主界面的结构如下图：\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.58.06.png)\n\n**B其实就是作为UIScrollView的contentView存在的，把所有原本是UIScrollView中的子控件都应该放在B中。**\n\n接下里就是布局主要界面，像最终效果图那样，拖入三个UIImageView和一个UILabel，并且设置对应的约束。（此处设置省略，具体可以参考我项目中的设置）注意不要设置UILabel\n的高度约束，并且要设置底部两个UIImageView的下边距约束，这样B就会根据显示的内容自适应高度，并且UIScrollView也会根据B的高度设置contentSize。\n\n整个过程过程的关键点就在于A，B两个UIView，A作为一个辅助视图，辅助UIScrollView计算UIScrollView中内容的高度。B的作用是分离UIScrollView和其子控件之间的关系，\n使得UIScrollView仅与B产生约束关系。\n\n## 使用Masonry进行布局\n\n下面使用第三方框架Masonry进行布局，完成上述功能。\n\n首先使用CocoaPods安装Masonry，然后在UItableViewController中添加一个cell，并在SB中创建一个新的UIViewController，绑定对应的类AutolayoutViewController，\n如下图：\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-28%20at%2000.05.28.png)\n\n在AutolayoutViewController中添加代码，核心代码如下\n\n```objectivec\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    self.scrollView = [[UIScrollView alloc] init];\n    [self.view addSubview:self.scrollView];\n\n    // 把所有子视图都放在containerView中，然后把containerView加在UIScrollView中\n    self.containerView = [[UIView alloc] init];\n    [self.scrollView addSubview:self.containerView];\n\n    self.topImage = [[UIImageView alloc] init];\n    self.topImage.image = [UIImage imageNamed:@\"1.JPG\"];\n    [self.containerView addSubview:self.topImage];\n\n    self.descLabel = [[UILabel alloc] init];\n    self.descLabel.numberOfLines = 0;\n    self.descLabel.text = @\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n    [self.containerView addSubview:self.descLabel];\n\n    self.leftImage = [[UIImageView alloc] init];\n    self.leftImage.image = [UIImage imageNamed:@\"2.JPG\"];\n    [self.containerView addSubview:self.leftImage];\n\n    self.rightImage = [[UIImageView alloc] init];\n    self.rightImage.image = [UIImage imageNamed:@\"3.JPG\"];\n    [self.containerView addSubview:self.rightImage];\n\n    [self.scrollView mas_updateConstraints:^(MASConstraintMaker *make) {\n        make.edges.equalTo(self.view);\n    }];\n\n    [self.containerView mas_updateConstraints:^(MASConstraintMaker *make) {\n        make.edges.equalTo(self.scrollView);\n        make.width.equalTo(self.scrollView);\n    }];\n\n    [self.topImage mas_updateConstraints:^(MASConstraintMaker *make) {\n        make.top.mas_equalTo(self.containerView).offset(20);\n        make.left.mas_equalTo(self.containerView).offset(20);\n        make.right.mas_equalTo(self.containerView).offset(-20);\n        make.height.mas_equalTo(200);\n    }];\n\n    // 注意不要设置descLabel的高度约束\n    [self.descLabel mas_updateConstraints:^(MASConstraintMaker *make) {\n        make.left.equalTo(self.topImage);\n        make.right.equalTo(self.topImage);\n        make.top.mas_equalTo(self.topImage.mas_bottom).offset(20);\n    }];\n\n    [self.leftImage mas_updateConstraints:^(MASConstraintMaker *make) {\n        make.size.equalTo(self.rightImage);\n        make.left.equalTo(self.topImage);\n        make.right.mas_equalTo(self.rightImage.mas_left).offset(20);\n        make.top.mas_equalTo(self.descLabel.mas_bottom).offset(20);\n        make.height.mas_equalTo(150);\n        make.bottom.mas_equalTo(self.containerView.mas_bottom).offset(-20);\n    }];\n\n    [self.rightImage mas_updateConstraints:^(MASConstraintMaker *make) {\n        make.top.equalTo(self.leftImage);\n        make.right.mas_equalTo(self.containerView.mas_right).offset(-20);\n    }];\n\n}\n\n```\n\n这里的关键点是那个containerView，它分离了UIScrollView和子视图的关系。\n\n以上就是本人总结的关于在Autolayout中应用UIScrollView的方法，如果有什么错误欢迎指出。\n\n[代码在这里](https://github.com/liujinlongxa/AutolayoutDemo)\n","source":"_posts/2015-10-27-UIScrollView与Autolayout.md","raw":"---\nlayout: post\ntitle: \"UIScrollView与Autolayout\"\ncategories: \"iOS开发\"\n---\n\n在Autolayout中应用UIScrollView一直以来都是一个难点或易错点，本文是我在参考了很多资料后，总结的两种在Autolayout中正确使用UIScrollView的方法。本文主要以两个\nDemo为例，讲解一下如何在Autolayout中应用UIScrollView，希望对大家能有帮助。\n\n先看一下最终的效果吧！\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/AutolayoutDemo.gif)\n\n## 使用Storyboard布局\n\n首先创建一个Single View Application项目，然后在Storyboard中完成如下布局。\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.29.54.png)\n\n第三个Controller就是我们要实现的界面（以下简称主界面），然后向主界面中拖入一个UIScrollView和一个UIView（姑且叫做A），并且设置UIScrollView的约束如下：\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.38.34.png)\n\n设置A的约束如下，注意不要添加底边距，或者高度约束\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.45.57.png)\n\n**注意，这个A和UIScrollView是同一级的，并不是父子视图的关系。A主要是用来辅助计算UIScrollView中内容的高度的。**\n\n此时设置完成后会有约束冲突（A缺少高度约束），先不用在意。接着向UIScrollView中拖入一个UIView（姑且叫做B），然后设置B的宽度和高度约束与A相等，如下图，可以在左侧\n导航视图中拖线设置。\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.56.15.png)\n\n然后设置B的边界约束如下：\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.38.34.png)\n\n设置完成后，此时的主界面的结构如下图：\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.58.06.png)\n\n**B其实就是作为UIScrollView的contentView存在的，把所有原本是UIScrollView中的子控件都应该放在B中。**\n\n接下里就是布局主要界面，像最终效果图那样，拖入三个UIImageView和一个UILabel，并且设置对应的约束。（此处设置省略，具体可以参考我项目中的设置）注意不要设置UILabel\n的高度约束，并且要设置底部两个UIImageView的下边距约束，这样B就会根据显示的内容自适应高度，并且UIScrollView也会根据B的高度设置contentSize。\n\n整个过程过程的关键点就在于A，B两个UIView，A作为一个辅助视图，辅助UIScrollView计算UIScrollView中内容的高度。B的作用是分离UIScrollView和其子控件之间的关系，\n使得UIScrollView仅与B产生约束关系。\n\n## 使用Masonry进行布局\n\n下面使用第三方框架Masonry进行布局，完成上述功能。\n\n首先使用CocoaPods安装Masonry，然后在UItableViewController中添加一个cell，并在SB中创建一个新的UIViewController，绑定对应的类AutolayoutViewController，\n如下图：\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-28%20at%2000.05.28.png)\n\n在AutolayoutViewController中添加代码，核心代码如下\n\n```objectivec\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    self.scrollView = [[UIScrollView alloc] init];\n    [self.view addSubview:self.scrollView];\n\n    // 把所有子视图都放在containerView中，然后把containerView加在UIScrollView中\n    self.containerView = [[UIView alloc] init];\n    [self.scrollView addSubview:self.containerView];\n\n    self.topImage = [[UIImageView alloc] init];\n    self.topImage.image = [UIImage imageNamed:@\"1.JPG\"];\n    [self.containerView addSubview:self.topImage];\n\n    self.descLabel = [[UILabel alloc] init];\n    self.descLabel.numberOfLines = 0;\n    self.descLabel.text = @\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n    [self.containerView addSubview:self.descLabel];\n\n    self.leftImage = [[UIImageView alloc] init];\n    self.leftImage.image = [UIImage imageNamed:@\"2.JPG\"];\n    [self.containerView addSubview:self.leftImage];\n\n    self.rightImage = [[UIImageView alloc] init];\n    self.rightImage.image = [UIImage imageNamed:@\"3.JPG\"];\n    [self.containerView addSubview:self.rightImage];\n\n    [self.scrollView mas_updateConstraints:^(MASConstraintMaker *make) {\n        make.edges.equalTo(self.view);\n    }];\n\n    [self.containerView mas_updateConstraints:^(MASConstraintMaker *make) {\n        make.edges.equalTo(self.scrollView);\n        make.width.equalTo(self.scrollView);\n    }];\n\n    [self.topImage mas_updateConstraints:^(MASConstraintMaker *make) {\n        make.top.mas_equalTo(self.containerView).offset(20);\n        make.left.mas_equalTo(self.containerView).offset(20);\n        make.right.mas_equalTo(self.containerView).offset(-20);\n        make.height.mas_equalTo(200);\n    }];\n\n    // 注意不要设置descLabel的高度约束\n    [self.descLabel mas_updateConstraints:^(MASConstraintMaker *make) {\n        make.left.equalTo(self.topImage);\n        make.right.equalTo(self.topImage);\n        make.top.mas_equalTo(self.topImage.mas_bottom).offset(20);\n    }];\n\n    [self.leftImage mas_updateConstraints:^(MASConstraintMaker *make) {\n        make.size.equalTo(self.rightImage);\n        make.left.equalTo(self.topImage);\n        make.right.mas_equalTo(self.rightImage.mas_left).offset(20);\n        make.top.mas_equalTo(self.descLabel.mas_bottom).offset(20);\n        make.height.mas_equalTo(150);\n        make.bottom.mas_equalTo(self.containerView.mas_bottom).offset(-20);\n    }];\n\n    [self.rightImage mas_updateConstraints:^(MASConstraintMaker *make) {\n        make.top.equalTo(self.leftImage);\n        make.right.mas_equalTo(self.containerView.mas_right).offset(-20);\n    }];\n\n}\n\n```\n\n这里的关键点是那个containerView，它分离了UIScrollView和子视图的关系。\n\n以上就是本人总结的关于在Autolayout中应用UIScrollView的方法，如果有什么错误欢迎指出。\n\n[代码在这里](https://github.com/liujinlongxa/AutolayoutDemo)\n","slug":"UIScrollView与Autolayout","published":1,"date":"2015-10-26T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oaar000wzrm0a33zjgot","content":"<p>在Autolayout中应用UIScrollView一直以来都是一个难点或易错点，本文是我在参考了很多资料后，总结的两种在Autolayout中正确使用UIScrollView的方法。本文主要以两个<br>Demo为例，讲解一下如何在Autolayout中应用UIScrollView，希望对大家能有帮助。</p>\n<p>先看一下最终的效果吧！</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/AutolayoutDemo.gif\" alt=\"image\"></p>\n<h2 id=\"使用Storyboard布局\"><a href=\"#使用Storyboard布局\" class=\"headerlink\" title=\"使用Storyboard布局\"></a>使用Storyboard布局</h2><p>首先创建一个Single View Application项目，然后在Storyboard中完成如下布局。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.29.54.png\" alt=\"image\"></p>\n<p>第三个Controller就是我们要实现的界面（以下简称主界面），然后向主界面中拖入一个UIScrollView和一个UIView（姑且叫做A），并且设置UIScrollView的约束如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.38.34.png\" alt=\"image\"></p>\n<p>设置A的约束如下，注意不要添加底边距，或者高度约束</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.45.57.png\" alt=\"image\"></p>\n<p><strong>注意，这个A和UIScrollView是同一级的，并不是父子视图的关系。A主要是用来辅助计算UIScrollView中内容的高度的。</strong></p>\n<p>此时设置完成后会有约束冲突（A缺少高度约束），先不用在意。接着向UIScrollView中拖入一个UIView（姑且叫做B），然后设置B的宽度和高度约束与A相等，如下图，可以在左侧<br>导航视图中拖线设置。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.56.15.png\" alt=\"image\"></p>\n<p>然后设置B的边界约束如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.38.34.png\" alt=\"image\"></p>\n<p>设置完成后，此时的主界面的结构如下图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.58.06.png\" alt=\"image\"></p>\n<p><strong>B其实就是作为UIScrollView的contentView存在的，把所有原本是UIScrollView中的子控件都应该放在B中。</strong></p>\n<p>接下里就是布局主要界面，像最终效果图那样，拖入三个UIImageView和一个UILabel，并且设置对应的约束。（此处设置省略，具体可以参考我项目中的设置）注意不要设置UILabel<br>的高度约束，并且要设置底部两个UIImageView的下边距约束，这样B就会根据显示的内容自适应高度，并且UIScrollView也会根据B的高度设置contentSize。</p>\n<p>整个过程过程的关键点就在于A，B两个UIView，A作为一个辅助视图，辅助UIScrollView计算UIScrollView中内容的高度。B的作用是分离UIScrollView和其子控件之间的关系，<br>使得UIScrollView仅与B产生约束关系。</p>\n<h2 id=\"使用Masonry进行布局\"><a href=\"#使用Masonry进行布局\" class=\"headerlink\" title=\"使用Masonry进行布局\"></a>使用Masonry进行布局</h2><p>下面使用第三方框架Masonry进行布局，完成上述功能。</p>\n<p>首先使用CocoaPods安装Masonry，然后在UItableViewController中添加一个cell，并在SB中创建一个新的UIViewController，绑定对应的类AutolayoutViewController，<br>如下图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-28%20at%2000.05.28.png\" alt=\"image\"></p>\n<p>在AutolayoutViewController中添加代码，核心代码如下</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.scrollView = [[<span class=\"built_in\">UIScrollView</span> alloc] init];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:<span class=\"keyword\">self</span>.scrollView];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 把所有子视图都放在containerView中，然后把containerView加在UIScrollView中</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.containerView = [[<span class=\"built_in\">UIView</span> alloc] init];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.scrollView addSubview:<span class=\"keyword\">self</span>.containerView];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.topImage = [[<span class=\"built_in\">UIImageView</span> alloc] init];</div><div class=\"line\">    <span class=\"keyword\">self</span>.topImage.image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"1.JPG\"</span>];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.containerView addSubview:<span class=\"keyword\">self</span>.topImage];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.descLabel = [[<span class=\"built_in\">UILabel</span> alloc] init];</div><div class=\"line\">    <span class=\"keyword\">self</span>.descLabel.numberOfLines = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">self</span>.descLabel.text = <span class=\"string\">@\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"</span>;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.containerView addSubview:<span class=\"keyword\">self</span>.descLabel];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.leftImage = [[<span class=\"built_in\">UIImageView</span> alloc] init];</div><div class=\"line\">    <span class=\"keyword\">self</span>.leftImage.image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"2.JPG\"</span>];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.containerView addSubview:<span class=\"keyword\">self</span>.leftImage];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.rightImage = [[<span class=\"built_in\">UIImageView</span> alloc] init];</div><div class=\"line\">    <span class=\"keyword\">self</span>.rightImage.image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"3.JPG\"</span>];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.containerView addSubview:<span class=\"keyword\">self</span>.rightImage];</div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">self</span>.scrollView mas_updateConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">        make.edges.equalTo(<span class=\"keyword\">self</span>.view);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">self</span>.containerView mas_updateConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">        make.edges.equalTo(<span class=\"keyword\">self</span>.scrollView);</div><div class=\"line\">        make.width.equalTo(<span class=\"keyword\">self</span>.scrollView);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">self</span>.topImage mas_updateConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">        make.top.mas_equalTo(<span class=\"keyword\">self</span>.containerView).offset(<span class=\"number\">20</span>);</div><div class=\"line\">        make.left.mas_equalTo(<span class=\"keyword\">self</span>.containerView).offset(<span class=\"number\">20</span>);</div><div class=\"line\">        make.right.mas_equalTo(<span class=\"keyword\">self</span>.containerView).offset(<span class=\"number\">-20</span>);</div><div class=\"line\">        make.height.mas_equalTo(<span class=\"number\">200</span>);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 注意不要设置descLabel的高度约束</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.descLabel mas_updateConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">        make.left.equalTo(<span class=\"keyword\">self</span>.topImage);</div><div class=\"line\">        make.right.equalTo(<span class=\"keyword\">self</span>.topImage);</div><div class=\"line\">        make.top.mas_equalTo(<span class=\"keyword\">self</span>.topImage.mas_bottom).offset(<span class=\"number\">20</span>);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">self</span>.leftImage mas_updateConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">        make.size.equalTo(<span class=\"keyword\">self</span>.rightImage);</div><div class=\"line\">        make.left.equalTo(<span class=\"keyword\">self</span>.topImage);</div><div class=\"line\">        make.right.mas_equalTo(<span class=\"keyword\">self</span>.rightImage.mas_left).offset(<span class=\"number\">20</span>);</div><div class=\"line\">        make.top.mas_equalTo(<span class=\"keyword\">self</span>.descLabel.mas_bottom).offset(<span class=\"number\">20</span>);</div><div class=\"line\">        make.height.mas_equalTo(<span class=\"number\">150</span>);</div><div class=\"line\">        make.bottom.mas_equalTo(<span class=\"keyword\">self</span>.containerView.mas_bottom).offset(<span class=\"number\">-20</span>);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">self</span>.rightImage mas_updateConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">        make.top.equalTo(<span class=\"keyword\">self</span>.leftImage);</div><div class=\"line\">        make.right.mas_equalTo(<span class=\"keyword\">self</span>.containerView.mas_right).offset(<span class=\"number\">-20</span>);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里的关键点是那个containerView，它分离了UIScrollView和子视图的关系。</p>\n<p>以上就是本人总结的关于在Autolayout中应用UIScrollView的方法，如果有什么错误欢迎指出。</p>\n<p><a href=\"https://github.com/liujinlongxa/AutolayoutDemo\" target=\"_blank\" rel=\"external\">代码在这里</a></p>\n","excerpt":"","more":"<p>在Autolayout中应用UIScrollView一直以来都是一个难点或易错点，本文是我在参考了很多资料后，总结的两种在Autolayout中正确使用UIScrollView的方法。本文主要以两个<br>Demo为例，讲解一下如何在Autolayout中应用UIScrollView，希望对大家能有帮助。</p>\n<p>先看一下最终的效果吧！</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/AutolayoutDemo.gif\" alt=\"image\"></p>\n<h2 id=\"使用Storyboard布局\"><a href=\"#使用Storyboard布局\" class=\"headerlink\" title=\"使用Storyboard布局\"></a>使用Storyboard布局</h2><p>首先创建一个Single View Application项目，然后在Storyboard中完成如下布局。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.29.54.png\" alt=\"image\"></p>\n<p>第三个Controller就是我们要实现的界面（以下简称主界面），然后向主界面中拖入一个UIScrollView和一个UIView（姑且叫做A），并且设置UIScrollView的约束如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.38.34.png\" alt=\"image\"></p>\n<p>设置A的约束如下，注意不要添加底边距，或者高度约束</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.45.57.png\" alt=\"image\"></p>\n<p><strong>注意，这个A和UIScrollView是同一级的，并不是父子视图的关系。A主要是用来辅助计算UIScrollView中内容的高度的。</strong></p>\n<p>此时设置完成后会有约束冲突（A缺少高度约束），先不用在意。接着向UIScrollView中拖入一个UIView（姑且叫做B），然后设置B的宽度和高度约束与A相等，如下图，可以在左侧<br>导航视图中拖线设置。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.56.15.png\" alt=\"image\"></p>\n<p>然后设置B的边界约束如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.38.34.png\" alt=\"image\"></p>\n<p>设置完成后，此时的主界面的结构如下图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-27%20at%2022.58.06.png\" alt=\"image\"></p>\n<p><strong>B其实就是作为UIScrollView的contentView存在的，把所有原本是UIScrollView中的子控件都应该放在B中。</strong></p>\n<p>接下里就是布局主要界面，像最终效果图那样，拖入三个UIImageView和一个UILabel，并且设置对应的约束。（此处设置省略，具体可以参考我项目中的设置）注意不要设置UILabel<br>的高度约束，并且要设置底部两个UIImageView的下边距约束，这样B就会根据显示的内容自适应高度，并且UIScrollView也会根据B的高度设置contentSize。</p>\n<p>整个过程过程的关键点就在于A，B两个UIView，A作为一个辅助视图，辅助UIScrollView计算UIScrollView中内容的高度。B的作用是分离UIScrollView和其子控件之间的关系，<br>使得UIScrollView仅与B产生约束关系。</p>\n<h2 id=\"使用Masonry进行布局\"><a href=\"#使用Masonry进行布局\" class=\"headerlink\" title=\"使用Masonry进行布局\"></a>使用Masonry进行布局</h2><p>下面使用第三方框架Masonry进行布局，完成上述功能。</p>\n<p>首先使用CocoaPods安装Masonry，然后在UItableViewController中添加一个cell，并在SB中创建一个新的UIViewController，绑定对应的类AutolayoutViewController，<br>如下图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-10-28%20at%2000.05.28.png\" alt=\"image\"></p>\n<p>在AutolayoutViewController中添加代码，核心代码如下</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.scrollView = [[<span class=\"built_in\">UIScrollView</span> alloc] init];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:<span class=\"keyword\">self</span>.scrollView];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 把所有子视图都放在containerView中，然后把containerView加在UIScrollView中</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.containerView = [[<span class=\"built_in\">UIView</span> alloc] init];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.scrollView addSubview:<span class=\"keyword\">self</span>.containerView];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.topImage = [[<span class=\"built_in\">UIImageView</span> alloc] init];</div><div class=\"line\">    <span class=\"keyword\">self</span>.topImage.image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"1.JPG\"</span>];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.containerView addSubview:<span class=\"keyword\">self</span>.topImage];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.descLabel = [[<span class=\"built_in\">UILabel</span> alloc] init];</div><div class=\"line\">    <span class=\"keyword\">self</span>.descLabel.numberOfLines = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">self</span>.descLabel.text = <span class=\"string\">@\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"</span>;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.containerView addSubview:<span class=\"keyword\">self</span>.descLabel];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.leftImage = [[<span class=\"built_in\">UIImageView</span> alloc] init];</div><div class=\"line\">    <span class=\"keyword\">self</span>.leftImage.image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"2.JPG\"</span>];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.containerView addSubview:<span class=\"keyword\">self</span>.leftImage];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.rightImage = [[<span class=\"built_in\">UIImageView</span> alloc] init];</div><div class=\"line\">    <span class=\"keyword\">self</span>.rightImage.image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"3.JPG\"</span>];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.containerView addSubview:<span class=\"keyword\">self</span>.rightImage];</div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">self</span>.scrollView mas_updateConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">        make.edges.equalTo(<span class=\"keyword\">self</span>.view);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">self</span>.containerView mas_updateConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">        make.edges.equalTo(<span class=\"keyword\">self</span>.scrollView);</div><div class=\"line\">        make.width.equalTo(<span class=\"keyword\">self</span>.scrollView);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">self</span>.topImage mas_updateConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">        make.top.mas_equalTo(<span class=\"keyword\">self</span>.containerView).offset(<span class=\"number\">20</span>);</div><div class=\"line\">        make.left.mas_equalTo(<span class=\"keyword\">self</span>.containerView).offset(<span class=\"number\">20</span>);</div><div class=\"line\">        make.right.mas_equalTo(<span class=\"keyword\">self</span>.containerView).offset(<span class=\"number\">-20</span>);</div><div class=\"line\">        make.height.mas_equalTo(<span class=\"number\">200</span>);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 注意不要设置descLabel的高度约束</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.descLabel mas_updateConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">        make.left.equalTo(<span class=\"keyword\">self</span>.topImage);</div><div class=\"line\">        make.right.equalTo(<span class=\"keyword\">self</span>.topImage);</div><div class=\"line\">        make.top.mas_equalTo(<span class=\"keyword\">self</span>.topImage.mas_bottom).offset(<span class=\"number\">20</span>);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">self</span>.leftImage mas_updateConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">        make.size.equalTo(<span class=\"keyword\">self</span>.rightImage);</div><div class=\"line\">        make.left.equalTo(<span class=\"keyword\">self</span>.topImage);</div><div class=\"line\">        make.right.mas_equalTo(<span class=\"keyword\">self</span>.rightImage.mas_left).offset(<span class=\"number\">20</span>);</div><div class=\"line\">        make.top.mas_equalTo(<span class=\"keyword\">self</span>.descLabel.mas_bottom).offset(<span class=\"number\">20</span>);</div><div class=\"line\">        make.height.mas_equalTo(<span class=\"number\">150</span>);</div><div class=\"line\">        make.bottom.mas_equalTo(<span class=\"keyword\">self</span>.containerView.mas_bottom).offset(<span class=\"number\">-20</span>);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">self</span>.rightImage mas_updateConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">        make.top.equalTo(<span class=\"keyword\">self</span>.leftImage);</div><div class=\"line\">        make.right.mas_equalTo(<span class=\"keyword\">self</span>.containerView.mas_right).offset(<span class=\"number\">-20</span>);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里的关键点是那个containerView，它分离了UIScrollView和子视图的关系。</p>\n<p>以上就是本人总结的关于在Autolayout中应用UIScrollView的方法，如果有什么错误欢迎指出。</p>\n<p><a href=\"https://github.com/liujinlongxa/AutolayoutDemo\">代码在这里</a></p>\n"},{"layout":"post","title":"Content Hugging与Content Compression Resistance","_content":"\n最近在使用Autolayout遇到了一个问题，我设置了一个UILabel的宽度约束，希望这个UILabel在显示时，如果内容宽度没有超过约束的宽度，则以约束的宽度显示，如果\n内容宽度超过约束的宽度，则以内容的宽度显示，这时，如果只设置宽度约束，UILabel会始终以约束的宽度显示，如果降低宽度约束，则UILabel就会使用以内容的宽度显示，\n始终无法达到我想要的效果，于是一番Google，便发现了Content Hugging与Content Compression Resistance两个概念。\n\n## 基本概念\n\n**Content Hugging Priority** 字面意思为内容紧缩，通过改变它的优先级，可以设置当View的大小大于实际内容的大小时，是否将View缩小，使其紧紧包裹住内容\n\n**Content Compression Resistance Priority** 字面意思为阻止内容紧缩，通过改变它的优先级，可以设置当View的大小小于实际内容的大小时，是否将View扩大，使其紧紧包裹内容\n\n##  实例应用\n\n本例将以一个UILabel为例，来说明一下ContentHugging与ContentCompressionResistance的具体设置方法。\n\n首先创建一个空项目，打开SB，拖入一个UILabel，然后设置一下三个约束：\n\n> 1. 水平居中对齐\n> 2. 垂直居中对齐\n> 3. 宽度为100\n\n为类方便观察，给Label加一个背景颜色，设置完运行如下图：\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.46.17.png)\n\n然后改变宽度约束的优先级为500，如图：\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.15.10.png)\n\n然后就可以开始设置ContentHuggingPriority与ContentCompressionResistancePriority了，设置界面如下：\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.30.26.png)\n\n首先设置水平方向上的ContentHuggingPriority为501，运行项目，显示效果如下：\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.44.05.png)\n\n如果设置水平方向上的ContentHuggingPriority为499，运行项目，显示效果如下：\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.46.17.png)\n\n这是因为当宽度约束的优先级大于ContentHuggingPriority，优先以约束的宽度显示，当宽度约束的优先级小于ContentHuggingPriority时，如果Label的大小\n大于内容的大小，则会按实际内容的大小显示。\n\n接下来改变Label的宽度约束值为30，然后运行项目，显示效果如下：\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.44.05.png)\n\n水平方向上ContentCompressionResistancePriority的默认值为750，将其改为499，则显示效果如下：\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2023.02.49.png)\n\n这是因为当宽度约束的优先级大于ContentCompressionResistancePriority，优先以约束的宽度显示，当宽度约束的优先级小于ContentCompressionResistancePriority\n时，如果Label的大小小于内容的大小，则会按实际内容的大小显示\n\n除了在SB中设置外，还可以在代码中设置，代码如下：\n\n```objectivec\n\n// 设置水平方向上内容紧缩的优先级为高\n[self.label setContentHuggingPriority:UILayoutPriorityDefaultHigh forAxis:UILayoutConstraintAxisHorizontal];\n\n// 设置垂直方向上阻止内容紧缩的优先级为低\n[self.label setContentCompressionResistancePriority:UILayoutPriorityDefaultLow forAxis:UILayoutConstraintAxisVertical];\n\n```\n","source":"_posts/2015-11-07-ContentHugging与ContentCompressionResistance.md","raw":"---\nlayout: post\ntitle: \"Content Hugging与Content Compression Resistance\"\ncategories: \"iOS开发\"\n---\n\n最近在使用Autolayout遇到了一个问题，我设置了一个UILabel的宽度约束，希望这个UILabel在显示时，如果内容宽度没有超过约束的宽度，则以约束的宽度显示，如果\n内容宽度超过约束的宽度，则以内容的宽度显示，这时，如果只设置宽度约束，UILabel会始终以约束的宽度显示，如果降低宽度约束，则UILabel就会使用以内容的宽度显示，\n始终无法达到我想要的效果，于是一番Google，便发现了Content Hugging与Content Compression Resistance两个概念。\n\n## 基本概念\n\n**Content Hugging Priority** 字面意思为内容紧缩，通过改变它的优先级，可以设置当View的大小大于实际内容的大小时，是否将View缩小，使其紧紧包裹住内容\n\n**Content Compression Resistance Priority** 字面意思为阻止内容紧缩，通过改变它的优先级，可以设置当View的大小小于实际内容的大小时，是否将View扩大，使其紧紧包裹内容\n\n##  实例应用\n\n本例将以一个UILabel为例，来说明一下ContentHugging与ContentCompressionResistance的具体设置方法。\n\n首先创建一个空项目，打开SB，拖入一个UILabel，然后设置一下三个约束：\n\n> 1. 水平居中对齐\n> 2. 垂直居中对齐\n> 3. 宽度为100\n\n为类方便观察，给Label加一个背景颜色，设置完运行如下图：\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.46.17.png)\n\n然后改变宽度约束的优先级为500，如图：\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.15.10.png)\n\n然后就可以开始设置ContentHuggingPriority与ContentCompressionResistancePriority了，设置界面如下：\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.30.26.png)\n\n首先设置水平方向上的ContentHuggingPriority为501，运行项目，显示效果如下：\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.44.05.png)\n\n如果设置水平方向上的ContentHuggingPriority为499，运行项目，显示效果如下：\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.46.17.png)\n\n这是因为当宽度约束的优先级大于ContentHuggingPriority，优先以约束的宽度显示，当宽度约束的优先级小于ContentHuggingPriority时，如果Label的大小\n大于内容的大小，则会按实际内容的大小显示。\n\n接下来改变Label的宽度约束值为30，然后运行项目，显示效果如下：\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.44.05.png)\n\n水平方向上ContentCompressionResistancePriority的默认值为750，将其改为499，则显示效果如下：\n\n![image](http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2023.02.49.png)\n\n这是因为当宽度约束的优先级大于ContentCompressionResistancePriority，优先以约束的宽度显示，当宽度约束的优先级小于ContentCompressionResistancePriority\n时，如果Label的大小小于内容的大小，则会按实际内容的大小显示\n\n除了在SB中设置外，还可以在代码中设置，代码如下：\n\n```objectivec\n\n// 设置水平方向上内容紧缩的优先级为高\n[self.label setContentHuggingPriority:UILayoutPriorityDefaultHigh forAxis:UILayoutConstraintAxisHorizontal];\n\n// 设置垂直方向上阻止内容紧缩的优先级为低\n[self.label setContentCompressionResistancePriority:UILayoutPriorityDefaultLow forAxis:UILayoutConstraintAxisVertical];\n\n```\n","slug":"ContentHugging与ContentCompressionResistance","published":1,"date":"2015-11-06T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oaat000yzrm08kymdii6","content":"<p>最近在使用Autolayout遇到了一个问题，我设置了一个UILabel的宽度约束，希望这个UILabel在显示时，如果内容宽度没有超过约束的宽度，则以约束的宽度显示，如果<br>内容宽度超过约束的宽度，则以内容的宽度显示，这时，如果只设置宽度约束，UILabel会始终以约束的宽度显示，如果降低宽度约束，则UILabel就会使用以内容的宽度显示，<br>始终无法达到我想要的效果，于是一番Google，便发现了Content Hugging与Content Compression Resistance两个概念。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p><strong>Content Hugging Priority</strong> 字面意思为内容紧缩，通过改变它的优先级，可以设置当View的大小大于实际内容的大小时，是否将View缩小，使其紧紧包裹住内容</p>\n<p><strong>Content Compression Resistance Priority</strong> 字面意思为阻止内容紧缩，通过改变它的优先级，可以设置当View的大小小于实际内容的大小时，是否将View扩大，使其紧紧包裹内容</p>\n<h2 id=\"实例应用\"><a href=\"#实例应用\" class=\"headerlink\" title=\"实例应用\"></a>实例应用</h2><p>本例将以一个UILabel为例，来说明一下ContentHugging与ContentCompressionResistance的具体设置方法。</p>\n<p>首先创建一个空项目，打开SB，拖入一个UILabel，然后设置一下三个约束：</p>\n<blockquote>\n<ol>\n<li>水平居中对齐</li>\n<li>垂直居中对齐</li>\n<li>宽度为100</li>\n</ol>\n</blockquote>\n<p>为类方便观察，给Label加一个背景颜色，设置完运行如下图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.46.17.png\" alt=\"image\"></p>\n<p>然后改变宽度约束的优先级为500，如图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.15.10.png\" alt=\"image\"></p>\n<p>然后就可以开始设置ContentHuggingPriority与ContentCompressionResistancePriority了，设置界面如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.30.26.png\" alt=\"image\"></p>\n<p>首先设置水平方向上的ContentHuggingPriority为501，运行项目，显示效果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.44.05.png\" alt=\"image\"></p>\n<p>如果设置水平方向上的ContentHuggingPriority为499，运行项目，显示效果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.46.17.png\" alt=\"image\"></p>\n<p>这是因为当宽度约束的优先级大于ContentHuggingPriority，优先以约束的宽度显示，当宽度约束的优先级小于ContentHuggingPriority时，如果Label的大小<br>大于内容的大小，则会按实际内容的大小显示。</p>\n<p>接下来改变Label的宽度约束值为30，然后运行项目，显示效果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.44.05.png\" alt=\"image\"></p>\n<p>水平方向上ContentCompressionResistancePriority的默认值为750，将其改为499，则显示效果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2023.02.49.png\" alt=\"image\"></p>\n<p>这是因为当宽度约束的优先级大于ContentCompressionResistancePriority，优先以约束的宽度显示，当宽度约束的优先级小于ContentCompressionResistancePriority<br>时，如果Label的大小小于内容的大小，则会按实际内容的大小显示</p>\n<p>除了在SB中设置外，还可以在代码中设置，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 设置水平方向上内容紧缩的优先级为高</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.label setContentHuggingPriority:<span class=\"built_in\">UILayoutPriorityDefaultHigh</span> forAxis:<span class=\"built_in\">UILayoutConstraintAxisHorizontal</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 设置垂直方向上阻止内容紧缩的优先级为低</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.label setContentCompressionResistancePriority:<span class=\"built_in\">UILayoutPriorityDefaultLow</span> forAxis:<span class=\"built_in\">UILayoutConstraintAxisVertical</span>];</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>最近在使用Autolayout遇到了一个问题，我设置了一个UILabel的宽度约束，希望这个UILabel在显示时，如果内容宽度没有超过约束的宽度，则以约束的宽度显示，如果<br>内容宽度超过约束的宽度，则以内容的宽度显示，这时，如果只设置宽度约束，UILabel会始终以约束的宽度显示，如果降低宽度约束，则UILabel就会使用以内容的宽度显示，<br>始终无法达到我想要的效果，于是一番Google，便发现了Content Hugging与Content Compression Resistance两个概念。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p><strong>Content Hugging Priority</strong> 字面意思为内容紧缩，通过改变它的优先级，可以设置当View的大小大于实际内容的大小时，是否将View缩小，使其紧紧包裹住内容</p>\n<p><strong>Content Compression Resistance Priority</strong> 字面意思为阻止内容紧缩，通过改变它的优先级，可以设置当View的大小小于实际内容的大小时，是否将View扩大，使其紧紧包裹内容</p>\n<h2 id=\"实例应用\"><a href=\"#实例应用\" class=\"headerlink\" title=\"实例应用\"></a>实例应用</h2><p>本例将以一个UILabel为例，来说明一下ContentHugging与ContentCompressionResistance的具体设置方法。</p>\n<p>首先创建一个空项目，打开SB，拖入一个UILabel，然后设置一下三个约束：</p>\n<blockquote>\n<ol>\n<li>水平居中对齐</li>\n<li>垂直居中对齐</li>\n<li>宽度为100</li>\n</ol>\n</blockquote>\n<p>为类方便观察，给Label加一个背景颜色，设置完运行如下图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.46.17.png\" alt=\"image\"></p>\n<p>然后改变宽度约束的优先级为500，如图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.15.10.png\" alt=\"image\"></p>\n<p>然后就可以开始设置ContentHuggingPriority与ContentCompressionResistancePriority了，设置界面如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.30.26.png\" alt=\"image\"></p>\n<p>首先设置水平方向上的ContentHuggingPriority为501，运行项目，显示效果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.44.05.png\" alt=\"image\"></p>\n<p>如果设置水平方向上的ContentHuggingPriority为499，运行项目，显示效果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.46.17.png\" alt=\"image\"></p>\n<p>这是因为当宽度约束的优先级大于ContentHuggingPriority，优先以约束的宽度显示，当宽度约束的优先级小于ContentHuggingPriority时，如果Label的大小<br>大于内容的大小，则会按实际内容的大小显示。</p>\n<p>接下来改变Label的宽度约束值为30，然后运行项目，显示效果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2022.44.05.png\" alt=\"image\"></p>\n<p>水平方向上ContentCompressionResistancePriority的默认值为750，将其改为499，则显示效果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/Screen%20Shot%202015-11-07%20at%2023.02.49.png\" alt=\"image\"></p>\n<p>这是因为当宽度约束的优先级大于ContentCompressionResistancePriority，优先以约束的宽度显示，当宽度约束的优先级小于ContentCompressionResistancePriority<br>时，如果Label的大小小于内容的大小，则会按实际内容的大小显示</p>\n<p>除了在SB中设置外，还可以在代码中设置，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 设置水平方向上内容紧缩的优先级为高</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.label setContentHuggingPriority:<span class=\"built_in\">UILayoutPriorityDefaultHigh</span> forAxis:<span class=\"built_in\">UILayoutConstraintAxisHorizontal</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 设置垂直方向上阻止内容紧缩的优先级为低</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.label setContentCompressionResistancePriority:<span class=\"built_in\">UILayoutPriorityDefaultLow</span> forAxis:<span class=\"built_in\">UILayoutConstraintAxisVertical</span>];</div></pre></td></tr></table></figure>\n"},{"layout":"post","title":"CoreAnimation编程指南学习笔记(2)","_content":"\n## 第六章 动画\n\n### 动画类\n\n* CABasicAnimation提供了在图层的属性值间简单的插入。\n* CAKeyframeAnimation提供支持关键帧动画。你指定动画的一个图层属性的关键路径，一个表示在动画的每个阶段的价值的数组，还有一个关键帧时间的数组和时间函数。\n* CATransition提供了一个影响整个图层的内容过渡效果。在动画显示过程中采用淡出（fade）、推出(push)、显露(reveal)图层的内容。 常用的过渡效果可以通过提供你自己定制的核心图像滤镜来扩展。\n\n### 隐式动画\n\n隐式动画指所有修改CALayer的可动画属性，默认会都会带有动画。例如`self.layer.position = CGPointMake(200, 200);`默认是带有动画效果的。注意一定是修改layer属性，修改UIView的属性，默认是不带有隐式动画的。而且UIView默认带有的layer属性也是不带隐式动画的。\n\n### 显示动画\n\n```objectivec\n\tCABasicAnimation *anim = [CABasicAnimation \tanimationWithKeyPath:@\"opacity\"];\n    anim.fromValue = @(1.0);\n    anim.toValue = @(0.5);\n    anim.autoreverses = YES;\n    anim.repeatCount = 10;\n    anim.duration = 2;\n    [self.layer addAnimation:anim forKey:@\"anim\"];\n```\n\n## 第七章 事务\n\n图层的每一个改变都是事务的一部分。隐式分为显示事务和隐式事务。隐式事务由系统自动创建和提交，在修改图层属性时，系统会自动创建一个事务，在下一次运行循环时自动提交。显示事务由用户程序控制创建和提交。一旦创建了显示事务，系统就不会再创建隐式事务。\n\n### 使用显式事务禁止隐式动画\n\n```objectivec\n\t[CATransaction begin];\n    [CATransaction setDisableActions:YES];\n    self.layer.position = CGPointMake(200, 200);\n    [CATransaction commit];\n```\n\n### 修改隐式动画的动画时长\n\n```objectivec\n\t[CATransaction begin];\n    [CATransaction setAnimationDuration:2.0];\n    self.layer.position = CGPointMake(200, 200);\n    [CATransaction commit];\n```\n\n## 第八章 KVC\n\nCoreAnimation是通过KVC来实现对不同字段或关键路径进行动画的，使用方法如下\n\n```objectivec\n[theLayer setValue:[NSNumber numberWithInteger:50] forKey:@\"someKey\"];\n```\n\n使用`defaultValueForKey:`可以获取字段的默认值。\n\nCAAnimation提供支持使用关键路径访问选择的结构字段。目前支持的字段如下\n\n![](http://7xn88v.com1.z0.glb.clouddn.com/2015-12-13_10-42-53.jpg)\n","source":"_posts/2015-12-13-CoreAnimation编程指南学习笔记(2).md","raw":"---\nlayout: post\ntitle: \"CoreAnimation编程指南学习笔记(2)\"\ncategories: \"读书笔记\"\n---\n\n## 第六章 动画\n\n### 动画类\n\n* CABasicAnimation提供了在图层的属性值间简单的插入。\n* CAKeyframeAnimation提供支持关键帧动画。你指定动画的一个图层属性的关键路径，一个表示在动画的每个阶段的价值的数组，还有一个关键帧时间的数组和时间函数。\n* CATransition提供了一个影响整个图层的内容过渡效果。在动画显示过程中采用淡出（fade）、推出(push)、显露(reveal)图层的内容。 常用的过渡效果可以通过提供你自己定制的核心图像滤镜来扩展。\n\n### 隐式动画\n\n隐式动画指所有修改CALayer的可动画属性，默认会都会带有动画。例如`self.layer.position = CGPointMake(200, 200);`默认是带有动画效果的。注意一定是修改layer属性，修改UIView的属性，默认是不带有隐式动画的。而且UIView默认带有的layer属性也是不带隐式动画的。\n\n### 显示动画\n\n```objectivec\n\tCABasicAnimation *anim = [CABasicAnimation \tanimationWithKeyPath:@\"opacity\"];\n    anim.fromValue = @(1.0);\n    anim.toValue = @(0.5);\n    anim.autoreverses = YES;\n    anim.repeatCount = 10;\n    anim.duration = 2;\n    [self.layer addAnimation:anim forKey:@\"anim\"];\n```\n\n## 第七章 事务\n\n图层的每一个改变都是事务的一部分。隐式分为显示事务和隐式事务。隐式事务由系统自动创建和提交，在修改图层属性时，系统会自动创建一个事务，在下一次运行循环时自动提交。显示事务由用户程序控制创建和提交。一旦创建了显示事务，系统就不会再创建隐式事务。\n\n### 使用显式事务禁止隐式动画\n\n```objectivec\n\t[CATransaction begin];\n    [CATransaction setDisableActions:YES];\n    self.layer.position = CGPointMake(200, 200);\n    [CATransaction commit];\n```\n\n### 修改隐式动画的动画时长\n\n```objectivec\n\t[CATransaction begin];\n    [CATransaction setAnimationDuration:2.0];\n    self.layer.position = CGPointMake(200, 200);\n    [CATransaction commit];\n```\n\n## 第八章 KVC\n\nCoreAnimation是通过KVC来实现对不同字段或关键路径进行动画的，使用方法如下\n\n```objectivec\n[theLayer setValue:[NSNumber numberWithInteger:50] forKey:@\"someKey\"];\n```\n\n使用`defaultValueForKey:`可以获取字段的默认值。\n\nCAAnimation提供支持使用关键路径访问选择的结构字段。目前支持的字段如下\n\n![](http://7xn88v.com1.z0.glb.clouddn.com/2015-12-13_10-42-53.jpg)\n","slug":"CoreAnimation编程指南学习笔记(2)","published":1,"date":"2015-12-12T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oaax0011zrm05t5fvh5p","content":"<h2 id=\"第六章-动画\"><a href=\"#第六章-动画\" class=\"headerlink\" title=\"第六章 动画\"></a>第六章 动画</h2><h3 id=\"动画类\"><a href=\"#动画类\" class=\"headerlink\" title=\"动画类\"></a>动画类</h3><ul>\n<li>CABasicAnimation提供了在图层的属性值间简单的插入。</li>\n<li>CAKeyframeAnimation提供支持关键帧动画。你指定动画的一个图层属性的关键路径，一个表示在动画的每个阶段的价值的数组，还有一个关键帧时间的数组和时间函数。</li>\n<li>CATransition提供了一个影响整个图层的内容过渡效果。在动画显示过程中采用淡出（fade）、推出(push)、显露(reveal)图层的内容。 常用的过渡效果可以通过提供你自己定制的核心图像滤镜来扩展。</li>\n</ul>\n<h3 id=\"隐式动画\"><a href=\"#隐式动画\" class=\"headerlink\" title=\"隐式动画\"></a>隐式动画</h3><p>隐式动画指所有修改CALayer的可动画属性，默认会都会带有动画。例如<code>self.layer.position = CGPointMake(200, 200);</code>默认是带有动画效果的。注意一定是修改layer属性，修改UIView的属性，默认是不带有隐式动画的。而且UIView默认带有的layer属性也是不带隐式动画的。</p>\n<h3 id=\"显示动画\"><a href=\"#显示动画\" class=\"headerlink\" title=\"显示动画\"></a>显示动画</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">CABasicAnimation</span> *anim = [<span class=\"built_in\">CABasicAnimation</span> \tanimationWithKeyPath:<span class=\"string\">@\"opacity\"</span>];</div><div class=\"line\">   anim.fromValue = @(<span class=\"number\">1.0</span>);</div><div class=\"line\">   anim.toValue = @(<span class=\"number\">0.5</span>);</div><div class=\"line\">   anim.autoreverses = <span class=\"literal\">YES</span>;</div><div class=\"line\">   anim.repeatCount = <span class=\"number\">10</span>;</div><div class=\"line\">   anim.duration = <span class=\"number\">2</span>;</div><div class=\"line\">   [<span class=\"keyword\">self</span>.layer addAnimation:anim forKey:<span class=\"string\">@\"anim\"</span>];</div></pre></td></tr></table></figure>\n<h2 id=\"第七章-事务\"><a href=\"#第七章-事务\" class=\"headerlink\" title=\"第七章 事务\"></a>第七章 事务</h2><p>图层的每一个改变都是事务的一部分。隐式分为显示事务和隐式事务。隐式事务由系统自动创建和提交，在修改图层属性时，系统会自动创建一个事务，在下一次运行循环时自动提交。显示事务由用户程序控制创建和提交。一旦创建了显示事务，系统就不会再创建隐式事务。</p>\n<h3 id=\"使用显式事务禁止隐式动画\"><a href=\"#使用显式事务禁止隐式动画\" class=\"headerlink\" title=\"使用显式事务禁止隐式动画\"></a>使用显式事务禁止隐式动画</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"built_in\">CATransaction</span> begin];</div><div class=\"line\">   [<span class=\"built_in\">CATransaction</span> setDisableActions:<span class=\"literal\">YES</span>];</div><div class=\"line\">   <span class=\"keyword\">self</span>.layer.position = <span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">200</span>);</div><div class=\"line\">   [<span class=\"built_in\">CATransaction</span> commit];</div></pre></td></tr></table></figure>\n<h3 id=\"修改隐式动画的动画时长\"><a href=\"#修改隐式动画的动画时长\" class=\"headerlink\" title=\"修改隐式动画的动画时长\"></a>修改隐式动画的动画时长</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"built_in\">CATransaction</span> begin];</div><div class=\"line\">   [<span class=\"built_in\">CATransaction</span> setAnimationDuration:<span class=\"number\">2.0</span>];</div><div class=\"line\">   <span class=\"keyword\">self</span>.layer.position = <span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">200</span>);</div><div class=\"line\">   [<span class=\"built_in\">CATransaction</span> commit];</div></pre></td></tr></table></figure>\n<h2 id=\"第八章-KVC\"><a href=\"#第八章-KVC\" class=\"headerlink\" title=\"第八章 KVC\"></a>第八章 KVC</h2><p>CoreAnimation是通过KVC来实现对不同字段或关键路径进行动画的，使用方法如下</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[theLayer setValue:[<span class=\"built_in\">NSNumber</span> numberWithInteger:<span class=\"number\">50</span>] forKey:<span class=\"string\">@\"someKey\"</span>];</div></pre></td></tr></table></figure>\n<p>使用<code>defaultValueForKey:</code>可以获取字段的默认值。</p>\n<p>CAAnimation提供支持使用关键路径访问选择的结构字段。目前支持的字段如下</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/2015-12-13_10-42-53.jpg\" alt=\"\"></p>\n","excerpt":"","more":"<h2 id=\"第六章-动画\"><a href=\"#第六章-动画\" class=\"headerlink\" title=\"第六章 动画\"></a>第六章 动画</h2><h3 id=\"动画类\"><a href=\"#动画类\" class=\"headerlink\" title=\"动画类\"></a>动画类</h3><ul>\n<li>CABasicAnimation提供了在图层的属性值间简单的插入。</li>\n<li>CAKeyframeAnimation提供支持关键帧动画。你指定动画的一个图层属性的关键路径，一个表示在动画的每个阶段的价值的数组，还有一个关键帧时间的数组和时间函数。</li>\n<li>CATransition提供了一个影响整个图层的内容过渡效果。在动画显示过程中采用淡出（fade）、推出(push)、显露(reveal)图层的内容。 常用的过渡效果可以通过提供你自己定制的核心图像滤镜来扩展。</li>\n</ul>\n<h3 id=\"隐式动画\"><a href=\"#隐式动画\" class=\"headerlink\" title=\"隐式动画\"></a>隐式动画</h3><p>隐式动画指所有修改CALayer的可动画属性，默认会都会带有动画。例如<code>self.layer.position = CGPointMake(200, 200);</code>默认是带有动画效果的。注意一定是修改layer属性，修改UIView的属性，默认是不带有隐式动画的。而且UIView默认带有的layer属性也是不带隐式动画的。</p>\n<h3 id=\"显示动画\"><a href=\"#显示动画\" class=\"headerlink\" title=\"显示动画\"></a>显示动画</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">CABasicAnimation</span> *anim = [<span class=\"built_in\">CABasicAnimation</span> \tanimationWithKeyPath:<span class=\"string\">@\"opacity\"</span>];</div><div class=\"line\">   anim.fromValue = @(<span class=\"number\">1.0</span>);</div><div class=\"line\">   anim.toValue = @(<span class=\"number\">0.5</span>);</div><div class=\"line\">   anim.autoreverses = <span class=\"literal\">YES</span>;</div><div class=\"line\">   anim.repeatCount = <span class=\"number\">10</span>;</div><div class=\"line\">   anim.duration = <span class=\"number\">2</span>;</div><div class=\"line\">   [<span class=\"keyword\">self</span>.layer addAnimation:anim forKey:<span class=\"string\">@\"anim\"</span>];</div></pre></td></tr></table></figure>\n<h2 id=\"第七章-事务\"><a href=\"#第七章-事务\" class=\"headerlink\" title=\"第七章 事务\"></a>第七章 事务</h2><p>图层的每一个改变都是事务的一部分。隐式分为显示事务和隐式事务。隐式事务由系统自动创建和提交，在修改图层属性时，系统会自动创建一个事务，在下一次运行循环时自动提交。显示事务由用户程序控制创建和提交。一旦创建了显示事务，系统就不会再创建隐式事务。</p>\n<h3 id=\"使用显式事务禁止隐式动画\"><a href=\"#使用显式事务禁止隐式动画\" class=\"headerlink\" title=\"使用显式事务禁止隐式动画\"></a>使用显式事务禁止隐式动画</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"built_in\">CATransaction</span> begin];</div><div class=\"line\">   [<span class=\"built_in\">CATransaction</span> setDisableActions:<span class=\"literal\">YES</span>];</div><div class=\"line\">   <span class=\"keyword\">self</span>.layer.position = <span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">200</span>);</div><div class=\"line\">   [<span class=\"built_in\">CATransaction</span> commit];</div></pre></td></tr></table></figure>\n<h3 id=\"修改隐式动画的动画时长\"><a href=\"#修改隐式动画的动画时长\" class=\"headerlink\" title=\"修改隐式动画的动画时长\"></a>修改隐式动画的动画时长</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"built_in\">CATransaction</span> begin];</div><div class=\"line\">   [<span class=\"built_in\">CATransaction</span> setAnimationDuration:<span class=\"number\">2.0</span>];</div><div class=\"line\">   <span class=\"keyword\">self</span>.layer.position = <span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">200</span>);</div><div class=\"line\">   [<span class=\"built_in\">CATransaction</span> commit];</div></pre></td></tr></table></figure>\n<h2 id=\"第八章-KVC\"><a href=\"#第八章-KVC\" class=\"headerlink\" title=\"第八章 KVC\"></a>第八章 KVC</h2><p>CoreAnimation是通过KVC来实现对不同字段或关键路径进行动画的，使用方法如下</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[theLayer setValue:[<span class=\"built_in\">NSNumber</span> numberWithInteger:<span class=\"number\">50</span>] forKey:<span class=\"string\">@\"someKey\"</span>];</div></pre></td></tr></table></figure>\n<p>使用<code>defaultValueForKey:</code>可以获取字段的默认值。</p>\n<p>CAAnimation提供支持使用关键路径访问选择的结构字段。目前支持的字段如下</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/2015-12-13_10-42-53.jpg\" alt=\"\"></p>\n"},{"layout":"post","title":"CoreAnimation编程指南学习笔记(1)","_content":"\n## 第一章：核心动画概念\n\nCoreAnimation框架中类的分类\n\n* 提供显示内容的图层类\n* 动画和计时类\n* 布局和约束类\n* 事务类，在原子更新的时候组合图层类\n\n\n### 图层类（Layer Classes）\n\nCALayer是所有层类的父类，几个常见的图层子类：CAScrollLayer,CATextLayer,CATiledLayer等\n\n### 动画类和计时类\n\nCAAnimation是动画类的基类，他实现了CAMediaTiming协议，提供了动画的持续时间，速度，和重复计数等。他也实现了CAAction协议，该协议为图层触发一个动画动作提供了标准化响应。\n\n动画类同时定义了一个使用贝塞尔曲线来描述动画改变的时间函数。\n\n* CATransition：提供了一个图层改变的过渡效果，他能影响图层的整个内容。\n* CAAnimationGroup:组动画\n* CAPropertyAnimation:属性动画\n* CABasicAnimation:基础动画\n* CAKeyframeAnimation:关键帧动画\n\n### 布局管理类\n\nCAConstraint类是一个布局管理类，他可以指定子图层类限制于你指定的约束集合。\n\n### 事务管理类\n\nCATransaction是核心动画里面负责协调多个动画原子更新显示操作。事务支持嵌套使用。核心动画支持两种事务：隐式事务和显式事务。\n\n## 第二章：渲染架构\n\n每个可见的图层树由两个相应的树组成，一个是呈现树，一个是渲染树。修改图层的一个属性，图层树里相应的值会被马上更新，但是呈现树里面的值在将要显示给用户的时候才会被更新为新值。\n\n## 第三章：几何变换\n\nanchorPoint:锚点，他指定了bounds相对于position的值，同时也作为变换时候的支点。在Autolayout设置约束时，锚点的值也会影响视图显示的位置。\n\n几何变换：CATransform3D，可以使用变换函数进行变换，例如CATransform3DMakeTranslation，CATransform3DTranslate等，也可以通过键值路径修改变换。\n\n## 第四章：图层树结构\n\n图层树与视图的结构很类似：\n\n* 每个图层定义了一个基于其父图层的坐标系的坐标系，当一个图层变换的时候，他的子图层同样变换\n* 一个动态的图层树，可以在程序运行的时候重新设置，图层可以添加，也可以删除\n\nios中，每个UIView的实例会自动创建一个CALayer类的实体，视图为图层提供了底层的事件处理，图层为视图提供了显示的内容。\n\n## 第五章：图层的内容\n\n使用CALayer无需创建继承子类，直接设置CALayer的contents属性即可，contents属性是一个CGImageRef类型，这样子创建比使用UIImageView效率要高\n\n```objectivec\nself.myLayer = [[CALayer alloc] init];\nself.myLayer.bounds = CGRectMake(0, 0, 100, 100);\nself.myLayer.position = CGPointMake(100, 100);\nself.myLayer.backgroundColor = [UIColor redColor].CGColor;\nUIImage *image = [UIImage imageNamed:@\"1.JPG\"];\nself.myLayer.contents = (__bridge id _Nullable)(image.CGImage);\n[self.view.layer addSublayer:self.myLayer];\n```\n\n\n也可以通过代理方法，提供CALayer的内容，有两个代理方法：`- (void)displayLayer:(CALayer *)theLayer`与`- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx`, 要通知系统重绘图层，只需要调用CALayer的`setNeedsDisplay`或者`setNeedsDisplayInRect:`方法或者把图层的needsDisplayOnBoundsChange属性值设置为YES即可。\n\n\n```objectivec\n- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx {\n    CGMutablePathRef thePath = CGPathCreateMutable();\n    CGPathMoveToPoint(thePath,NULL,15.0f,15.f);\n    CGPathAddCurveToPoint(thePath,\n                          NULL,\n                          15.f,250.0f,\n                          295.0f,250.0f,\n                          295.0f,15.0f);\n    CGContextBeginPath(ctx);\n    CGContextAddPath(ctx, thePath );\n    CGContextSetLineWidth(ctx, 5);\n    CGContextStrokePath(ctx);\n    // release the path\n    CFRelease(thePath);\n}\n\n- (void)displayLayer:(CALayer *)layer {\n    UIImage *image = [UIImage imageNamed:@\"1.JPG\"];\n    layer.contents = (__bridge id _Nullable)(image.CGImage);\n}\n```\n\n\n除了设置代理方法，也可以通过继承CALayer，重写`display`方法或`- (void)drawInContext:(CGContextRef)theContext`方法来自定义图层\n\nCALayer的contentsGravity属性相当于UIView的contentMode属性。\n","source":"_posts/2015-12-06-CoreAnimation编程指南学习笔记(1).md","raw":"---\nlayout: post\ntitle: \"CoreAnimation编程指南学习笔记(1)\"\ncategories: \"读书笔记\"\n---\n\n## 第一章：核心动画概念\n\nCoreAnimation框架中类的分类\n\n* 提供显示内容的图层类\n* 动画和计时类\n* 布局和约束类\n* 事务类，在原子更新的时候组合图层类\n\n\n### 图层类（Layer Classes）\n\nCALayer是所有层类的父类，几个常见的图层子类：CAScrollLayer,CATextLayer,CATiledLayer等\n\n### 动画类和计时类\n\nCAAnimation是动画类的基类，他实现了CAMediaTiming协议，提供了动画的持续时间，速度，和重复计数等。他也实现了CAAction协议，该协议为图层触发一个动画动作提供了标准化响应。\n\n动画类同时定义了一个使用贝塞尔曲线来描述动画改变的时间函数。\n\n* CATransition：提供了一个图层改变的过渡效果，他能影响图层的整个内容。\n* CAAnimationGroup:组动画\n* CAPropertyAnimation:属性动画\n* CABasicAnimation:基础动画\n* CAKeyframeAnimation:关键帧动画\n\n### 布局管理类\n\nCAConstraint类是一个布局管理类，他可以指定子图层类限制于你指定的约束集合。\n\n### 事务管理类\n\nCATransaction是核心动画里面负责协调多个动画原子更新显示操作。事务支持嵌套使用。核心动画支持两种事务：隐式事务和显式事务。\n\n## 第二章：渲染架构\n\n每个可见的图层树由两个相应的树组成，一个是呈现树，一个是渲染树。修改图层的一个属性，图层树里相应的值会被马上更新，但是呈现树里面的值在将要显示给用户的时候才会被更新为新值。\n\n## 第三章：几何变换\n\nanchorPoint:锚点，他指定了bounds相对于position的值，同时也作为变换时候的支点。在Autolayout设置约束时，锚点的值也会影响视图显示的位置。\n\n几何变换：CATransform3D，可以使用变换函数进行变换，例如CATransform3DMakeTranslation，CATransform3DTranslate等，也可以通过键值路径修改变换。\n\n## 第四章：图层树结构\n\n图层树与视图的结构很类似：\n\n* 每个图层定义了一个基于其父图层的坐标系的坐标系，当一个图层变换的时候，他的子图层同样变换\n* 一个动态的图层树，可以在程序运行的时候重新设置，图层可以添加，也可以删除\n\nios中，每个UIView的实例会自动创建一个CALayer类的实体，视图为图层提供了底层的事件处理，图层为视图提供了显示的内容。\n\n## 第五章：图层的内容\n\n使用CALayer无需创建继承子类，直接设置CALayer的contents属性即可，contents属性是一个CGImageRef类型，这样子创建比使用UIImageView效率要高\n\n```objectivec\nself.myLayer = [[CALayer alloc] init];\nself.myLayer.bounds = CGRectMake(0, 0, 100, 100);\nself.myLayer.position = CGPointMake(100, 100);\nself.myLayer.backgroundColor = [UIColor redColor].CGColor;\nUIImage *image = [UIImage imageNamed:@\"1.JPG\"];\nself.myLayer.contents = (__bridge id _Nullable)(image.CGImage);\n[self.view.layer addSublayer:self.myLayer];\n```\n\n\n也可以通过代理方法，提供CALayer的内容，有两个代理方法：`- (void)displayLayer:(CALayer *)theLayer`与`- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx`, 要通知系统重绘图层，只需要调用CALayer的`setNeedsDisplay`或者`setNeedsDisplayInRect:`方法或者把图层的needsDisplayOnBoundsChange属性值设置为YES即可。\n\n\n```objectivec\n- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx {\n    CGMutablePathRef thePath = CGPathCreateMutable();\n    CGPathMoveToPoint(thePath,NULL,15.0f,15.f);\n    CGPathAddCurveToPoint(thePath,\n                          NULL,\n                          15.f,250.0f,\n                          295.0f,250.0f,\n                          295.0f,15.0f);\n    CGContextBeginPath(ctx);\n    CGContextAddPath(ctx, thePath );\n    CGContextSetLineWidth(ctx, 5);\n    CGContextStrokePath(ctx);\n    // release the path\n    CFRelease(thePath);\n}\n\n- (void)displayLayer:(CALayer *)layer {\n    UIImage *image = [UIImage imageNamed:@\"1.JPG\"];\n    layer.contents = (__bridge id _Nullable)(image.CGImage);\n}\n```\n\n\n除了设置代理方法，也可以通过继承CALayer，重写`display`方法或`- (void)drawInContext:(CGContextRef)theContext`方法来自定义图层\n\nCALayer的contentsGravity属性相当于UIView的contentMode属性。\n","slug":"CoreAnimation编程指南学习笔记(1)","published":1,"date":"2015-12-05T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oaaz0013zrm0s2h8pj5n","content":"<h2 id=\"第一章：核心动画概念\"><a href=\"#第一章：核心动画概念\" class=\"headerlink\" title=\"第一章：核心动画概念\"></a>第一章：核心动画概念</h2><p>CoreAnimation框架中类的分类</p>\n<ul>\n<li>提供显示内容的图层类</li>\n<li>动画和计时类</li>\n<li>布局和约束类</li>\n<li>事务类，在原子更新的时候组合图层类</li>\n</ul>\n<h3 id=\"图层类（Layer-Classes）\"><a href=\"#图层类（Layer-Classes）\" class=\"headerlink\" title=\"图层类（Layer Classes）\"></a>图层类（Layer Classes）</h3><p>CALayer是所有层类的父类，几个常见的图层子类：CAScrollLayer,CATextLayer,CATiledLayer等</p>\n<h3 id=\"动画类和计时类\"><a href=\"#动画类和计时类\" class=\"headerlink\" title=\"动画类和计时类\"></a>动画类和计时类</h3><p>CAAnimation是动画类的基类，他实现了CAMediaTiming协议，提供了动画的持续时间，速度，和重复计数等。他也实现了CAAction协议，该协议为图层触发一个动画动作提供了标准化响应。</p>\n<p>动画类同时定义了一个使用贝塞尔曲线来描述动画改变的时间函数。</p>\n<ul>\n<li>CATransition：提供了一个图层改变的过渡效果，他能影响图层的整个内容。</li>\n<li>CAAnimationGroup:组动画</li>\n<li>CAPropertyAnimation:属性动画</li>\n<li>CABasicAnimation:基础动画</li>\n<li>CAKeyframeAnimation:关键帧动画</li>\n</ul>\n<h3 id=\"布局管理类\"><a href=\"#布局管理类\" class=\"headerlink\" title=\"布局管理类\"></a>布局管理类</h3><p>CAConstraint类是一个布局管理类，他可以指定子图层类限制于你指定的约束集合。</p>\n<h3 id=\"事务管理类\"><a href=\"#事务管理类\" class=\"headerlink\" title=\"事务管理类\"></a>事务管理类</h3><p>CATransaction是核心动画里面负责协调多个动画原子更新显示操作。事务支持嵌套使用。核心动画支持两种事务：隐式事务和显式事务。</p>\n<h2 id=\"第二章：渲染架构\"><a href=\"#第二章：渲染架构\" class=\"headerlink\" title=\"第二章：渲染架构\"></a>第二章：渲染架构</h2><p>每个可见的图层树由两个相应的树组成，一个是呈现树，一个是渲染树。修改图层的一个属性，图层树里相应的值会被马上更新，但是呈现树里面的值在将要显示给用户的时候才会被更新为新值。</p>\n<h2 id=\"第三章：几何变换\"><a href=\"#第三章：几何变换\" class=\"headerlink\" title=\"第三章：几何变换\"></a>第三章：几何变换</h2><p>anchorPoint:锚点，他指定了bounds相对于position的值，同时也作为变换时候的支点。在Autolayout设置约束时，锚点的值也会影响视图显示的位置。</p>\n<p>几何变换：CATransform3D，可以使用变换函数进行变换，例如CATransform3DMakeTranslation，CATransform3DTranslate等，也可以通过键值路径修改变换。</p>\n<h2 id=\"第四章：图层树结构\"><a href=\"#第四章：图层树结构\" class=\"headerlink\" title=\"第四章：图层树结构\"></a>第四章：图层树结构</h2><p>图层树与视图的结构很类似：</p>\n<ul>\n<li>每个图层定义了一个基于其父图层的坐标系的坐标系，当一个图层变换的时候，他的子图层同样变换</li>\n<li>一个动态的图层树，可以在程序运行的时候重新设置，图层可以添加，也可以删除</li>\n</ul>\n<p>ios中，每个UIView的实例会自动创建一个CALayer类的实体，视图为图层提供了底层的事件处理，图层为视图提供了显示的内容。</p>\n<h2 id=\"第五章：图层的内容\"><a href=\"#第五章：图层的内容\" class=\"headerlink\" title=\"第五章：图层的内容\"></a>第五章：图层的内容</h2><p>使用CALayer无需创建继承子类，直接设置CALayer的contents属性即可，contents属性是一个CGImageRef类型，这样子创建比使用UIImageView效率要高</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.myLayer = [[<span class=\"built_in\">CALayer</span> alloc] init];</div><div class=\"line\"><span class=\"keyword\">self</span>.myLayer.bounds = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</div><div class=\"line\"><span class=\"keyword\">self</span>.myLayer.position = <span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>);</div><div class=\"line\"><span class=\"keyword\">self</span>.myLayer.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor].CGColor;</div><div class=\"line\"><span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"1.JPG\"</span>];</div><div class=\"line\"><span class=\"keyword\">self</span>.myLayer.contents = (__bridge <span class=\"keyword\">id</span> _Nullable)(image.CGImage);</div><div class=\"line\">[<span class=\"keyword\">self</span>.view.layer addSublayer:<span class=\"keyword\">self</span>.myLayer];</div></pre></td></tr></table></figure>\n<p>也可以通过代理方法，提供CALayer的内容，有两个代理方法：<code>- (void)displayLayer:(CALayer *)theLayer</code>与<code>- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx</code>, 要通知系统重绘图层，只需要调用CALayer的<code>setNeedsDisplay</code>或者<code>setNeedsDisplayInRect:</code>方法或者把图层的needsDisplayOnBoundsChange属性值设置为YES即可。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)drawLayer:(<span class=\"built_in\">CALayer</span> *)layer inContext:(<span class=\"built_in\">CGContextRef</span>)ctx &#123;</div><div class=\"line\">    <span class=\"built_in\">CGMutablePathRef</span> thePath = <span class=\"built_in\">CGPathCreateMutable</span>();</div><div class=\"line\">    <span class=\"built_in\">CGPathMoveToPoint</span>(thePath,<span class=\"literal\">NULL</span>,<span class=\"number\">15.0</span>f,<span class=\"number\">15.</span>f);</div><div class=\"line\">    <span class=\"built_in\">CGPathAddCurveToPoint</span>(thePath,</div><div class=\"line\">                          <span class=\"literal\">NULL</span>,</div><div class=\"line\">                          <span class=\"number\">15.</span>f,<span class=\"number\">250.0</span>f,</div><div class=\"line\">                          <span class=\"number\">295.0</span>f,<span class=\"number\">250.0</span>f,</div><div class=\"line\">                          <span class=\"number\">295.0</span>f,<span class=\"number\">15.0</span>f);</div><div class=\"line\">    <span class=\"built_in\">CGContextBeginPath</span>(ctx);</div><div class=\"line\">    <span class=\"built_in\">CGContextAddPath</span>(ctx, thePath );</div><div class=\"line\">    <span class=\"built_in\">CGContextSetLineWidth</span>(ctx, <span class=\"number\">5</span>);</div><div class=\"line\">    <span class=\"built_in\">CGContextStrokePath</span>(ctx);</div><div class=\"line\">    <span class=\"comment\">// release the path</span></div><div class=\"line\">    <span class=\"built_in\">CFRelease</span>(thePath);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)displayLayer:(<span class=\"built_in\">CALayer</span> *)layer &#123;</div><div class=\"line\">    <span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"1.JPG\"</span>];</div><div class=\"line\">    layer.contents = (__bridge <span class=\"keyword\">id</span> _Nullable)(image.CGImage);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>除了设置代理方法，也可以通过继承CALayer，重写<code>display</code>方法或<code>- (void)drawInContext:(CGContextRef)theContext</code>方法来自定义图层</p>\n<p>CALayer的contentsGravity属性相当于UIView的contentMode属性。</p>\n","excerpt":"","more":"<h2 id=\"第一章：核心动画概念\"><a href=\"#第一章：核心动画概念\" class=\"headerlink\" title=\"第一章：核心动画概念\"></a>第一章：核心动画概念</h2><p>CoreAnimation框架中类的分类</p>\n<ul>\n<li>提供显示内容的图层类</li>\n<li>动画和计时类</li>\n<li>布局和约束类</li>\n<li>事务类，在原子更新的时候组合图层类</li>\n</ul>\n<h3 id=\"图层类（Layer-Classes）\"><a href=\"#图层类（Layer-Classes）\" class=\"headerlink\" title=\"图层类（Layer Classes）\"></a>图层类（Layer Classes）</h3><p>CALayer是所有层类的父类，几个常见的图层子类：CAScrollLayer,CATextLayer,CATiledLayer等</p>\n<h3 id=\"动画类和计时类\"><a href=\"#动画类和计时类\" class=\"headerlink\" title=\"动画类和计时类\"></a>动画类和计时类</h3><p>CAAnimation是动画类的基类，他实现了CAMediaTiming协议，提供了动画的持续时间，速度，和重复计数等。他也实现了CAAction协议，该协议为图层触发一个动画动作提供了标准化响应。</p>\n<p>动画类同时定义了一个使用贝塞尔曲线来描述动画改变的时间函数。</p>\n<ul>\n<li>CATransition：提供了一个图层改变的过渡效果，他能影响图层的整个内容。</li>\n<li>CAAnimationGroup:组动画</li>\n<li>CAPropertyAnimation:属性动画</li>\n<li>CABasicAnimation:基础动画</li>\n<li>CAKeyframeAnimation:关键帧动画</li>\n</ul>\n<h3 id=\"布局管理类\"><a href=\"#布局管理类\" class=\"headerlink\" title=\"布局管理类\"></a>布局管理类</h3><p>CAConstraint类是一个布局管理类，他可以指定子图层类限制于你指定的约束集合。</p>\n<h3 id=\"事务管理类\"><a href=\"#事务管理类\" class=\"headerlink\" title=\"事务管理类\"></a>事务管理类</h3><p>CATransaction是核心动画里面负责协调多个动画原子更新显示操作。事务支持嵌套使用。核心动画支持两种事务：隐式事务和显式事务。</p>\n<h2 id=\"第二章：渲染架构\"><a href=\"#第二章：渲染架构\" class=\"headerlink\" title=\"第二章：渲染架构\"></a>第二章：渲染架构</h2><p>每个可见的图层树由两个相应的树组成，一个是呈现树，一个是渲染树。修改图层的一个属性，图层树里相应的值会被马上更新，但是呈现树里面的值在将要显示给用户的时候才会被更新为新值。</p>\n<h2 id=\"第三章：几何变换\"><a href=\"#第三章：几何变换\" class=\"headerlink\" title=\"第三章：几何变换\"></a>第三章：几何变换</h2><p>anchorPoint:锚点，他指定了bounds相对于position的值，同时也作为变换时候的支点。在Autolayout设置约束时，锚点的值也会影响视图显示的位置。</p>\n<p>几何变换：CATransform3D，可以使用变换函数进行变换，例如CATransform3DMakeTranslation，CATransform3DTranslate等，也可以通过键值路径修改变换。</p>\n<h2 id=\"第四章：图层树结构\"><a href=\"#第四章：图层树结构\" class=\"headerlink\" title=\"第四章：图层树结构\"></a>第四章：图层树结构</h2><p>图层树与视图的结构很类似：</p>\n<ul>\n<li>每个图层定义了一个基于其父图层的坐标系的坐标系，当一个图层变换的时候，他的子图层同样变换</li>\n<li>一个动态的图层树，可以在程序运行的时候重新设置，图层可以添加，也可以删除</li>\n</ul>\n<p>ios中，每个UIView的实例会自动创建一个CALayer类的实体，视图为图层提供了底层的事件处理，图层为视图提供了显示的内容。</p>\n<h2 id=\"第五章：图层的内容\"><a href=\"#第五章：图层的内容\" class=\"headerlink\" title=\"第五章：图层的内容\"></a>第五章：图层的内容</h2><p>使用CALayer无需创建继承子类，直接设置CALayer的contents属性即可，contents属性是一个CGImageRef类型，这样子创建比使用UIImageView效率要高</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.myLayer = [[<span class=\"built_in\">CALayer</span> alloc] init];</div><div class=\"line\"><span class=\"keyword\">self</span>.myLayer.bounds = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</div><div class=\"line\"><span class=\"keyword\">self</span>.myLayer.position = <span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>);</div><div class=\"line\"><span class=\"keyword\">self</span>.myLayer.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor].CGColor;</div><div class=\"line\"><span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"1.JPG\"</span>];</div><div class=\"line\"><span class=\"keyword\">self</span>.myLayer.contents = (__bridge <span class=\"keyword\">id</span> _Nullable)(image.CGImage);</div><div class=\"line\">[<span class=\"keyword\">self</span>.view.layer addSublayer:<span class=\"keyword\">self</span>.myLayer];</div></pre></td></tr></table></figure>\n<p>也可以通过代理方法，提供CALayer的内容，有两个代理方法：<code>- (void)displayLayer:(CALayer *)theLayer</code>与<code>- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx</code>, 要通知系统重绘图层，只需要调用CALayer的<code>setNeedsDisplay</code>或者<code>setNeedsDisplayInRect:</code>方法或者把图层的needsDisplayOnBoundsChange属性值设置为YES即可。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)drawLayer:(<span class=\"built_in\">CALayer</span> *)layer inContext:(<span class=\"built_in\">CGContextRef</span>)ctx &#123;</div><div class=\"line\">    <span class=\"built_in\">CGMutablePathRef</span> thePath = <span class=\"built_in\">CGPathCreateMutable</span>();</div><div class=\"line\">    <span class=\"built_in\">CGPathMoveToPoint</span>(thePath,<span class=\"literal\">NULL</span>,<span class=\"number\">15.0</span>f,<span class=\"number\">15.</span>f);</div><div class=\"line\">    <span class=\"built_in\">CGPathAddCurveToPoint</span>(thePath,</div><div class=\"line\">                          <span class=\"literal\">NULL</span>,</div><div class=\"line\">                          <span class=\"number\">15.</span>f,<span class=\"number\">250.0</span>f,</div><div class=\"line\">                          <span class=\"number\">295.0</span>f,<span class=\"number\">250.0</span>f,</div><div class=\"line\">                          <span class=\"number\">295.0</span>f,<span class=\"number\">15.0</span>f);</div><div class=\"line\">    <span class=\"built_in\">CGContextBeginPath</span>(ctx);</div><div class=\"line\">    <span class=\"built_in\">CGContextAddPath</span>(ctx, thePath );</div><div class=\"line\">    <span class=\"built_in\">CGContextSetLineWidth</span>(ctx, <span class=\"number\">5</span>);</div><div class=\"line\">    <span class=\"built_in\">CGContextStrokePath</span>(ctx);</div><div class=\"line\">    <span class=\"comment\">// release the path</span></div><div class=\"line\">    <span class=\"built_in\">CFRelease</span>(thePath);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)displayLayer:(<span class=\"built_in\">CALayer</span> *)layer &#123;</div><div class=\"line\">    <span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"1.JPG\"</span>];</div><div class=\"line\">    layer.contents = (__bridge <span class=\"keyword\">id</span> _Nullable)(image.CGImage);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>除了设置代理方法，也可以通过继承CALayer，重写<code>display</code>方法或<code>- (void)drawInContext:(CGContextRef)theContext</code>方法来自定义图层</p>\n<p>CALayer的contentsGravity属性相当于UIView的contentMode属性。</p>\n"},{"layout":"post","title":"RAC学习笔记","_content":"## RAC简介\n\nRAC要解决的问题是传统ios中事件，通知，回调的机制十分的繁琐。\n\n## 常规用法\n\n### target-action\n\n* RAC可以替代一般的target-action操作，例如监测textField的文字的改变，不是用RAC的写法\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    UITextField *text = ({\n        UITextField *text = [[UITextField alloc] init];\n        [self.view addSubview:text];\n        [text mas_makeConstraints:^(MASConstraintMaker *make) {\n            make.center.equalTo(self.view);\n            make.size.mas_equalTo(CGSizeMake(200, 40));\n        }];\n        text.backgroundColor = [UIColor redColor];\n        [text addTarget:self action:@selector(textDidChange:) forControlEvents:UIControlEventEditingChanged];\n        text;\n    });\n}\n\n- (void)textDidChange:(UITextField *)sender {\n    NSLog(@\"did change: %@\", sender);\n}\n```\n\n* 使用RAC的写法：\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    UITextField *text = ({\n        UITextField *text = [[UITextField alloc] init];\n        [self.view addSubview:text];\n        [text mas_makeConstraints:^(MASConstraintMaker *make) {\n            make.center.equalTo(self.view);\n            make.size.mas_equalTo(CGSizeMake(200, 40));\n        }];\n        text.backgroundColor = [UIColor redColor];\n\n        [[text rac_signalForControlEvents:UIControlEventEditingChanged] subscribeNext:^(id x) {\n            NSLog(@\"%@\", x);\n        }];\n\n        // 或者\n        //[text.rac_textSignal subscribeNext:^(id x) {\n        //    NSLog(@\"%@\", x);\n        //}];\n\n        text;\n    });\n}\n```\n\n### 手势中使用RAC\n\n* RAC可以替换手势的方法，代码如下\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    self.view.userInteractionEnabled = YES;\n    UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] init];\n    [[tap rac_gestureSignal] subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }];\n    [self.view addGestureRecognizer:tap];\n}\n```\n\n### 通知\n\n* RAC可以代替通知，并且RAC的通知不用移出\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIApplicationDidBecomeActiveNotification object:nil] subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }];\n}\n```\n\n### 定制器\n\n* RAC可以代替定时器\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // 延迟2秒执行\n    [[RACScheduler mainThreadScheduler] afterDelay:2.0 schedule:^{\n        NSLog(@\"haha\");\n    }];\n\n    // interval为间隔事件，scheduler为在那个线程上执行，leeway为多久之后开始执行。\n    [[RACSignal interval:2.0 onScheduler:[RACScheduler mainThreadScheduler] withLeeway:5.0] subscribeNext:^(NSDate x) {\n        NSLog(@\"%@\", x);\n    }];\n\n}\n```\n\n### 代理\n\n* RAC可以替换代理，但仅限没有返回值的代理\n\n```objectivec\n@interface ViewController ()<UITableViewDelegate>\n@property (nonatomic, strong) UIAlertView *alertView;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    self.alertView = [[UIAlertView alloc] initWithTitle:@\"RAC\" message:@\"test\" delegate:self cancelButtonTitle:@\"OK\" otherButtonTitles: nil];\n    [[self rac_signalForSelector:@selector(alertView:clickedButtonAtIndex:) fromProtocol:@protocol(UIAlertViewDelegate)]subscribeNext:^(id x) {\n        NSLog(@\"%@\",x);\n    }];\n    // 或者\n    // [[self.alertView rac_buttonClickedSignal] subscribeNext:^(id x) {\n    //     NSLog(@\"%@\", x);\n    // }];\n\n    [self.alertView show];\n}\n\n@end\n```\n\n### KVO\n\n* RAC可以替换KVO\n\n```objectivec\n@interface ViewController ()\n\n@property (nonatomic, assign) NSInteger index;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    [RACObserve(self, index) subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }];\n\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {\n    self.index++;\n}\n\n@end\n```\n\n## 高级用法\n\n### 创建信号\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        NSURLRequest *req = [NSURLRequest requestWithURL:[NSURL URLWithString:@\"http://www.baidu.com\"]];\n        [NSURLConnection sendAsynchronousRequest:req queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) {\n            if (connectionError) {\n                // 请求失败\n                [subscriber sendError:connectionError];\n            }\n            else {\n                // 请求成功\n                [subscriber sendNext:data];\n            }\n            [subscriber sendCompleted];\n        }];\n        return [RACDisposable disposableWithBlock:^{\n            // 取消订阅\n            NSLog(@\"cancel\");\n        }];\n    }];\n\n    RACDisposable *disposable = [signal subscribeNext:^(NSData *responseData) {\n        NSLog(@\"%@\", responseData);\n    } error:^(NSError *error) {\n        NSLog(@\"%@\", error);\n    } completed:^{\n        NSLog(@\"completed\");\n    }];\n\n    // 订阅完就取消订阅，这样就不会执行订阅block了\n    [disposable dispose];\n}\n```\n\n### 信号处理\n\n* map:映射\n* filter:过滤\n* delay:延时\n* startWith:在接收到信号前，先接收到一个信号\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    UITextField *textField = ({\n        UITextField *view = [[UITextField alloc] init];\n        [self.view addSubview:view];\n        [view mas_makeConstraints:^(MASConstraintMaker *make) {\n            make.center.equalTo(self.view);\n            make.size.mas_equalTo(CGSizeMake(200, 40));\n        }];\n        view.backgroundColor = [UIColor redColor];\n        view;\n    });\n\n    [[[[[[textField rac_textSignal] map:^id(id value) {\n        NSString *str = (NSString *)value;\n        return @([str length]);\n    }] filter:^BOOL(id value) {\n        return [value integerValue] > 3;\n    }] delay:2] startWith:@\"haha\"] subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }];\n}\n```\n\n* timeout:超时\n\n```objectivec\nRACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n\n    [[RACScheduler mainThreadScheduler] afterDelay:1.0 schedule:^{\n        [subscriber sendNext:@\"hello\"];\n        [subscriber sendCompleted];\n    }];\n    return nil;\n\n}] timeout:2.0 onScheduler:[RACScheduler mainThreadScheduler]]; // 如果请求没有在2秒内完成，则请求超时，会调用errorBlock\n\n[signal subscribeNext:^(NSData *responseData) {\n    NSLog(@\"%@\", responseData);\n} error:^(NSError *error) {\n    NSLog(@\"%@\", error);\n} completed:^{\n    NSLog(@\"completed\");\n}];\n```\n\n* take:接收到多次信号，但只处理前几次信号\n* takeLast:只处理最后几次信号\n* skip:忽略几次\n* takeUntilBlock:返回YES可以表示不接收，返回NO表示接收该信号，与filter类似\n* takeWhileBlock:当返回一次YES后，就停止接收所有信号\n\n```objectivec\nRACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n\n    [subscriber sendNext:@\"hello1\"];\n    [subscriber sendNext:@\"hello2\"];\n    [subscriber sendNext:@\"hello3\"];\n    [subscriber sendNext:@\"hello4\"];\n    [subscriber sendNext:@\"hello5\"];\n    [subscriber sendCompleted];\n    return nil;\n\n}] takeLast:2];\n\n[signal subscribeNext:^(id value) {\n    NSLog(@\"%@\", value);\n}];\n```\n\n* throttle:节流，可以规定两个信号的间隔时间必须大于某个值\n* distinctUntilChanged:直到订阅的内容发生变化才会处理信号\n* ignore:忽略某些信号值\n\n```objectivec\nUITextField *textField = ({\n    UITextField *view = [[UITextField alloc] init];\n    [self.view addSubview:view];\n    [view mas_makeConstraints:^(MASConstraintMaker *make) {\n        make.center.equalTo(self.view);\n        make.size.mas_equalTo(CGSizeMake(200, 40));\n    }];\n    view.backgroundColor = [UIColor redColor];\n    view;\n});\n\n// 如果文字的改变速度过快，则不处理，两次信号间隔时间必须大于0.3秒\n[[[[[textField rac_textSignal] throttle:0.3] distinctUntilChanged] ignore:@\"\"] subscribeNext:^(id x) {\n    NSLog(@\"%@\", x);\n}];\n```\n\n* flattenMap:订阅的值为一个信号，将该信号转为订阅具体的值\n\n```objectivec\nUITextField *textField = ({\n    UITextField *view = [[UITextField alloc] init];\n    [self.view addSubview:view];\n    [view mas_makeConstraints:^(MASConstraintMaker *make) {\n        make.center.equalTo(self.view);\n        make.size.mas_equalTo(CGSizeMake(200, 40));\n    }];\n    view.backgroundColor = [UIColor redColor];\n    view;\n});\n\n[[[textField.rac_textSignal throttle:0.3] flattenMap:^id(id value) {\n    return [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        [subscriber sendNext:@\"aaa\"];\n        [subscriber sendCompleted];\n        return [RACDisposable disposableWithBlock:^{\n\n        }];\n    }];\n}] subscribeNext:^(id x) {\n    NSLog(@\"%@\", x);\n}];\n```\n\n* repeat:重复发送某个信号\n\n```objectivec\nRACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        [subscriber sendNext:[NSDate date]];\n        [subscriber sendCompleted];\n        return nil;\n    }] repeat];\n\n    [signal subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }];\n```\n\n* merge:同时订阅两个信号源，无论哪个发出信号，都会执行\n\n```objectivec\nRACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n          [subscriber sendNext:@\"1\"];\n          [subscriber sendCompleted];\n      });\n      return nil;\n  }];\n\n  RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n          [subscriber sendNext:@\"2\"];\n          [subscriber sendCompleted];\n      });\n      return nil;\n  }];\n\n  [[signalA merge:signalB] subscribeNext:^(id x) {\n      NSLog(@\"%@\", x);\n  }];\n```\n\n* combineLatest:reduce:这是一个RACSignal的类方法，表示同时聚合多个信号\n\n```objectivec\nRACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n            [subscriber sendNext:@\"1\"];\n            [subscriber sendCompleted];\n        });\n        return nil;\n    }];\n\n    RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n            [subscriber sendNext:@\"2\"];\n            [subscriber sendCompleted];\n        });\n        return nil;\n    }];\n\n    [[RACSignal combineLatest:@[signalA, signalB] reduce:^id(NSString *s1, NSString *s2){\n        NSLog(@\"s1=%@, s2=%@\", s1, s2);\n        return [NSString stringWithFormat:@\"%@%@\", s1, s2];\n    }] subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }];\n```\n\n* concat:先订阅信号A，A执行完成后再订阅信号B\n\n```objectivec\nRACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        [subscriber sendNext:@\"1\"];\n        [subscriber sendCompleted];\n    });\n    return nil;\n}];\n\nRACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        [subscriber sendNext:@\"2\"];\n        [subscriber sendCompleted];\n    });\n    return nil;\n}];\n\n// 先订阅A，A执行完成后，再执行B，如果A失败了，不会再执行B\n[[signalA concat:signalB] subscribeNext:^(id x) {\n    NSLog(@\"%@\", x);\n}];\n```\n\n* zipWith:两个信号都发出后，再执行，也可以使用combineLatest:\n\n```objectivec\nRACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        [subscriber sendNext:@\"1\"];\n        [subscriber sendCompleted];\n    });\n    return nil;\n}];\n\nRACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        [subscriber sendNext:@\"2\"];\n        [subscriber sendCompleted];\n    });\n    return nil;\n}];\n\n[[signalA zipWith:signalB] subscribeNext:^(id x) {\n    // x是一个RACTuple，包含了signalA和signalB的值\n    NSLog(@\"%@\", x);\n}];\n```\n\n\n### RAC的坑\n\n* side effect: 一个信号源被多个订阅者订阅，每个订阅者收到的信号可能不一样。解决方法：使用reply\n\n```objectivec\nRACSignal *signalA = [[RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n    static int i = 0;\n    i++;\n    [subscriber sendNext:@(i)];\n    [subscriber sendCompleted];\n    return nil;\n}] replay];\n\n[signalA subscribeNext:^(id x) {\n    NSLog(@\"%@\", x);\n}];\n\n[signalA subscribeNext:^(id x) {\n    NSLog(@\"%@\", x);\n}];\n```\n","source":"_posts/2015-12-20-RAC学习笔记.md","raw":"---\nlayout: post\ntitle: \"RAC学习笔记\"\ncategories: \"iOS开发\"\n---\n## RAC简介\n\nRAC要解决的问题是传统ios中事件，通知，回调的机制十分的繁琐。\n\n## 常规用法\n\n### target-action\n\n* RAC可以替代一般的target-action操作，例如监测textField的文字的改变，不是用RAC的写法\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    UITextField *text = ({\n        UITextField *text = [[UITextField alloc] init];\n        [self.view addSubview:text];\n        [text mas_makeConstraints:^(MASConstraintMaker *make) {\n            make.center.equalTo(self.view);\n            make.size.mas_equalTo(CGSizeMake(200, 40));\n        }];\n        text.backgroundColor = [UIColor redColor];\n        [text addTarget:self action:@selector(textDidChange:) forControlEvents:UIControlEventEditingChanged];\n        text;\n    });\n}\n\n- (void)textDidChange:(UITextField *)sender {\n    NSLog(@\"did change: %@\", sender);\n}\n```\n\n* 使用RAC的写法：\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    UITextField *text = ({\n        UITextField *text = [[UITextField alloc] init];\n        [self.view addSubview:text];\n        [text mas_makeConstraints:^(MASConstraintMaker *make) {\n            make.center.equalTo(self.view);\n            make.size.mas_equalTo(CGSizeMake(200, 40));\n        }];\n        text.backgroundColor = [UIColor redColor];\n\n        [[text rac_signalForControlEvents:UIControlEventEditingChanged] subscribeNext:^(id x) {\n            NSLog(@\"%@\", x);\n        }];\n\n        // 或者\n        //[text.rac_textSignal subscribeNext:^(id x) {\n        //    NSLog(@\"%@\", x);\n        //}];\n\n        text;\n    });\n}\n```\n\n### 手势中使用RAC\n\n* RAC可以替换手势的方法，代码如下\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    self.view.userInteractionEnabled = YES;\n    UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] init];\n    [[tap rac_gestureSignal] subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }];\n    [self.view addGestureRecognizer:tap];\n}\n```\n\n### 通知\n\n* RAC可以代替通知，并且RAC的通知不用移出\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIApplicationDidBecomeActiveNotification object:nil] subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }];\n}\n```\n\n### 定制器\n\n* RAC可以代替定时器\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // 延迟2秒执行\n    [[RACScheduler mainThreadScheduler] afterDelay:2.0 schedule:^{\n        NSLog(@\"haha\");\n    }];\n\n    // interval为间隔事件，scheduler为在那个线程上执行，leeway为多久之后开始执行。\n    [[RACSignal interval:2.0 onScheduler:[RACScheduler mainThreadScheduler] withLeeway:5.0] subscribeNext:^(NSDate x) {\n        NSLog(@\"%@\", x);\n    }];\n\n}\n```\n\n### 代理\n\n* RAC可以替换代理，但仅限没有返回值的代理\n\n```objectivec\n@interface ViewController ()<UITableViewDelegate>\n@property (nonatomic, strong) UIAlertView *alertView;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    self.alertView = [[UIAlertView alloc] initWithTitle:@\"RAC\" message:@\"test\" delegate:self cancelButtonTitle:@\"OK\" otherButtonTitles: nil];\n    [[self rac_signalForSelector:@selector(alertView:clickedButtonAtIndex:) fromProtocol:@protocol(UIAlertViewDelegate)]subscribeNext:^(id x) {\n        NSLog(@\"%@\",x);\n    }];\n    // 或者\n    // [[self.alertView rac_buttonClickedSignal] subscribeNext:^(id x) {\n    //     NSLog(@\"%@\", x);\n    // }];\n\n    [self.alertView show];\n}\n\n@end\n```\n\n### KVO\n\n* RAC可以替换KVO\n\n```objectivec\n@interface ViewController ()\n\n@property (nonatomic, assign) NSInteger index;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    [RACObserve(self, index) subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }];\n\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {\n    self.index++;\n}\n\n@end\n```\n\n## 高级用法\n\n### 创建信号\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        NSURLRequest *req = [NSURLRequest requestWithURL:[NSURL URLWithString:@\"http://www.baidu.com\"]];\n        [NSURLConnection sendAsynchronousRequest:req queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) {\n            if (connectionError) {\n                // 请求失败\n                [subscriber sendError:connectionError];\n            }\n            else {\n                // 请求成功\n                [subscriber sendNext:data];\n            }\n            [subscriber sendCompleted];\n        }];\n        return [RACDisposable disposableWithBlock:^{\n            // 取消订阅\n            NSLog(@\"cancel\");\n        }];\n    }];\n\n    RACDisposable *disposable = [signal subscribeNext:^(NSData *responseData) {\n        NSLog(@\"%@\", responseData);\n    } error:^(NSError *error) {\n        NSLog(@\"%@\", error);\n    } completed:^{\n        NSLog(@\"completed\");\n    }];\n\n    // 订阅完就取消订阅，这样就不会执行订阅block了\n    [disposable dispose];\n}\n```\n\n### 信号处理\n\n* map:映射\n* filter:过滤\n* delay:延时\n* startWith:在接收到信号前，先接收到一个信号\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    UITextField *textField = ({\n        UITextField *view = [[UITextField alloc] init];\n        [self.view addSubview:view];\n        [view mas_makeConstraints:^(MASConstraintMaker *make) {\n            make.center.equalTo(self.view);\n            make.size.mas_equalTo(CGSizeMake(200, 40));\n        }];\n        view.backgroundColor = [UIColor redColor];\n        view;\n    });\n\n    [[[[[[textField rac_textSignal] map:^id(id value) {\n        NSString *str = (NSString *)value;\n        return @([str length]);\n    }] filter:^BOOL(id value) {\n        return [value integerValue] > 3;\n    }] delay:2] startWith:@\"haha\"] subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }];\n}\n```\n\n* timeout:超时\n\n```objectivec\nRACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n\n    [[RACScheduler mainThreadScheduler] afterDelay:1.0 schedule:^{\n        [subscriber sendNext:@\"hello\"];\n        [subscriber sendCompleted];\n    }];\n    return nil;\n\n}] timeout:2.0 onScheduler:[RACScheduler mainThreadScheduler]]; // 如果请求没有在2秒内完成，则请求超时，会调用errorBlock\n\n[signal subscribeNext:^(NSData *responseData) {\n    NSLog(@\"%@\", responseData);\n} error:^(NSError *error) {\n    NSLog(@\"%@\", error);\n} completed:^{\n    NSLog(@\"completed\");\n}];\n```\n\n* take:接收到多次信号，但只处理前几次信号\n* takeLast:只处理最后几次信号\n* skip:忽略几次\n* takeUntilBlock:返回YES可以表示不接收，返回NO表示接收该信号，与filter类似\n* takeWhileBlock:当返回一次YES后，就停止接收所有信号\n\n```objectivec\nRACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n\n    [subscriber sendNext:@\"hello1\"];\n    [subscriber sendNext:@\"hello2\"];\n    [subscriber sendNext:@\"hello3\"];\n    [subscriber sendNext:@\"hello4\"];\n    [subscriber sendNext:@\"hello5\"];\n    [subscriber sendCompleted];\n    return nil;\n\n}] takeLast:2];\n\n[signal subscribeNext:^(id value) {\n    NSLog(@\"%@\", value);\n}];\n```\n\n* throttle:节流，可以规定两个信号的间隔时间必须大于某个值\n* distinctUntilChanged:直到订阅的内容发生变化才会处理信号\n* ignore:忽略某些信号值\n\n```objectivec\nUITextField *textField = ({\n    UITextField *view = [[UITextField alloc] init];\n    [self.view addSubview:view];\n    [view mas_makeConstraints:^(MASConstraintMaker *make) {\n        make.center.equalTo(self.view);\n        make.size.mas_equalTo(CGSizeMake(200, 40));\n    }];\n    view.backgroundColor = [UIColor redColor];\n    view;\n});\n\n// 如果文字的改变速度过快，则不处理，两次信号间隔时间必须大于0.3秒\n[[[[[textField rac_textSignal] throttle:0.3] distinctUntilChanged] ignore:@\"\"] subscribeNext:^(id x) {\n    NSLog(@\"%@\", x);\n}];\n```\n\n* flattenMap:订阅的值为一个信号，将该信号转为订阅具体的值\n\n```objectivec\nUITextField *textField = ({\n    UITextField *view = [[UITextField alloc] init];\n    [self.view addSubview:view];\n    [view mas_makeConstraints:^(MASConstraintMaker *make) {\n        make.center.equalTo(self.view);\n        make.size.mas_equalTo(CGSizeMake(200, 40));\n    }];\n    view.backgroundColor = [UIColor redColor];\n    view;\n});\n\n[[[textField.rac_textSignal throttle:0.3] flattenMap:^id(id value) {\n    return [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        [subscriber sendNext:@\"aaa\"];\n        [subscriber sendCompleted];\n        return [RACDisposable disposableWithBlock:^{\n\n        }];\n    }];\n}] subscribeNext:^(id x) {\n    NSLog(@\"%@\", x);\n}];\n```\n\n* repeat:重复发送某个信号\n\n```objectivec\nRACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        [subscriber sendNext:[NSDate date]];\n        [subscriber sendCompleted];\n        return nil;\n    }] repeat];\n\n    [signal subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }];\n```\n\n* merge:同时订阅两个信号源，无论哪个发出信号，都会执行\n\n```objectivec\nRACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n          [subscriber sendNext:@\"1\"];\n          [subscriber sendCompleted];\n      });\n      return nil;\n  }];\n\n  RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n          [subscriber sendNext:@\"2\"];\n          [subscriber sendCompleted];\n      });\n      return nil;\n  }];\n\n  [[signalA merge:signalB] subscribeNext:^(id x) {\n      NSLog(@\"%@\", x);\n  }];\n```\n\n* combineLatest:reduce:这是一个RACSignal的类方法，表示同时聚合多个信号\n\n```objectivec\nRACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n            [subscriber sendNext:@\"1\"];\n            [subscriber sendCompleted];\n        });\n        return nil;\n    }];\n\n    RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n            [subscriber sendNext:@\"2\"];\n            [subscriber sendCompleted];\n        });\n        return nil;\n    }];\n\n    [[RACSignal combineLatest:@[signalA, signalB] reduce:^id(NSString *s1, NSString *s2){\n        NSLog(@\"s1=%@, s2=%@\", s1, s2);\n        return [NSString stringWithFormat:@\"%@%@\", s1, s2];\n    }] subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }];\n```\n\n* concat:先订阅信号A，A执行完成后再订阅信号B\n\n```objectivec\nRACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        [subscriber sendNext:@\"1\"];\n        [subscriber sendCompleted];\n    });\n    return nil;\n}];\n\nRACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        [subscriber sendNext:@\"2\"];\n        [subscriber sendCompleted];\n    });\n    return nil;\n}];\n\n// 先订阅A，A执行完成后，再执行B，如果A失败了，不会再执行B\n[[signalA concat:signalB] subscribeNext:^(id x) {\n    NSLog(@\"%@\", x);\n}];\n```\n\n* zipWith:两个信号都发出后，再执行，也可以使用combineLatest:\n\n```objectivec\nRACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        [subscriber sendNext:@\"1\"];\n        [subscriber sendCompleted];\n    });\n    return nil;\n}];\n\nRACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        [subscriber sendNext:@\"2\"];\n        [subscriber sendCompleted];\n    });\n    return nil;\n}];\n\n[[signalA zipWith:signalB] subscribeNext:^(id x) {\n    // x是一个RACTuple，包含了signalA和signalB的值\n    NSLog(@\"%@\", x);\n}];\n```\n\n\n### RAC的坑\n\n* side effect: 一个信号源被多个订阅者订阅，每个订阅者收到的信号可能不一样。解决方法：使用reply\n\n```objectivec\nRACSignal *signalA = [[RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n    static int i = 0;\n    i++;\n    [subscriber sendNext:@(i)];\n    [subscriber sendCompleted];\n    return nil;\n}] replay];\n\n[signalA subscribeNext:^(id x) {\n    NSLog(@\"%@\", x);\n}];\n\n[signalA subscribeNext:^(id x) {\n    NSLog(@\"%@\", x);\n}];\n```\n","slug":"RAC学习笔记","published":1,"date":"2015-12-19T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oab20016zrm0r7jylpgh","content":"<h2 id=\"RAC简介\"><a href=\"#RAC简介\" class=\"headerlink\" title=\"RAC简介\"></a>RAC简介</h2><p>RAC要解决的问题是传统ios中事件，通知，回调的机制十分的繁琐。</p>\n<h2 id=\"常规用法\"><a href=\"#常规用法\" class=\"headerlink\" title=\"常规用法\"></a>常规用法</h2><h3 id=\"target-action\"><a href=\"#target-action\" class=\"headerlink\" title=\"target-action\"></a>target-action</h3><ul>\n<li>RAC可以替代一般的target-action操作，例如监测textField的文字的改变，不是用RAC的写法</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">UITextField</span> *text = (&#123;</div><div class=\"line\">        <span class=\"built_in\">UITextField</span> *text = [[<span class=\"built_in\">UITextField</span> alloc] init];</div><div class=\"line\">        [<span class=\"keyword\">self</span>.view addSubview:text];</div><div class=\"line\">        [text mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">            make.center.equalTo(<span class=\"keyword\">self</span>.view);</div><div class=\"line\">            make.size.mas_equalTo(<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">200</span>, <span class=\"number\">40</span>));</div><div class=\"line\">        &#125;];</div><div class=\"line\">        text.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor];</div><div class=\"line\">        [text addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(textDidChange:) forControlEvents:<span class=\"built_in\">UIControlEventEditingChanged</span>];</div><div class=\"line\">        text;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)textDidChange:(<span class=\"built_in\">UITextField</span> *)sender &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"did change: %@\"</span>, sender);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>使用RAC的写法：<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">UITextField</span> *text = (&#123;</div><div class=\"line\">        <span class=\"built_in\">UITextField</span> *text = [[<span class=\"built_in\">UITextField</span> alloc] init];</div><div class=\"line\">        [<span class=\"keyword\">self</span>.view addSubview:text];</div><div class=\"line\">        [text mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">            make.center.equalTo(<span class=\"keyword\">self</span>.view);</div><div class=\"line\">            make.size.mas_equalTo(<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">200</span>, <span class=\"number\">40</span>));</div><div class=\"line\">        &#125;];</div><div class=\"line\">        text.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor];</div><div class=\"line\"></div><div class=\"line\">        [[text rac_signalForControlEvents:<span class=\"built_in\">UIControlEventEditingChanged</span>] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">        &#125;];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 或者</span></div><div class=\"line\">        <span class=\"comment\">//[text.rac_textSignal subscribeNext:^(id x) &#123;</span></div><div class=\"line\">        <span class=\"comment\">//    NSLog(@\"%@\", x);</span></div><div class=\"line\">        <span class=\"comment\">//&#125;];</span></div><div class=\"line\"></div><div class=\"line\">        text;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"手势中使用RAC\"><a href=\"#手势中使用RAC\" class=\"headerlink\" title=\"手势中使用RAC\"></a>手势中使用RAC</h3><ul>\n<li>RAC可以替换手势的方法，代码如下</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.view.userInteractionEnabled = <span class=\"literal\">YES</span>;</div><div class=\"line\">    <span class=\"built_in\">UITapGestureRecognizer</span> *tap = [[<span class=\"built_in\">UITapGestureRecognizer</span> alloc] init];</div><div class=\"line\">    [[tap rac_gestureSignal] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.view addGestureRecognizer:tap];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"通知\"><a href=\"#通知\" class=\"headerlink\" title=\"通知\"></a>通知</h3><ul>\n<li>RAC可以代替通知，并且RAC的通知不用移出</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    [[[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] rac_addObserverForName:<span class=\"built_in\">UIApplicationDidBecomeActiveNotification</span> object:<span class=\"literal\">nil</span>] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"定制器\"><a href=\"#定制器\" class=\"headerlink\" title=\"定制器\"></a>定制器</h3><ul>\n<li>RAC可以代替定时器</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 延迟2秒执行</span></div><div class=\"line\">    [[RACScheduler mainThreadScheduler] afterDelay:<span class=\"number\">2.0</span> schedule:^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"haha\"</span>);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// interval为间隔事件，scheduler为在那个线程上执行，leeway为多久之后开始执行。</span></div><div class=\"line\">    [[RACSignal interval:<span class=\"number\">2.0</span> onScheduler:[RACScheduler mainThreadScheduler] withLeeway:<span class=\"number\">5.0</span>] subscribeNext:^(<span class=\"built_in\">NSDate</span> x) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h3><ul>\n<li>RAC可以替换代理，但仅限没有返回值的代理</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()&lt;<span class=\"title\">UITableViewDelegate</span>&gt;</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UIAlertView</span> *alertView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.alertView = [[<span class=\"built_in\">UIAlertView</span> alloc] initWithTitle:<span class=\"string\">@\"RAC\"</span> message:<span class=\"string\">@\"test\"</span> delegate:<span class=\"keyword\">self</span> cancelButtonTitle:<span class=\"string\">@\"OK\"</span> otherButtonTitles: <span class=\"literal\">nil</span>];</div><div class=\"line\">    [[<span class=\"keyword\">self</span> rac_signalForSelector:<span class=\"keyword\">@selector</span>(alertView:clickedButtonAtIndex:) fromProtocol:<span class=\"class\"><span class=\"keyword\">@protocol</span>(<span class=\"title\">UIAlertViewDelegate</span>)]<span class=\"title\">subscribeNext</span>:^(<span class=\"title\">id</span> <span class=\"title\">x</span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,x);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    <span class=\"comment\">// 或者</span></div><div class=\"line\">    <span class=\"comment\">// [[self.alertView rac_buttonClickedSignal] subscribeNext:^(id x) &#123;</span></div><div class=\"line\">    <span class=\"comment\">//     NSLog(@\"%@\", x);</span></div><div class=\"line\">    <span class=\"comment\">// &#125;];</span></div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">self</span>.alertView show];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h3 id=\"KVO\"><a href=\"#KVO\" class=\"headerlink\" title=\"KVO\"></a>KVO</h3><ul>\n<li>RAC可以替换KVO</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSInteger</span> index;</div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    [RACObserve(<span class=\"keyword\">self</span>, index) subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">UITouch</span> *&gt; *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event &#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.index++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h2 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h2><h3 id=\"创建信号\"><a href=\"#创建信号\" class=\"headerlink\" title=\"创建信号\"></a>创建信号</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSURLRequest</span> *req = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:[<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://www.baidu.com\"</span>]];</div><div class=\"line\">        [<span class=\"built_in\">NSURLConnection</span> sendAsynchronousRequest:req queue:[<span class=\"built_in\">NSOperationQueue</span> mainQueue] completionHandler:^(<span class=\"built_in\">NSURLResponse</span> * _Nullable response, <span class=\"built_in\">NSData</span> * _Nullable data, <span class=\"built_in\">NSError</span> * _Nullable connectionError) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (connectionError) &#123;</div><div class=\"line\">                <span class=\"comment\">// 请求失败</span></div><div class=\"line\">                [subscriber sendError:connectionError];</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"comment\">// 请求成功</span></div><div class=\"line\">                [subscriber sendNext:data];</div><div class=\"line\">            &#125;</div><div class=\"line\">            [subscriber sendCompleted];</div><div class=\"line\">        &#125;];</div><div class=\"line\">        <span class=\"keyword\">return</span> [RACDisposable disposableWithBlock:^&#123;</div><div class=\"line\">            <span class=\"comment\">// 取消订阅</span></div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"cancel\"</span>);</div><div class=\"line\">        &#125;];</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    RACDisposable *disposable = [signal subscribeNext:^(<span class=\"built_in\">NSData</span> *responseData) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, responseData);</div><div class=\"line\">    &#125; error:^(<span class=\"built_in\">NSError</span> *error) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, error);</div><div class=\"line\">    &#125; completed:^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"completed\"</span>);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 订阅完就取消订阅，这样就不会执行订阅block了</span></div><div class=\"line\">    [disposable dispose];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"信号处理\"><a href=\"#信号处理\" class=\"headerlink\" title=\"信号处理\"></a>信号处理</h3><ul>\n<li>map:映射</li>\n<li>filter:过滤</li>\n<li>delay:延时</li>\n<li>startWith:在接收到信号前，先接收到一个信号</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">UITextField</span> *textField = (&#123;</div><div class=\"line\">        <span class=\"built_in\">UITextField</span> *view = [[<span class=\"built_in\">UITextField</span> alloc] init];</div><div class=\"line\">        [<span class=\"keyword\">self</span>.view addSubview:view];</div><div class=\"line\">        [view mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">            make.center.equalTo(<span class=\"keyword\">self</span>.view);</div><div class=\"line\">            make.size.mas_equalTo(<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">200</span>, <span class=\"number\">40</span>));</div><div class=\"line\">        &#125;];</div><div class=\"line\">        view.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor];</div><div class=\"line\">        view;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    [[[[[[textField rac_textSignal] map:^<span class=\"keyword\">id</span>(<span class=\"keyword\">id</span> value) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *str = (<span class=\"built_in\">NSString</span> *)value;</div><div class=\"line\">        <span class=\"keyword\">return</span> @([str length]);</div><div class=\"line\">    &#125;] filter:^<span class=\"built_in\">BOOL</span>(<span class=\"keyword\">id</span> value) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> [value integerValue] &gt; <span class=\"number\">3</span>;</div><div class=\"line\">    &#125;] delay:<span class=\"number\">2</span>] startWith:<span class=\"string\">@\"haha\"</span>] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>timeout:超时</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\"></div><div class=\"line\">    [[RACScheduler mainThreadScheduler] afterDelay:<span class=\"number\">1.0</span> schedule:^&#123;</div><div class=\"line\">        [subscriber sendNext:<span class=\"string\">@\"hello\"</span>];</div><div class=\"line\">        [subscriber sendCompleted];</div><div class=\"line\">    &#125;];</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\"></div><div class=\"line\">&#125;] timeout:<span class=\"number\">2.0</span> onScheduler:[RACScheduler mainThreadScheduler]]; <span class=\"comment\">// 如果请求没有在2秒内完成，则请求超时，会调用errorBlock</span></div><div class=\"line\"></div><div class=\"line\">[signal subscribeNext:^(<span class=\"built_in\">NSData</span> *responseData) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, responseData);</div><div class=\"line\">&#125; error:^(<span class=\"built_in\">NSError</span> *error) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, error);</div><div class=\"line\">&#125; completed:^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"completed\"</span>);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<ul>\n<li>take:接收到多次信号，但只处理前几次信号</li>\n<li>takeLast:只处理最后几次信号</li>\n<li>skip:忽略几次</li>\n<li>takeUntilBlock:返回YES可以表示不接收，返回NO表示接收该信号，与filter类似</li>\n<li>takeWhileBlock:当返回一次YES后，就停止接收所有信号</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\"></div><div class=\"line\">    [subscriber sendNext:<span class=\"string\">@\"hello1\"</span>];</div><div class=\"line\">    [subscriber sendNext:<span class=\"string\">@\"hello2\"</span>];</div><div class=\"line\">    [subscriber sendNext:<span class=\"string\">@\"hello3\"</span>];</div><div class=\"line\">    [subscriber sendNext:<span class=\"string\">@\"hello4\"</span>];</div><div class=\"line\">    [subscriber sendNext:<span class=\"string\">@\"hello5\"</span>];</div><div class=\"line\">    [subscriber sendCompleted];</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\"></div><div class=\"line\">&#125;] takeLast:<span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\">[signal subscribeNext:^(<span class=\"keyword\">id</span> value) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, value);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<ul>\n<li>throttle:节流，可以规定两个信号的间隔时间必须大于某个值</li>\n<li>distinctUntilChanged:直到订阅的内容发生变化才会处理信号</li>\n<li>ignore:忽略某些信号值</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UITextField</span> *textField = (&#123;</div><div class=\"line\">    <span class=\"built_in\">UITextField</span> *view = [[<span class=\"built_in\">UITextField</span> alloc] init];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:view];</div><div class=\"line\">    [view mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">        make.center.equalTo(<span class=\"keyword\">self</span>.view);</div><div class=\"line\">        make.size.mas_equalTo(<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">200</span>, <span class=\"number\">40</span>));</div><div class=\"line\">    &#125;];</div><div class=\"line\">    view.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor];</div><div class=\"line\">    view;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 如果文字的改变速度过快，则不处理，两次信号间隔时间必须大于0.3秒</span></div><div class=\"line\">[[[[[textField rac_textSignal] throttle:<span class=\"number\">0.3</span>] distinctUntilChanged] ignore:<span class=\"string\">@\"\"</span>] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<ul>\n<li>flattenMap:订阅的值为一个信号，将该信号转为订阅具体的值</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UITextField</span> *textField = (&#123;</div><div class=\"line\">    <span class=\"built_in\">UITextField</span> *view = [[<span class=\"built_in\">UITextField</span> alloc] init];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:view];</div><div class=\"line\">    [view mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">        make.center.equalTo(<span class=\"keyword\">self</span>.view);</div><div class=\"line\">        make.size.mas_equalTo(<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">200</span>, <span class=\"number\">40</span>));</div><div class=\"line\">    &#125;];</div><div class=\"line\">    view.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor];</div><div class=\"line\">    view;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">[[[textField.rac_textSignal throttle:<span class=\"number\">0.3</span>] flattenMap:^<span class=\"keyword\">id</span>(<span class=\"keyword\">id</span> value) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> [RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">        [subscriber sendNext:<span class=\"string\">@\"aaa\"</span>];</div><div class=\"line\">        [subscriber sendCompleted];</div><div class=\"line\">        <span class=\"keyword\">return</span> [RACDisposable disposableWithBlock:^&#123;</div><div class=\"line\"></div><div class=\"line\">        &#125;];</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<ul>\n<li>repeat:重复发送某个信号</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">        [subscriber sendNext:[<span class=\"built_in\">NSDate</span> date]];</div><div class=\"line\">        [subscriber sendCompleted];</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">    &#125;] repeat];</div><div class=\"line\"></div><div class=\"line\">    [signal subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n<ul>\n<li>merge:同时订阅两个信号源，无论哪个发出信号，都会执行</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">          [subscriber sendNext:<span class=\"string\">@\"1\"</span>];</div><div class=\"line\">          [subscriber sendCompleted];</div><div class=\"line\">      &#125;);</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">  &#125;];</div><div class=\"line\"></div><div class=\"line\">  RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">3.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">          [subscriber sendNext:<span class=\"string\">@\"2\"</span>];</div><div class=\"line\">          [subscriber sendCompleted];</div><div class=\"line\">      &#125;);</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">  &#125;];</div><div class=\"line\"></div><div class=\"line\">  [[signalA merge:signalB] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">      <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">  &#125;];</div></pre></td></tr></table></figure>\n<ul>\n<li>combineLatest:reduce:这是一个RACSignal的类方法，表示同时聚合多个信号</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            [subscriber sendNext:<span class=\"string\">@\"1\"</span>];</div><div class=\"line\">            [subscriber sendCompleted];</div><div class=\"line\">        &#125;);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">3.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            [subscriber sendNext:<span class=\"string\">@\"2\"</span>];</div><div class=\"line\">            [subscriber sendCompleted];</div><div class=\"line\">        &#125;);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    [[RACSignal combineLatest:@[signalA, signalB] reduce:^<span class=\"keyword\">id</span>(<span class=\"built_in\">NSString</span> *s1, <span class=\"built_in\">NSString</span> *s2)&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"s1=%@, s2=%@\"</span>, s1, s2);</div><div class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@%@\"</span>, s1, s2];</div><div class=\"line\">    &#125;] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n<ul>\n<li>concat:先订阅信号A，A执行完成后再订阅信号B</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        [subscriber sendNext:<span class=\"string\">@\"1\"</span>];</div><div class=\"line\">        [subscriber sendCompleted];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        [subscriber sendNext:<span class=\"string\">@\"2\"</span>];</div><div class=\"line\">        [subscriber sendCompleted];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 先订阅A，A执行完成后，再执行B，如果A失败了，不会再执行B</span></div><div class=\"line\">[[signalA concat:signalB] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<ul>\n<li>zipWith:两个信号都发出后，再执行，也可以使用combineLatest:</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        [subscriber sendNext:<span class=\"string\">@\"1\"</span>];</div><div class=\"line\">        [subscriber sendCompleted];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">3.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        [subscriber sendNext:<span class=\"string\">@\"2\"</span>];</div><div class=\"line\">        [subscriber sendCompleted];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">[[signalA zipWith:signalB] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">    <span class=\"comment\">// x是一个RACTuple，包含了signalA和signalB的值</span></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<h3 id=\"RAC的坑\"><a href=\"#RAC的坑\" class=\"headerlink\" title=\"RAC的坑\"></a>RAC的坑</h3><ul>\n<li>side effect: 一个信号源被多个订阅者订阅，每个订阅者收到的信号可能不一样。解决方法：使用reply</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">RACSignal *signalA = [[RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">    i++;</div><div class=\"line\">    [subscriber sendNext:@(i)];</div><div class=\"line\">    [subscriber sendCompleted];</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">&#125;] replay];</div><div class=\"line\"></div><div class=\"line\">[signalA subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">[signalA subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"RAC简介\"><a href=\"#RAC简介\" class=\"headerlink\" title=\"RAC简介\"></a>RAC简介</h2><p>RAC要解决的问题是传统ios中事件，通知，回调的机制十分的繁琐。</p>\n<h2 id=\"常规用法\"><a href=\"#常规用法\" class=\"headerlink\" title=\"常规用法\"></a>常规用法</h2><h3 id=\"target-action\"><a href=\"#target-action\" class=\"headerlink\" title=\"target-action\"></a>target-action</h3><ul>\n<li>RAC可以替代一般的target-action操作，例如监测textField的文字的改变，不是用RAC的写法</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">UITextField</span> *text = (&#123;</div><div class=\"line\">        <span class=\"built_in\">UITextField</span> *text = [[<span class=\"built_in\">UITextField</span> alloc] init];</div><div class=\"line\">        [<span class=\"keyword\">self</span>.view addSubview:text];</div><div class=\"line\">        [text mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">            make.center.equalTo(<span class=\"keyword\">self</span>.view);</div><div class=\"line\">            make.size.mas_equalTo(<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">200</span>, <span class=\"number\">40</span>));</div><div class=\"line\">        &#125;];</div><div class=\"line\">        text.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor];</div><div class=\"line\">        [text addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(textDidChange:) forControlEvents:<span class=\"built_in\">UIControlEventEditingChanged</span>];</div><div class=\"line\">        text;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)textDidChange:(<span class=\"built_in\">UITextField</span> *)sender &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"did change: %@\"</span>, sender);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>使用RAC的写法：<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">UITextField</span> *text = (&#123;</div><div class=\"line\">        <span class=\"built_in\">UITextField</span> *text = [[<span class=\"built_in\">UITextField</span> alloc] init];</div><div class=\"line\">        [<span class=\"keyword\">self</span>.view addSubview:text];</div><div class=\"line\">        [text mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">            make.center.equalTo(<span class=\"keyword\">self</span>.view);</div><div class=\"line\">            make.size.mas_equalTo(<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">200</span>, <span class=\"number\">40</span>));</div><div class=\"line\">        &#125;];</div><div class=\"line\">        text.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor];</div><div class=\"line\"></div><div class=\"line\">        [[text rac_signalForControlEvents:<span class=\"built_in\">UIControlEventEditingChanged</span>] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">        &#125;];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 或者</span></div><div class=\"line\">        <span class=\"comment\">//[text.rac_textSignal subscribeNext:^(id x) &#123;</span></div><div class=\"line\">        <span class=\"comment\">//    NSLog(@\"%@\", x);</span></div><div class=\"line\">        <span class=\"comment\">//&#125;];</span></div><div class=\"line\"></div><div class=\"line\">        text;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"手势中使用RAC\"><a href=\"#手势中使用RAC\" class=\"headerlink\" title=\"手势中使用RAC\"></a>手势中使用RAC</h3><ul>\n<li>RAC可以替换手势的方法，代码如下</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.view.userInteractionEnabled = <span class=\"literal\">YES</span>;</div><div class=\"line\">    <span class=\"built_in\">UITapGestureRecognizer</span> *tap = [[<span class=\"built_in\">UITapGestureRecognizer</span> alloc] init];</div><div class=\"line\">    [[tap rac_gestureSignal] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.view addGestureRecognizer:tap];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"通知\"><a href=\"#通知\" class=\"headerlink\" title=\"通知\"></a>通知</h3><ul>\n<li>RAC可以代替通知，并且RAC的通知不用移出</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    [[[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] rac_addObserverForName:<span class=\"built_in\">UIApplicationDidBecomeActiveNotification</span> object:<span class=\"literal\">nil</span>] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"定制器\"><a href=\"#定制器\" class=\"headerlink\" title=\"定制器\"></a>定制器</h3><ul>\n<li>RAC可以代替定时器</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 延迟2秒执行</span></div><div class=\"line\">    [[RACScheduler mainThreadScheduler] afterDelay:<span class=\"number\">2.0</span> schedule:^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"haha\"</span>);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// interval为间隔事件，scheduler为在那个线程上执行，leeway为多久之后开始执行。</span></div><div class=\"line\">    [[RACSignal interval:<span class=\"number\">2.0</span> onScheduler:[RACScheduler mainThreadScheduler] withLeeway:<span class=\"number\">5.0</span>] subscribeNext:^(<span class=\"built_in\">NSDate</span> x) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h3><ul>\n<li>RAC可以替换代理，但仅限没有返回值的代理</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()&lt;<span class=\"title\">UITableViewDelegate</span>&gt;</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UIAlertView</span> *alertView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.alertView = [[<span class=\"built_in\">UIAlertView</span> alloc] initWithTitle:<span class=\"string\">@\"RAC\"</span> message:<span class=\"string\">@\"test\"</span> delegate:<span class=\"keyword\">self</span> cancelButtonTitle:<span class=\"string\">@\"OK\"</span> otherButtonTitles: <span class=\"literal\">nil</span>];</div><div class=\"line\">    [[<span class=\"keyword\">self</span> rac_signalForSelector:<span class=\"keyword\">@selector</span>(alertView:clickedButtonAtIndex:) fromProtocol:<span class=\"class\"><span class=\"keyword\">@protocol</span>(<span class=\"title\">UIAlertViewDelegate</span>)]<span class=\"title\">subscribeNext</span>:^(<span class=\"title\">id</span> <span class=\"title\">x</span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,x);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    <span class=\"comment\">// 或者</span></div><div class=\"line\">    <span class=\"comment\">// [[self.alertView rac_buttonClickedSignal] subscribeNext:^(id x) &#123;</span></div><div class=\"line\">    <span class=\"comment\">//     NSLog(@\"%@\", x);</span></div><div class=\"line\">    <span class=\"comment\">// &#125;];</span></div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">self</span>.alertView show];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h3 id=\"KVO\"><a href=\"#KVO\" class=\"headerlink\" title=\"KVO\"></a>KVO</h3><ul>\n<li>RAC可以替换KVO</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSInteger</span> index;</div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    [RACObserve(<span class=\"keyword\">self</span>, index) subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">UITouch</span> *&gt; *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event &#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.index++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h2 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h2><h3 id=\"创建信号\"><a href=\"#创建信号\" class=\"headerlink\" title=\"创建信号\"></a>创建信号</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSURLRequest</span> *req = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:[<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://www.baidu.com\"</span>]];</div><div class=\"line\">        [<span class=\"built_in\">NSURLConnection</span> sendAsynchronousRequest:req queue:[<span class=\"built_in\">NSOperationQueue</span> mainQueue] completionHandler:^(<span class=\"built_in\">NSURLResponse</span> * _Nullable response, <span class=\"built_in\">NSData</span> * _Nullable data, <span class=\"built_in\">NSError</span> * _Nullable connectionError) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (connectionError) &#123;</div><div class=\"line\">                <span class=\"comment\">// 请求失败</span></div><div class=\"line\">                [subscriber sendError:connectionError];</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"comment\">// 请求成功</span></div><div class=\"line\">                [subscriber sendNext:data];</div><div class=\"line\">            &#125;</div><div class=\"line\">            [subscriber sendCompleted];</div><div class=\"line\">        &#125;];</div><div class=\"line\">        <span class=\"keyword\">return</span> [RACDisposable disposableWithBlock:^&#123;</div><div class=\"line\">            <span class=\"comment\">// 取消订阅</span></div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"cancel\"</span>);</div><div class=\"line\">        &#125;];</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    RACDisposable *disposable = [signal subscribeNext:^(<span class=\"built_in\">NSData</span> *responseData) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, responseData);</div><div class=\"line\">    &#125; error:^(<span class=\"built_in\">NSError</span> *error) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, error);</div><div class=\"line\">    &#125; completed:^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"completed\"</span>);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 订阅完就取消订阅，这样就不会执行订阅block了</span></div><div class=\"line\">    [disposable dispose];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"信号处理\"><a href=\"#信号处理\" class=\"headerlink\" title=\"信号处理\"></a>信号处理</h3><ul>\n<li>map:映射</li>\n<li>filter:过滤</li>\n<li>delay:延时</li>\n<li>startWith:在接收到信号前，先接收到一个信号</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">UITextField</span> *textField = (&#123;</div><div class=\"line\">        <span class=\"built_in\">UITextField</span> *view = [[<span class=\"built_in\">UITextField</span> alloc] init];</div><div class=\"line\">        [<span class=\"keyword\">self</span>.view addSubview:view];</div><div class=\"line\">        [view mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">            make.center.equalTo(<span class=\"keyword\">self</span>.view);</div><div class=\"line\">            make.size.mas_equalTo(<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">200</span>, <span class=\"number\">40</span>));</div><div class=\"line\">        &#125;];</div><div class=\"line\">        view.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor];</div><div class=\"line\">        view;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    [[[[[[textField rac_textSignal] map:^<span class=\"keyword\">id</span>(<span class=\"keyword\">id</span> value) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *str = (<span class=\"built_in\">NSString</span> *)value;</div><div class=\"line\">        <span class=\"keyword\">return</span> @([str length]);</div><div class=\"line\">    &#125;] filter:^<span class=\"built_in\">BOOL</span>(<span class=\"keyword\">id</span> value) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> [value integerValue] &gt; <span class=\"number\">3</span>;</div><div class=\"line\">    &#125;] delay:<span class=\"number\">2</span>] startWith:<span class=\"string\">@\"haha\"</span>] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>timeout:超时</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\"></div><div class=\"line\">    [[RACScheduler mainThreadScheduler] afterDelay:<span class=\"number\">1.0</span> schedule:^&#123;</div><div class=\"line\">        [subscriber sendNext:<span class=\"string\">@\"hello\"</span>];</div><div class=\"line\">        [subscriber sendCompleted];</div><div class=\"line\">    &#125;];</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\"></div><div class=\"line\">&#125;] timeout:<span class=\"number\">2.0</span> onScheduler:[RACScheduler mainThreadScheduler]]; <span class=\"comment\">// 如果请求没有在2秒内完成，则请求超时，会调用errorBlock</span></div><div class=\"line\"></div><div class=\"line\">[signal subscribeNext:^(<span class=\"built_in\">NSData</span> *responseData) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, responseData);</div><div class=\"line\">&#125; error:^(<span class=\"built_in\">NSError</span> *error) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, error);</div><div class=\"line\">&#125; completed:^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"completed\"</span>);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<ul>\n<li>take:接收到多次信号，但只处理前几次信号</li>\n<li>takeLast:只处理最后几次信号</li>\n<li>skip:忽略几次</li>\n<li>takeUntilBlock:返回YES可以表示不接收，返回NO表示接收该信号，与filter类似</li>\n<li>takeWhileBlock:当返回一次YES后，就停止接收所有信号</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\"></div><div class=\"line\">    [subscriber sendNext:<span class=\"string\">@\"hello1\"</span>];</div><div class=\"line\">    [subscriber sendNext:<span class=\"string\">@\"hello2\"</span>];</div><div class=\"line\">    [subscriber sendNext:<span class=\"string\">@\"hello3\"</span>];</div><div class=\"line\">    [subscriber sendNext:<span class=\"string\">@\"hello4\"</span>];</div><div class=\"line\">    [subscriber sendNext:<span class=\"string\">@\"hello5\"</span>];</div><div class=\"line\">    [subscriber sendCompleted];</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\"></div><div class=\"line\">&#125;] takeLast:<span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\">[signal subscribeNext:^(<span class=\"keyword\">id</span> value) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, value);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<ul>\n<li>throttle:节流，可以规定两个信号的间隔时间必须大于某个值</li>\n<li>distinctUntilChanged:直到订阅的内容发生变化才会处理信号</li>\n<li>ignore:忽略某些信号值</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UITextField</span> *textField = (&#123;</div><div class=\"line\">    <span class=\"built_in\">UITextField</span> *view = [[<span class=\"built_in\">UITextField</span> alloc] init];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:view];</div><div class=\"line\">    [view mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">        make.center.equalTo(<span class=\"keyword\">self</span>.view);</div><div class=\"line\">        make.size.mas_equalTo(<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">200</span>, <span class=\"number\">40</span>));</div><div class=\"line\">    &#125;];</div><div class=\"line\">    view.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor];</div><div class=\"line\">    view;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 如果文字的改变速度过快，则不处理，两次信号间隔时间必须大于0.3秒</span></div><div class=\"line\">[[[[[textField rac_textSignal] throttle:<span class=\"number\">0.3</span>] distinctUntilChanged] ignore:<span class=\"string\">@\"\"</span>] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<ul>\n<li>flattenMap:订阅的值为一个信号，将该信号转为订阅具体的值</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UITextField</span> *textField = (&#123;</div><div class=\"line\">    <span class=\"built_in\">UITextField</span> *view = [[<span class=\"built_in\">UITextField</span> alloc] init];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:view];</div><div class=\"line\">    [view mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">        make.center.equalTo(<span class=\"keyword\">self</span>.view);</div><div class=\"line\">        make.size.mas_equalTo(<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">200</span>, <span class=\"number\">40</span>));</div><div class=\"line\">    &#125;];</div><div class=\"line\">    view.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor];</div><div class=\"line\">    view;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">[[[textField.rac_textSignal throttle:<span class=\"number\">0.3</span>] flattenMap:^<span class=\"keyword\">id</span>(<span class=\"keyword\">id</span> value) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> [RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">        [subscriber sendNext:<span class=\"string\">@\"aaa\"</span>];</div><div class=\"line\">        [subscriber sendCompleted];</div><div class=\"line\">        <span class=\"keyword\">return</span> [RACDisposable disposableWithBlock:^&#123;</div><div class=\"line\"></div><div class=\"line\">        &#125;];</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<ul>\n<li>repeat:重复发送某个信号</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">        [subscriber sendNext:[<span class=\"built_in\">NSDate</span> date]];</div><div class=\"line\">        [subscriber sendCompleted];</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">    &#125;] repeat];</div><div class=\"line\"></div><div class=\"line\">    [signal subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n<ul>\n<li>merge:同时订阅两个信号源，无论哪个发出信号，都会执行</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">          [subscriber sendNext:<span class=\"string\">@\"1\"</span>];</div><div class=\"line\">          [subscriber sendCompleted];</div><div class=\"line\">      &#125;);</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">  &#125;];</div><div class=\"line\"></div><div class=\"line\">  RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">3.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">          [subscriber sendNext:<span class=\"string\">@\"2\"</span>];</div><div class=\"line\">          [subscriber sendCompleted];</div><div class=\"line\">      &#125;);</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">  &#125;];</div><div class=\"line\"></div><div class=\"line\">  [[signalA merge:signalB] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">      <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">  &#125;];</div></pre></td></tr></table></figure>\n<ul>\n<li>combineLatest:reduce:这是一个RACSignal的类方法，表示同时聚合多个信号</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            [subscriber sendNext:<span class=\"string\">@\"1\"</span>];</div><div class=\"line\">            [subscriber sendCompleted];</div><div class=\"line\">        &#125;);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">3.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            [subscriber sendNext:<span class=\"string\">@\"2\"</span>];</div><div class=\"line\">            [subscriber sendCompleted];</div><div class=\"line\">        &#125;);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    [[RACSignal combineLatest:@[signalA, signalB] reduce:^<span class=\"keyword\">id</span>(<span class=\"built_in\">NSString</span> *s1, <span class=\"built_in\">NSString</span> *s2)&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"s1=%@, s2=%@\"</span>, s1, s2);</div><div class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@%@\"</span>, s1, s2];</div><div class=\"line\">    &#125;] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n<ul>\n<li>concat:先订阅信号A，A执行完成后再订阅信号B</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        [subscriber sendNext:<span class=\"string\">@\"1\"</span>];</div><div class=\"line\">        [subscriber sendCompleted];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        [subscriber sendNext:<span class=\"string\">@\"2\"</span>];</div><div class=\"line\">        [subscriber sendCompleted];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 先订阅A，A执行完成后，再执行B，如果A失败了，不会再执行B</span></div><div class=\"line\">[[signalA concat:signalB] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<ul>\n<li>zipWith:两个信号都发出后，再执行，也可以使用combineLatest:</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        [subscriber sendNext:<span class=\"string\">@\"1\"</span>];</div><div class=\"line\">        [subscriber sendCompleted];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">3.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        [subscriber sendNext:<span class=\"string\">@\"2\"</span>];</div><div class=\"line\">        [subscriber sendCompleted];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">[[signalA zipWith:signalB] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">    <span class=\"comment\">// x是一个RACTuple，包含了signalA和signalB的值</span></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<h3 id=\"RAC的坑\"><a href=\"#RAC的坑\" class=\"headerlink\" title=\"RAC的坑\"></a>RAC的坑</h3><ul>\n<li>side effect: 一个信号源被多个订阅者订阅，每个订阅者收到的信号可能不一样。解决方法：使用reply</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">RACSignal *signalA = [[RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">    i++;</div><div class=\"line\">    [subscriber sendNext:@(i)];</div><div class=\"line\">    [subscriber sendCompleted];</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">&#125;] replay];</div><div class=\"line\"></div><div class=\"line\">[signalA subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">[signalA subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, x);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n"},{"layout":"post","title":"《ios核心动画高级技巧》阅读笔记(1)","_content":"## 第一章 图层树\n\n### CoreAnimation简介\n\n* 动画只是CoreAnimation特性的冰山一角\n* CoreAnimation是一个复合引擎，它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容被分解成独立的图层，存储在一个叫图层树的体系中。\n\n### 图层与视图\n\n* CALayer类在概念上和UIView类似，同样是一些被层级关系树管理的矩形块，同样可以含有一些内容。他有一些方法和属性用来做动画和变换。\n* 和UIView最大的不同是，CALayer不处理用户的交互。CALayer并不清楚具体的响应链，因此它并不能响应时间。\n* 每个UIView都有一个CALayer属性，即所谓的bakinglayer，视图的职责就是创建并管理这个图层。视图的层级关系与其图层的层级关系是相同的。\n* 真正在界面上显示和进行动画的都是CALayer，UIView只是对CALayer的一个封装而已。\n* 进行视图和图层的分类，是为了职责分离，避免重复的代码。ios中视图为UIView，MacOS中视图为NSView，但是他们的图层都是CALayer。\n\n### 图层的能力\n\n* CALayer能做但UIView不能做的东西：\n    * 阴影，圆角，带颜色的边框\n    * 3D变换\n    * 非矩形范围\n    * 透明遮罩\n    * 多级非线性动画\n\n### 使用图层\n\n* 可以直接在UIView的layer属性中添加图层，如下\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    CALayer *blueLayer = [[CALayer alloc] init];\n    blueLayer.frame = CGRectMake(50, 50, 50, 50);\n    blueLayer.backgroundColor = [UIColor blueColor].CGColor;\n    [self.layerView.layer addSublayer:blueLayer];\n\n}\n```\n* 使用图层而不使用视图的情况\n    * 开发可以在MacOS上运行的跨平台应用\n    * 使用多种CALayer的子类（特殊图层），并且不想创建单独的UIView去封装他们\n    * 做一些对性能特别挑剔的工作\n\n## 第二章 寄宿图\n\nCALayer除了可以设置颜色，也可以设置一张图片，这张图片称为CALayer的寄宿图。\n\n### contents属性\n\n* CALayer有一个contents的属性，它虽然是id类型，但是必须设置一个CGImage，才能显示出图片，设置为其他类型，都只会显示一个空白的区域。这种现象是有Mac OS的历史历史原因造成的。在Mac OS上，contents对CGImage和NSImage类型的值都起作用，但在ios中，不能给contents设置一个UIImage。\n* contentGravity属性：与UIView中的contentMode属性对应\n* contentScale属性：定义了寄宿图的像素尺寸和视图的比例，默认为1.0。UIView中与之对应的属性为contentScaleFactor。使用UIImage加载图片会自动根据屏幕加载2x或3x图片，但是使用CGImage则不会。这样我们就需要手动设置contentScale属性来修复这个问题。一般使用代码设置寄宿图，都会手动设置contentScale，如下：`blueLayer.contentsScale = [[UIScreen mainScreen] scale];`\n* maskToBounds属性用来决定是否显示超出边界的内容\n\n### contentsRect属性\n\n* contentRect属性允许我们在图层边框里显示寄宿图的一个子域，这要比contentGravity属性灵活许多。contentRect是一个单位坐标，长宽最大都为1。默认为{0，0，1，1}，当设置为{0，0，0.5，0.5}，则显示效果如下图：\n\n![contentsRect](http://7xn88v.com1.z0.glb.clouddn.com/004ddacd5a9506600889fc2c32686262.png)\n\n* contentRect的另外一个用途就是ImageSprites（图片拼合），把多张图片放在一张大的图片上，然后使用contentRect分别显示每一张图片，去掉不显示的部分，这就是图片拼合。在游戏编程中非常常见。加载一张大图要比加载多张小图效率要高。\n\n### contentsCenter属性\n\n* contentsCenter属性表示图层相对于寄宿图的位置与大小，可以用来定义图片的拉伸。\n* 如下图，虚线框为图层的区域，灰色为内容的区域。\n\n![contentCenter](http://7xn88v.com1.z0.glb.clouddn.com/01278b2b759e5b3c5fc5ae2a961a71ee.png)\n\n* 该属性相当于UIImage的`resizableImageWithCapInsets:`方法\n\n\n### customDrawing\n\n* 除了直接给contents属性设置CGImage，也可以通过CoreGraphics直接绘制寄宿图。使用UIVIew 的drawRect:方法来自定义绘制\n* 除了重写drawRect:方法，也可以通过设置CALayer的代理，使用代理方法`(void)displayLayer:`来实现重绘，但是强烈建议使用前一种方法。\n","source":"_posts/2015-12-27-《ios核心动画高级技巧》阅读笔记(1).md","raw":"---\nlayout: post\ntitle: \"《ios核心动画高级技巧》阅读笔记(1)\"\ncategories: \"读书笔记\"\n---\n## 第一章 图层树\n\n### CoreAnimation简介\n\n* 动画只是CoreAnimation特性的冰山一角\n* CoreAnimation是一个复合引擎，它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容被分解成独立的图层，存储在一个叫图层树的体系中。\n\n### 图层与视图\n\n* CALayer类在概念上和UIView类似，同样是一些被层级关系树管理的矩形块，同样可以含有一些内容。他有一些方法和属性用来做动画和变换。\n* 和UIView最大的不同是，CALayer不处理用户的交互。CALayer并不清楚具体的响应链，因此它并不能响应时间。\n* 每个UIView都有一个CALayer属性，即所谓的bakinglayer，视图的职责就是创建并管理这个图层。视图的层级关系与其图层的层级关系是相同的。\n* 真正在界面上显示和进行动画的都是CALayer，UIView只是对CALayer的一个封装而已。\n* 进行视图和图层的分类，是为了职责分离，避免重复的代码。ios中视图为UIView，MacOS中视图为NSView，但是他们的图层都是CALayer。\n\n### 图层的能力\n\n* CALayer能做但UIView不能做的东西：\n    * 阴影，圆角，带颜色的边框\n    * 3D变换\n    * 非矩形范围\n    * 透明遮罩\n    * 多级非线性动画\n\n### 使用图层\n\n* 可以直接在UIView的layer属性中添加图层，如下\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    CALayer *blueLayer = [[CALayer alloc] init];\n    blueLayer.frame = CGRectMake(50, 50, 50, 50);\n    blueLayer.backgroundColor = [UIColor blueColor].CGColor;\n    [self.layerView.layer addSublayer:blueLayer];\n\n}\n```\n* 使用图层而不使用视图的情况\n    * 开发可以在MacOS上运行的跨平台应用\n    * 使用多种CALayer的子类（特殊图层），并且不想创建单独的UIView去封装他们\n    * 做一些对性能特别挑剔的工作\n\n## 第二章 寄宿图\n\nCALayer除了可以设置颜色，也可以设置一张图片，这张图片称为CALayer的寄宿图。\n\n### contents属性\n\n* CALayer有一个contents的属性，它虽然是id类型，但是必须设置一个CGImage，才能显示出图片，设置为其他类型，都只会显示一个空白的区域。这种现象是有Mac OS的历史历史原因造成的。在Mac OS上，contents对CGImage和NSImage类型的值都起作用，但在ios中，不能给contents设置一个UIImage。\n* contentGravity属性：与UIView中的contentMode属性对应\n* contentScale属性：定义了寄宿图的像素尺寸和视图的比例，默认为1.0。UIView中与之对应的属性为contentScaleFactor。使用UIImage加载图片会自动根据屏幕加载2x或3x图片，但是使用CGImage则不会。这样我们就需要手动设置contentScale属性来修复这个问题。一般使用代码设置寄宿图，都会手动设置contentScale，如下：`blueLayer.contentsScale = [[UIScreen mainScreen] scale];`\n* maskToBounds属性用来决定是否显示超出边界的内容\n\n### contentsRect属性\n\n* contentRect属性允许我们在图层边框里显示寄宿图的一个子域，这要比contentGravity属性灵活许多。contentRect是一个单位坐标，长宽最大都为1。默认为{0，0，1，1}，当设置为{0，0，0.5，0.5}，则显示效果如下图：\n\n![contentsRect](http://7xn88v.com1.z0.glb.clouddn.com/004ddacd5a9506600889fc2c32686262.png)\n\n* contentRect的另外一个用途就是ImageSprites（图片拼合），把多张图片放在一张大的图片上，然后使用contentRect分别显示每一张图片，去掉不显示的部分，这就是图片拼合。在游戏编程中非常常见。加载一张大图要比加载多张小图效率要高。\n\n### contentsCenter属性\n\n* contentsCenter属性表示图层相对于寄宿图的位置与大小，可以用来定义图片的拉伸。\n* 如下图，虚线框为图层的区域，灰色为内容的区域。\n\n![contentCenter](http://7xn88v.com1.z0.glb.clouddn.com/01278b2b759e5b3c5fc5ae2a961a71ee.png)\n\n* 该属性相当于UIImage的`resizableImageWithCapInsets:`方法\n\n\n### customDrawing\n\n* 除了直接给contents属性设置CGImage，也可以通过CoreGraphics直接绘制寄宿图。使用UIVIew 的drawRect:方法来自定义绘制\n* 除了重写drawRect:方法，也可以通过设置CALayer的代理，使用代理方法`(void)displayLayer:`来实现重绘，但是强烈建议使用前一种方法。\n","slug":"《ios核心动画高级技巧》阅读笔记(1)","published":1,"date":"2015-12-26T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oab40018zrm073yjy2sv","content":"<h2 id=\"第一章-图层树\"><a href=\"#第一章-图层树\" class=\"headerlink\" title=\"第一章 图层树\"></a>第一章 图层树</h2><h3 id=\"CoreAnimation简介\"><a href=\"#CoreAnimation简介\" class=\"headerlink\" title=\"CoreAnimation简介\"></a>CoreAnimation简介</h3><ul>\n<li>动画只是CoreAnimation特性的冰山一角</li>\n<li>CoreAnimation是一个复合引擎，它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容被分解成独立的图层，存储在一个叫图层树的体系中。</li>\n</ul>\n<h3 id=\"图层与视图\"><a href=\"#图层与视图\" class=\"headerlink\" title=\"图层与视图\"></a>图层与视图</h3><ul>\n<li>CALayer类在概念上和UIView类似，同样是一些被层级关系树管理的矩形块，同样可以含有一些内容。他有一些方法和属性用来做动画和变换。</li>\n<li>和UIView最大的不同是，CALayer不处理用户的交互。CALayer并不清楚具体的响应链，因此它并不能响应时间。</li>\n<li>每个UIView都有一个CALayer属性，即所谓的bakinglayer，视图的职责就是创建并管理这个图层。视图的层级关系与其图层的层级关系是相同的。</li>\n<li>真正在界面上显示和进行动画的都是CALayer，UIView只是对CALayer的一个封装而已。</li>\n<li>进行视图和图层的分类，是为了职责分离，避免重复的代码。ios中视图为UIView，MacOS中视图为NSView，但是他们的图层都是CALayer。</li>\n</ul>\n<h3 id=\"图层的能力\"><a href=\"#图层的能力\" class=\"headerlink\" title=\"图层的能力\"></a>图层的能力</h3><ul>\n<li>CALayer能做但UIView不能做的东西：<ul>\n<li>阴影，圆角，带颜色的边框</li>\n<li>3D变换</li>\n<li>非矩形范围</li>\n<li>透明遮罩</li>\n<li>多级非线性动画</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"使用图层\"><a href=\"#使用图层\" class=\"headerlink\" title=\"使用图层\"></a>使用图层</h3><ul>\n<li>可以直接在UIView的layer属性中添加图层，如下</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">CALayer</span> *blueLayer = [[<span class=\"built_in\">CALayer</span> alloc] init];</div><div class=\"line\">    blueLayer.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">50</span>);</div><div class=\"line\">    blueLayer.backgroundColor = [<span class=\"built_in\">UIColor</span> blueColor].CGColor;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.layerView.layer addSublayer:blueLayer];</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>使用图层而不使用视图的情况<ul>\n<li>开发可以在MacOS上运行的跨平台应用</li>\n<li>使用多种CALayer的子类（特殊图层），并且不想创建单独的UIView去封装他们</li>\n<li>做一些对性能特别挑剔的工作</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第二章-寄宿图\"><a href=\"#第二章-寄宿图\" class=\"headerlink\" title=\"第二章 寄宿图\"></a>第二章 寄宿图</h2><p>CALayer除了可以设置颜色，也可以设置一张图片，这张图片称为CALayer的寄宿图。</p>\n<h3 id=\"contents属性\"><a href=\"#contents属性\" class=\"headerlink\" title=\"contents属性\"></a>contents属性</h3><ul>\n<li>CALayer有一个contents的属性，它虽然是id类型，但是必须设置一个CGImage，才能显示出图片，设置为其他类型，都只会显示一个空白的区域。这种现象是有Mac OS的历史历史原因造成的。在Mac OS上，contents对CGImage和NSImage类型的值都起作用，但在ios中，不能给contents设置一个UIImage。</li>\n<li>contentGravity属性：与UIView中的contentMode属性对应</li>\n<li>contentScale属性：定义了寄宿图的像素尺寸和视图的比例，默认为1.0。UIView中与之对应的属性为contentScaleFactor。使用UIImage加载图片会自动根据屏幕加载2x或3x图片，但是使用CGImage则不会。这样我们就需要手动设置contentScale属性来修复这个问题。一般使用代码设置寄宿图，都会手动设置contentScale，如下：<code>blueLayer.contentsScale = [[UIScreen mainScreen] scale];</code></li>\n<li>maskToBounds属性用来决定是否显示超出边界的内容</li>\n</ul>\n<h3 id=\"contentsRect属性\"><a href=\"#contentsRect属性\" class=\"headerlink\" title=\"contentsRect属性\"></a>contentsRect属性</h3><ul>\n<li>contentRect属性允许我们在图层边框里显示寄宿图的一个子域，这要比contentGravity属性灵活许多。contentRect是一个单位坐标，长宽最大都为1。默认为{0，0，1，1}，当设置为{0，0，0.5，0.5}，则显示效果如下图：</li>\n</ul>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/004ddacd5a9506600889fc2c32686262.png\" alt=\"contentsRect\"></p>\n<ul>\n<li>contentRect的另外一个用途就是ImageSprites（图片拼合），把多张图片放在一张大的图片上，然后使用contentRect分别显示每一张图片，去掉不显示的部分，这就是图片拼合。在游戏编程中非常常见。加载一张大图要比加载多张小图效率要高。</li>\n</ul>\n<h3 id=\"contentsCenter属性\"><a href=\"#contentsCenter属性\" class=\"headerlink\" title=\"contentsCenter属性\"></a>contentsCenter属性</h3><ul>\n<li>contentsCenter属性表示图层相对于寄宿图的位置与大小，可以用来定义图片的拉伸。</li>\n<li>如下图，虚线框为图层的区域，灰色为内容的区域。</li>\n</ul>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/01278b2b759e5b3c5fc5ae2a961a71ee.png\" alt=\"contentCenter\"></p>\n<ul>\n<li>该属性相当于UIImage的<code>resizableImageWithCapInsets:</code>方法</li>\n</ul>\n<h3 id=\"customDrawing\"><a href=\"#customDrawing\" class=\"headerlink\" title=\"customDrawing\"></a>customDrawing</h3><ul>\n<li>除了直接给contents属性设置CGImage，也可以通过CoreGraphics直接绘制寄宿图。使用UIVIew 的drawRect:方法来自定义绘制</li>\n<li>除了重写drawRect:方法，也可以通过设置CALayer的代理，使用代理方法<code>(void)displayLayer:</code>来实现重绘，但是强烈建议使用前一种方法。</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"第一章-图层树\"><a href=\"#第一章-图层树\" class=\"headerlink\" title=\"第一章 图层树\"></a>第一章 图层树</h2><h3 id=\"CoreAnimation简介\"><a href=\"#CoreAnimation简介\" class=\"headerlink\" title=\"CoreAnimation简介\"></a>CoreAnimation简介</h3><ul>\n<li>动画只是CoreAnimation特性的冰山一角</li>\n<li>CoreAnimation是一个复合引擎，它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容被分解成独立的图层，存储在一个叫图层树的体系中。</li>\n</ul>\n<h3 id=\"图层与视图\"><a href=\"#图层与视图\" class=\"headerlink\" title=\"图层与视图\"></a>图层与视图</h3><ul>\n<li>CALayer类在概念上和UIView类似，同样是一些被层级关系树管理的矩形块，同样可以含有一些内容。他有一些方法和属性用来做动画和变换。</li>\n<li>和UIView最大的不同是，CALayer不处理用户的交互。CALayer并不清楚具体的响应链，因此它并不能响应时间。</li>\n<li>每个UIView都有一个CALayer属性，即所谓的bakinglayer，视图的职责就是创建并管理这个图层。视图的层级关系与其图层的层级关系是相同的。</li>\n<li>真正在界面上显示和进行动画的都是CALayer，UIView只是对CALayer的一个封装而已。</li>\n<li>进行视图和图层的分类，是为了职责分离，避免重复的代码。ios中视图为UIView，MacOS中视图为NSView，但是他们的图层都是CALayer。</li>\n</ul>\n<h3 id=\"图层的能力\"><a href=\"#图层的能力\" class=\"headerlink\" title=\"图层的能力\"></a>图层的能力</h3><ul>\n<li>CALayer能做但UIView不能做的东西：<ul>\n<li>阴影，圆角，带颜色的边框</li>\n<li>3D变换</li>\n<li>非矩形范围</li>\n<li>透明遮罩</li>\n<li>多级非线性动画</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"使用图层\"><a href=\"#使用图层\" class=\"headerlink\" title=\"使用图层\"></a>使用图层</h3><ul>\n<li>可以直接在UIView的layer属性中添加图层，如下</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">CALayer</span> *blueLayer = [[<span class=\"built_in\">CALayer</span> alloc] init];</div><div class=\"line\">    blueLayer.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">50</span>);</div><div class=\"line\">    blueLayer.backgroundColor = [<span class=\"built_in\">UIColor</span> blueColor].CGColor;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.layerView.layer addSublayer:blueLayer];</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>使用图层而不使用视图的情况<ul>\n<li>开发可以在MacOS上运行的跨平台应用</li>\n<li>使用多种CALayer的子类（特殊图层），并且不想创建单独的UIView去封装他们</li>\n<li>做一些对性能特别挑剔的工作</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第二章-寄宿图\"><a href=\"#第二章-寄宿图\" class=\"headerlink\" title=\"第二章 寄宿图\"></a>第二章 寄宿图</h2><p>CALayer除了可以设置颜色，也可以设置一张图片，这张图片称为CALayer的寄宿图。</p>\n<h3 id=\"contents属性\"><a href=\"#contents属性\" class=\"headerlink\" title=\"contents属性\"></a>contents属性</h3><ul>\n<li>CALayer有一个contents的属性，它虽然是id类型，但是必须设置一个CGImage，才能显示出图片，设置为其他类型，都只会显示一个空白的区域。这种现象是有Mac OS的历史历史原因造成的。在Mac OS上，contents对CGImage和NSImage类型的值都起作用，但在ios中，不能给contents设置一个UIImage。</li>\n<li>contentGravity属性：与UIView中的contentMode属性对应</li>\n<li>contentScale属性：定义了寄宿图的像素尺寸和视图的比例，默认为1.0。UIView中与之对应的属性为contentScaleFactor。使用UIImage加载图片会自动根据屏幕加载2x或3x图片，但是使用CGImage则不会。这样我们就需要手动设置contentScale属性来修复这个问题。一般使用代码设置寄宿图，都会手动设置contentScale，如下：<code>blueLayer.contentsScale = [[UIScreen mainScreen] scale];</code></li>\n<li>maskToBounds属性用来决定是否显示超出边界的内容</li>\n</ul>\n<h3 id=\"contentsRect属性\"><a href=\"#contentsRect属性\" class=\"headerlink\" title=\"contentsRect属性\"></a>contentsRect属性</h3><ul>\n<li>contentRect属性允许我们在图层边框里显示寄宿图的一个子域，这要比contentGravity属性灵活许多。contentRect是一个单位坐标，长宽最大都为1。默认为{0，0，1，1}，当设置为{0，0，0.5，0.5}，则显示效果如下图：</li>\n</ul>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/004ddacd5a9506600889fc2c32686262.png\" alt=\"contentsRect\"></p>\n<ul>\n<li>contentRect的另外一个用途就是ImageSprites（图片拼合），把多张图片放在一张大的图片上，然后使用contentRect分别显示每一张图片，去掉不显示的部分，这就是图片拼合。在游戏编程中非常常见。加载一张大图要比加载多张小图效率要高。</li>\n</ul>\n<h3 id=\"contentsCenter属性\"><a href=\"#contentsCenter属性\" class=\"headerlink\" title=\"contentsCenter属性\"></a>contentsCenter属性</h3><ul>\n<li>contentsCenter属性表示图层相对于寄宿图的位置与大小，可以用来定义图片的拉伸。</li>\n<li>如下图，虚线框为图层的区域，灰色为内容的区域。</li>\n</ul>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/01278b2b759e5b3c5fc5ae2a961a71ee.png\" alt=\"contentCenter\"></p>\n<ul>\n<li>该属性相当于UIImage的<code>resizableImageWithCapInsets:</code>方法</li>\n</ul>\n<h3 id=\"customDrawing\"><a href=\"#customDrawing\" class=\"headerlink\" title=\"customDrawing\"></a>customDrawing</h3><ul>\n<li>除了直接给contents属性设置CGImage，也可以通过CoreGraphics直接绘制寄宿图。使用UIVIew 的drawRect:方法来自定义绘制</li>\n<li>除了重写drawRect:方法，也可以通过设置CALayer的代理，使用代理方法<code>(void)displayLayer:</code>来实现重绘，但是强烈建议使用前一种方法。</li>\n</ul>\n"},{"layout":"post","title":"《ios核心动画高级技巧》阅读笔记(3)","_content":"\n## 第四章 视觉效果\n\n### 圆角\n\n* 设置CALayer的cornerRadius属性来设置圆角，并且要把maskToBounds设置为YES\n\n### 边框\n\n* 设置CALayer的borderColor和borderWidth可以设置边框的颜色和宽度\n\n### 阴影\n\n* shadowColor:阴影的颜色\n* shadowOpacity:阴影的透明度\n* shadowOffset:阴影的偏移\n* shadowRadius:阴影的模糊度，即模糊半径\n* 如果设置了maskToBounds，则阴影就不会显示了，因为阴影已经被裁减调了。要解决这个问题，可以再创建一个frame一样的View，给这个view设置阴影，而设置原本的view的maskToBounds，这样阴影就不会被裁减掉了。\n* shadowPath:指定阴影的路径。\n* 设置ImageView,label等的阴影，并不是设置他们边界的阴影，而是设置里面内容的阴影，例如设置label的阴影，设置的是label中文字的阴影。\n\n```objectivec\n- (void)viewDidAppear:(BOOL)animated {\n    [super viewDidAppear:animated];\n    self.buleView.hidden = YES;\n    self.layerView.layer.shadowColor = [UIColor redColor].CGColor;\n    self.layerView.layer.shadowOpacity = 1;\n    self.layerView.layer.shadowRadius = 10;\n\n    CGMutablePathRef path = CGPathCreateMutable();\n    CGPathAddEllipseInRect(path, NULL, self.layerView.bounds);\n    self.layerView.layer.shadowPath = path;\n    CGPathRelease(path);\n}\n```\n\n### 图层蒙版\n\n* mask:CALayer的mask属性定义了父图层的部分可见区域，父图层与mask的关系如下图\n\n![mask](http://7xn88v.com1.z0.glb.clouddn.com/87291a0061be6a254bd4937851ecf4d8.png)\n\n* 虽然设置了mask，但是视图的事件响应区域任然是原视图的区域\n* mask是可以动态设置的，只要改变mask的大小，就可以对视图的显示区域进行动画\n\n```objectivec\n- (void)viewDidAppear:(BOOL)animated {\n    [super viewDidAppear:animated];\n    CAShapeLayer *mask = [CAShapeLayer layer];\n    UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:self.greenBtn.bounds];\n    mask.path = path.CGPath;\n    self.greenBtn.layer.mask = mask;\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {\n\n    UIBezierPath *endPath = [UIBezierPath bezierPathWithRect:self.greenBtn.bounds];\n    CAShapeLayer *layer = (CAShapeLayer *)self.greenBtn.layer.mask;\n\n    // 动画\n    CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@\"path\"];\n    animation.duration = 1;\n    animation.fromValue = (id)layer.path;\n    animation.toValue = (__bridge id _Nullable)(endPath.CGPath);\n    animation.removedOnCompletion = NO;\n    animation.fillMode = kCAFillModeForwards;\n    [layer addAnimation:animation forKey:@\"shapeLayerPath\"];\n}\n```\n\n### 拉伸过滤\n\n* minificationFilter:缩小图片的拉伸算法\n* magnificationFilter:方法图片的拉伸算法\n* 三个值：kCAFilterNearest，kCAFilterLinear，kCAFilterTrilinear\n\n### 组透明\n\n* 改变视图或图层的透明度，其子视图或子图层的透明度也会跟着改变，但是经过叠加后，原本颜色相同的父子视图，变成了不同的视图，如下图：\n\n![group-opacity](http://7xn88v.com1.z0.glb.clouddn.com/dda57bde043a3358e1cbc03af4fcbcf1.png)\n\n* 为了解决这种问题，可以在plist中添加\"Renders with group opacity\"为YES（目前ios9中默认就为YES），或者设置CALayer的shouldRasterize为YES也可以达到相同的效果。\n","source":"_posts/2015-12-27-《ios核心动画高级技巧》阅读笔记(3).md","raw":"---\nlayout: post\ntitle: \"《ios核心动画高级技巧》阅读笔记(3)\"\ncategories: \"读书笔记\"\n---\n\n## 第四章 视觉效果\n\n### 圆角\n\n* 设置CALayer的cornerRadius属性来设置圆角，并且要把maskToBounds设置为YES\n\n### 边框\n\n* 设置CALayer的borderColor和borderWidth可以设置边框的颜色和宽度\n\n### 阴影\n\n* shadowColor:阴影的颜色\n* shadowOpacity:阴影的透明度\n* shadowOffset:阴影的偏移\n* shadowRadius:阴影的模糊度，即模糊半径\n* 如果设置了maskToBounds，则阴影就不会显示了，因为阴影已经被裁减调了。要解决这个问题，可以再创建一个frame一样的View，给这个view设置阴影，而设置原本的view的maskToBounds，这样阴影就不会被裁减掉了。\n* shadowPath:指定阴影的路径。\n* 设置ImageView,label等的阴影，并不是设置他们边界的阴影，而是设置里面内容的阴影，例如设置label的阴影，设置的是label中文字的阴影。\n\n```objectivec\n- (void)viewDidAppear:(BOOL)animated {\n    [super viewDidAppear:animated];\n    self.buleView.hidden = YES;\n    self.layerView.layer.shadowColor = [UIColor redColor].CGColor;\n    self.layerView.layer.shadowOpacity = 1;\n    self.layerView.layer.shadowRadius = 10;\n\n    CGMutablePathRef path = CGPathCreateMutable();\n    CGPathAddEllipseInRect(path, NULL, self.layerView.bounds);\n    self.layerView.layer.shadowPath = path;\n    CGPathRelease(path);\n}\n```\n\n### 图层蒙版\n\n* mask:CALayer的mask属性定义了父图层的部分可见区域，父图层与mask的关系如下图\n\n![mask](http://7xn88v.com1.z0.glb.clouddn.com/87291a0061be6a254bd4937851ecf4d8.png)\n\n* 虽然设置了mask，但是视图的事件响应区域任然是原视图的区域\n* mask是可以动态设置的，只要改变mask的大小，就可以对视图的显示区域进行动画\n\n```objectivec\n- (void)viewDidAppear:(BOOL)animated {\n    [super viewDidAppear:animated];\n    CAShapeLayer *mask = [CAShapeLayer layer];\n    UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:self.greenBtn.bounds];\n    mask.path = path.CGPath;\n    self.greenBtn.layer.mask = mask;\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {\n\n    UIBezierPath *endPath = [UIBezierPath bezierPathWithRect:self.greenBtn.bounds];\n    CAShapeLayer *layer = (CAShapeLayer *)self.greenBtn.layer.mask;\n\n    // 动画\n    CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@\"path\"];\n    animation.duration = 1;\n    animation.fromValue = (id)layer.path;\n    animation.toValue = (__bridge id _Nullable)(endPath.CGPath);\n    animation.removedOnCompletion = NO;\n    animation.fillMode = kCAFillModeForwards;\n    [layer addAnimation:animation forKey:@\"shapeLayerPath\"];\n}\n```\n\n### 拉伸过滤\n\n* minificationFilter:缩小图片的拉伸算法\n* magnificationFilter:方法图片的拉伸算法\n* 三个值：kCAFilterNearest，kCAFilterLinear，kCAFilterTrilinear\n\n### 组透明\n\n* 改变视图或图层的透明度，其子视图或子图层的透明度也会跟着改变，但是经过叠加后，原本颜色相同的父子视图，变成了不同的视图，如下图：\n\n![group-opacity](http://7xn88v.com1.z0.glb.clouddn.com/dda57bde043a3358e1cbc03af4fcbcf1.png)\n\n* 为了解决这种问题，可以在plist中添加\"Renders with group opacity\"为YES（目前ios9中默认就为YES），或者设置CALayer的shouldRasterize为YES也可以达到相同的效果。\n","slug":"《ios核心动画高级技巧》阅读笔记(3)","published":1,"date":"2015-12-26T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oab6001azrm0jea2i8oy","content":"<h2 id=\"第四章-视觉效果\"><a href=\"#第四章-视觉效果\" class=\"headerlink\" title=\"第四章 视觉效果\"></a>第四章 视觉效果</h2><h3 id=\"圆角\"><a href=\"#圆角\" class=\"headerlink\" title=\"圆角\"></a>圆角</h3><ul>\n<li>设置CALayer的cornerRadius属性来设置圆角，并且要把maskToBounds设置为YES</li>\n</ul>\n<h3 id=\"边框\"><a href=\"#边框\" class=\"headerlink\" title=\"边框\"></a>边框</h3><ul>\n<li>设置CALayer的borderColor和borderWidth可以设置边框的颜色和宽度</li>\n</ul>\n<h3 id=\"阴影\"><a href=\"#阴影\" class=\"headerlink\" title=\"阴影\"></a>阴影</h3><ul>\n<li>shadowColor:阴影的颜色</li>\n<li>shadowOpacity:阴影的透明度</li>\n<li>shadowOffset:阴影的偏移</li>\n<li>shadowRadius:阴影的模糊度，即模糊半径</li>\n<li>如果设置了maskToBounds，则阴影就不会显示了，因为阴影已经被裁减调了。要解决这个问题，可以再创建一个frame一样的View，给这个view设置阴影，而设置原本的view的maskToBounds，这样阴影就不会被裁减掉了。</li>\n<li>shadowPath:指定阴影的路径。</li>\n<li>设置ImageView,label等的阴影，并不是设置他们边界的阴影，而是设置里面内容的阴影，例如设置label的阴影，设置的是label中文字的阴影。</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidAppear:(<span class=\"built_in\">BOOL</span>)animated &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidAppear:animated];</div><div class=\"line\">    <span class=\"keyword\">self</span>.buleView.hidden = <span class=\"literal\">YES</span>;</div><div class=\"line\">    <span class=\"keyword\">self</span>.layerView.layer.shadowColor = [<span class=\"built_in\">UIColor</span> redColor].CGColor;</div><div class=\"line\">    <span class=\"keyword\">self</span>.layerView.layer.shadowOpacity = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">self</span>.layerView.layer.shadowRadius = <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">CGMutablePathRef</span> path = <span class=\"built_in\">CGPathCreateMutable</span>();</div><div class=\"line\">    <span class=\"built_in\">CGPathAddEllipseInRect</span>(path, <span class=\"literal\">NULL</span>, <span class=\"keyword\">self</span>.layerView.bounds);</div><div class=\"line\">    <span class=\"keyword\">self</span>.layerView.layer.shadowPath = path;</div><div class=\"line\">    <span class=\"built_in\">CGPathRelease</span>(path);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"图层蒙版\"><a href=\"#图层蒙版\" class=\"headerlink\" title=\"图层蒙版\"></a>图层蒙版</h3><ul>\n<li>mask:CALayer的mask属性定义了父图层的部分可见区域，父图层与mask的关系如下图</li>\n</ul>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/87291a0061be6a254bd4937851ecf4d8.png\" alt=\"mask\"></p>\n<ul>\n<li>虽然设置了mask，但是视图的事件响应区域任然是原视图的区域</li>\n<li>mask是可以动态设置的，只要改变mask的大小，就可以对视图的显示区域进行动画</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidAppear:(<span class=\"built_in\">BOOL</span>)animated &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidAppear:animated];</div><div class=\"line\">    <span class=\"built_in\">CAShapeLayer</span> *mask = [<span class=\"built_in\">CAShapeLayer</span> layer];</div><div class=\"line\">    <span class=\"built_in\">UIBezierPath</span> *path = [<span class=\"built_in\">UIBezierPath</span> bezierPathWithOvalInRect:<span class=\"keyword\">self</span>.greenBtn.bounds];</div><div class=\"line\">    mask.path = path.CGPath;</div><div class=\"line\">    <span class=\"keyword\">self</span>.greenBtn.layer.mask = mask;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">UITouch</span> *&gt; *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">UIBezierPath</span> *endPath = [<span class=\"built_in\">UIBezierPath</span> bezierPathWithRect:<span class=\"keyword\">self</span>.greenBtn.bounds];</div><div class=\"line\">    <span class=\"built_in\">CAShapeLayer</span> *layer = (<span class=\"built_in\">CAShapeLayer</span> *)<span class=\"keyword\">self</span>.greenBtn.layer.mask;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 动画</span></div><div class=\"line\">    <span class=\"built_in\">CABasicAnimation</span> *animation = [<span class=\"built_in\">CABasicAnimation</span> animationWithKeyPath:<span class=\"string\">@\"path\"</span>];</div><div class=\"line\">    animation.duration = <span class=\"number\">1</span>;</div><div class=\"line\">    animation.fromValue = (<span class=\"keyword\">id</span>)layer.path;</div><div class=\"line\">    animation.toValue = (__bridge <span class=\"keyword\">id</span> _Nullable)(endPath.CGPath);</div><div class=\"line\">    animation.removedOnCompletion = <span class=\"literal\">NO</span>;</div><div class=\"line\">    animation.fillMode = kCAFillModeForwards;</div><div class=\"line\">    [layer addAnimation:animation forKey:<span class=\"string\">@\"shapeLayerPath\"</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"拉伸过滤\"><a href=\"#拉伸过滤\" class=\"headerlink\" title=\"拉伸过滤\"></a>拉伸过滤</h3><ul>\n<li>minificationFilter:缩小图片的拉伸算法</li>\n<li>magnificationFilter:方法图片的拉伸算法</li>\n<li>三个值：kCAFilterNearest，kCAFilterLinear，kCAFilterTrilinear</li>\n</ul>\n<h3 id=\"组透明\"><a href=\"#组透明\" class=\"headerlink\" title=\"组透明\"></a>组透明</h3><ul>\n<li>改变视图或图层的透明度，其子视图或子图层的透明度也会跟着改变，但是经过叠加后，原本颜色相同的父子视图，变成了不同的视图，如下图：</li>\n</ul>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/dda57bde043a3358e1cbc03af4fcbcf1.png\" alt=\"group-opacity\"></p>\n<ul>\n<li>为了解决这种问题，可以在plist中添加”Renders with group opacity”为YES（目前ios9中默认就为YES），或者设置CALayer的shouldRasterize为YES也可以达到相同的效果。</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"第四章-视觉效果\"><a href=\"#第四章-视觉效果\" class=\"headerlink\" title=\"第四章 视觉效果\"></a>第四章 视觉效果</h2><h3 id=\"圆角\"><a href=\"#圆角\" class=\"headerlink\" title=\"圆角\"></a>圆角</h3><ul>\n<li>设置CALayer的cornerRadius属性来设置圆角，并且要把maskToBounds设置为YES</li>\n</ul>\n<h3 id=\"边框\"><a href=\"#边框\" class=\"headerlink\" title=\"边框\"></a>边框</h3><ul>\n<li>设置CALayer的borderColor和borderWidth可以设置边框的颜色和宽度</li>\n</ul>\n<h3 id=\"阴影\"><a href=\"#阴影\" class=\"headerlink\" title=\"阴影\"></a>阴影</h3><ul>\n<li>shadowColor:阴影的颜色</li>\n<li>shadowOpacity:阴影的透明度</li>\n<li>shadowOffset:阴影的偏移</li>\n<li>shadowRadius:阴影的模糊度，即模糊半径</li>\n<li>如果设置了maskToBounds，则阴影就不会显示了，因为阴影已经被裁减调了。要解决这个问题，可以再创建一个frame一样的View，给这个view设置阴影，而设置原本的view的maskToBounds，这样阴影就不会被裁减掉了。</li>\n<li>shadowPath:指定阴影的路径。</li>\n<li>设置ImageView,label等的阴影，并不是设置他们边界的阴影，而是设置里面内容的阴影，例如设置label的阴影，设置的是label中文字的阴影。</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidAppear:(<span class=\"built_in\">BOOL</span>)animated &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidAppear:animated];</div><div class=\"line\">    <span class=\"keyword\">self</span>.buleView.hidden = <span class=\"literal\">YES</span>;</div><div class=\"line\">    <span class=\"keyword\">self</span>.layerView.layer.shadowColor = [<span class=\"built_in\">UIColor</span> redColor].CGColor;</div><div class=\"line\">    <span class=\"keyword\">self</span>.layerView.layer.shadowOpacity = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">self</span>.layerView.layer.shadowRadius = <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">CGMutablePathRef</span> path = <span class=\"built_in\">CGPathCreateMutable</span>();</div><div class=\"line\">    <span class=\"built_in\">CGPathAddEllipseInRect</span>(path, <span class=\"literal\">NULL</span>, <span class=\"keyword\">self</span>.layerView.bounds);</div><div class=\"line\">    <span class=\"keyword\">self</span>.layerView.layer.shadowPath = path;</div><div class=\"line\">    <span class=\"built_in\">CGPathRelease</span>(path);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"图层蒙版\"><a href=\"#图层蒙版\" class=\"headerlink\" title=\"图层蒙版\"></a>图层蒙版</h3><ul>\n<li>mask:CALayer的mask属性定义了父图层的部分可见区域，父图层与mask的关系如下图</li>\n</ul>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/87291a0061be6a254bd4937851ecf4d8.png\" alt=\"mask\"></p>\n<ul>\n<li>虽然设置了mask，但是视图的事件响应区域任然是原视图的区域</li>\n<li>mask是可以动态设置的，只要改变mask的大小，就可以对视图的显示区域进行动画</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidAppear:(<span class=\"built_in\">BOOL</span>)animated &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidAppear:animated];</div><div class=\"line\">    <span class=\"built_in\">CAShapeLayer</span> *mask = [<span class=\"built_in\">CAShapeLayer</span> layer];</div><div class=\"line\">    <span class=\"built_in\">UIBezierPath</span> *path = [<span class=\"built_in\">UIBezierPath</span> bezierPathWithOvalInRect:<span class=\"keyword\">self</span>.greenBtn.bounds];</div><div class=\"line\">    mask.path = path.CGPath;</div><div class=\"line\">    <span class=\"keyword\">self</span>.greenBtn.layer.mask = mask;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">UITouch</span> *&gt; *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">UIBezierPath</span> *endPath = [<span class=\"built_in\">UIBezierPath</span> bezierPathWithRect:<span class=\"keyword\">self</span>.greenBtn.bounds];</div><div class=\"line\">    <span class=\"built_in\">CAShapeLayer</span> *layer = (<span class=\"built_in\">CAShapeLayer</span> *)<span class=\"keyword\">self</span>.greenBtn.layer.mask;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 动画</span></div><div class=\"line\">    <span class=\"built_in\">CABasicAnimation</span> *animation = [<span class=\"built_in\">CABasicAnimation</span> animationWithKeyPath:<span class=\"string\">@\"path\"</span>];</div><div class=\"line\">    animation.duration = <span class=\"number\">1</span>;</div><div class=\"line\">    animation.fromValue = (<span class=\"keyword\">id</span>)layer.path;</div><div class=\"line\">    animation.toValue = (__bridge <span class=\"keyword\">id</span> _Nullable)(endPath.CGPath);</div><div class=\"line\">    animation.removedOnCompletion = <span class=\"literal\">NO</span>;</div><div class=\"line\">    animation.fillMode = kCAFillModeForwards;</div><div class=\"line\">    [layer addAnimation:animation forKey:<span class=\"string\">@\"shapeLayerPath\"</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"拉伸过滤\"><a href=\"#拉伸过滤\" class=\"headerlink\" title=\"拉伸过滤\"></a>拉伸过滤</h3><ul>\n<li>minificationFilter:缩小图片的拉伸算法</li>\n<li>magnificationFilter:方法图片的拉伸算法</li>\n<li>三个值：kCAFilterNearest，kCAFilterLinear，kCAFilterTrilinear</li>\n</ul>\n<h3 id=\"组透明\"><a href=\"#组透明\" class=\"headerlink\" title=\"组透明\"></a>组透明</h3><ul>\n<li>改变视图或图层的透明度，其子视图或子图层的透明度也会跟着改变，但是经过叠加后，原本颜色相同的父子视图，变成了不同的视图，如下图：</li>\n</ul>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/dda57bde043a3358e1cbc03af4fcbcf1.png\" alt=\"group-opacity\"></p>\n<ul>\n<li>为了解决这种问题，可以在plist中添加”Renders with group opacity”为YES（目前ios9中默认就为YES），或者设置CALayer的shouldRasterize为YES也可以达到相同的效果。</li>\n</ul>\n"},{"layout":"post","title":"《ios核心动画高级技巧》阅读笔记(2)","_content":"## 第三章 图层集合学\n\n### 布局\n\n* frame：图层的相对于父图层的外部坐标\n* bounds：内部坐标\n* center和position：相对于父图层anchorPoint所在的位置\n* 设置视图的frame，bounds和center，也就是相当于设置图层的frame，bounds和position\n* 一般情况下，frame中的size与bounds中的size是相同的，但是当视图旋转时，frame的size和bounds的size就不一样了，如下图\n\n![frame&bounds&center](http://7xn88v.com1.z0.glb.clouddn.com/a592d9f689fe8a2818583430f5a8211d.png)\n\n### 锚点\n\n* 锚点是相对于父图层anchorPoint所在的位置。\n* 默认，锚点位于图层的中点，可以改变锚点的位置，描点改变，frame也会随之改变。\n\n![anchorPoint](http://7xn88v.com1.z0.glb.clouddn.com/99c7a6ddc1d2b162816b2a9ef5ff568f.png)\n\n* 改变锚点，position不会改变，但是frame改变了。\n* anchorPoint是View在旋转是的轴点，如果想改变view的旋转轴点，改变anchorPoint即可\n\n### 坐标系\n\n* 与UIView一样，CALayer也提供了一套坐标变换的借口\n\n```objectivec\n- (CGPoint)convertPoint:(CGPoint)p fromLayer:(nullable CALayer *)l;\n- (CGPoint)convertPoint:(CGPoint)p toLayer:(nullable CALayer *)l;\n- (CGRect)convertRect:(CGRect)r fromLayer:(nullable CALayer *)l;\n- (CGRect)convertRect:(CGRect)r toLayer:(nullable CALayer *)l;\n```\n\n### 翻转的几何结构\n\n* ios上坐标系原点为左上角，macOS上坐标系原点为左下角。\n* CALayer的`geometryFlipped`属性决定了图层的坐标是否相对于父图层翻转。\n\n### z坐标轴\n\n* zPosition：表示图层空间z轴上的位置\n* zPosition除了可以改变z轴的位置，还可以用来改变图层的先后顺序，如图，如果设置了绿色view的zPosition，绿色View就可以覆盖在蓝色view之上。但是通过这种方法改变视图的层次，是不能改变视图的响应事件的顺序的。\n\n![zPositon](http://7xn88v.com1.z0.glb.clouddn.com/d673bc31fdbe28367ad557ac739a60fd.png)\n\n* anchorPointZ表示z轴上锚点的位置\n\n### Hit Testing\n\n* CALayer不能处理点击事件，但是他有一系列方法帮你处理事件。\n* `- (BOOL)containsPoint:(CGPoint)p;`用于判断一个点是否属于一个图层\n* `- (nullable CALayer *)hitTest:(CGPoint)p;`返回被点击的图层\n\n```objectivec\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {\n    UITouch *touch = [touches anyObject];\n    CGPoint point = [touch locationInView:self.view];\n\n    point = [self.layerView convertPoint:point fromView:self.view];\n    BOOL ret = [self.layerView.layer containsPoint:point];\n    if (ret) {\n        NSLog(@\"green\");\n    }\n\n    point = [self.buleView convertPoint:point fromView:self.layerView];\n    ret = [self.buleView.layer containsPoint:point];\n    if (ret) {\n        NSLog(@\"blue\");\n    }\n\n    CALayer *layer = [self.view.layer hitTest:point];\n    if (layer == self.layerView.layer) {\n        NSLog(@\"green\");\n    }\n    else if(layer == self.buleView.layer) {\n        NSLog(@\"blue\");\n    }\n\n}\n```\n","source":"_posts/2015-12-27-《ios核心动画高级技巧》阅读笔记(2).md","raw":"---\nlayout: post\ntitle: \"《ios核心动画高级技巧》阅读笔记(2)\"\ncategories: \"读书笔记\"\n---\n## 第三章 图层集合学\n\n### 布局\n\n* frame：图层的相对于父图层的外部坐标\n* bounds：内部坐标\n* center和position：相对于父图层anchorPoint所在的位置\n* 设置视图的frame，bounds和center，也就是相当于设置图层的frame，bounds和position\n* 一般情况下，frame中的size与bounds中的size是相同的，但是当视图旋转时，frame的size和bounds的size就不一样了，如下图\n\n![frame&bounds&center](http://7xn88v.com1.z0.glb.clouddn.com/a592d9f689fe8a2818583430f5a8211d.png)\n\n### 锚点\n\n* 锚点是相对于父图层anchorPoint所在的位置。\n* 默认，锚点位于图层的中点，可以改变锚点的位置，描点改变，frame也会随之改变。\n\n![anchorPoint](http://7xn88v.com1.z0.glb.clouddn.com/99c7a6ddc1d2b162816b2a9ef5ff568f.png)\n\n* 改变锚点，position不会改变，但是frame改变了。\n* anchorPoint是View在旋转是的轴点，如果想改变view的旋转轴点，改变anchorPoint即可\n\n### 坐标系\n\n* 与UIView一样，CALayer也提供了一套坐标变换的借口\n\n```objectivec\n- (CGPoint)convertPoint:(CGPoint)p fromLayer:(nullable CALayer *)l;\n- (CGPoint)convertPoint:(CGPoint)p toLayer:(nullable CALayer *)l;\n- (CGRect)convertRect:(CGRect)r fromLayer:(nullable CALayer *)l;\n- (CGRect)convertRect:(CGRect)r toLayer:(nullable CALayer *)l;\n```\n\n### 翻转的几何结构\n\n* ios上坐标系原点为左上角，macOS上坐标系原点为左下角。\n* CALayer的`geometryFlipped`属性决定了图层的坐标是否相对于父图层翻转。\n\n### z坐标轴\n\n* zPosition：表示图层空间z轴上的位置\n* zPosition除了可以改变z轴的位置，还可以用来改变图层的先后顺序，如图，如果设置了绿色view的zPosition，绿色View就可以覆盖在蓝色view之上。但是通过这种方法改变视图的层次，是不能改变视图的响应事件的顺序的。\n\n![zPositon](http://7xn88v.com1.z0.glb.clouddn.com/d673bc31fdbe28367ad557ac739a60fd.png)\n\n* anchorPointZ表示z轴上锚点的位置\n\n### Hit Testing\n\n* CALayer不能处理点击事件，但是他有一系列方法帮你处理事件。\n* `- (BOOL)containsPoint:(CGPoint)p;`用于判断一个点是否属于一个图层\n* `- (nullable CALayer *)hitTest:(CGPoint)p;`返回被点击的图层\n\n```objectivec\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {\n    UITouch *touch = [touches anyObject];\n    CGPoint point = [touch locationInView:self.view];\n\n    point = [self.layerView convertPoint:point fromView:self.view];\n    BOOL ret = [self.layerView.layer containsPoint:point];\n    if (ret) {\n        NSLog(@\"green\");\n    }\n\n    point = [self.buleView convertPoint:point fromView:self.layerView];\n    ret = [self.buleView.layer containsPoint:point];\n    if (ret) {\n        NSLog(@\"blue\");\n    }\n\n    CALayer *layer = [self.view.layer hitTest:point];\n    if (layer == self.layerView.layer) {\n        NSLog(@\"green\");\n    }\n    else if(layer == self.buleView.layer) {\n        NSLog(@\"blue\");\n    }\n\n}\n```\n","slug":"《ios核心动画高级技巧》阅读笔记(2)","published":1,"date":"2015-12-26T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oaba001czrm0kr7i1xyx","content":"<h2 id=\"第三章-图层集合学\"><a href=\"#第三章-图层集合学\" class=\"headerlink\" title=\"第三章 图层集合学\"></a>第三章 图层集合学</h2><h3 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h3><ul>\n<li>frame：图层的相对于父图层的外部坐标</li>\n<li>bounds：内部坐标</li>\n<li>center和position：相对于父图层anchorPoint所在的位置</li>\n<li>设置视图的frame，bounds和center，也就是相当于设置图层的frame，bounds和position</li>\n<li>一般情况下，frame中的size与bounds中的size是相同的，但是当视图旋转时，frame的size和bounds的size就不一样了，如下图</li>\n</ul>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/a592d9f689fe8a2818583430f5a8211d.png\" alt=\"frame&amp;bounds&amp;center\"></p>\n<h3 id=\"锚点\"><a href=\"#锚点\" class=\"headerlink\" title=\"锚点\"></a>锚点</h3><ul>\n<li>锚点是相对于父图层anchorPoint所在的位置。</li>\n<li>默认，锚点位于图层的中点，可以改变锚点的位置，描点改变，frame也会随之改变。</li>\n</ul>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/99c7a6ddc1d2b162816b2a9ef5ff568f.png\" alt=\"anchorPoint\"></p>\n<ul>\n<li>改变锚点，position不会改变，但是frame改变了。</li>\n<li>anchorPoint是View在旋转是的轴点，如果想改变view的旋转轴点，改变anchorPoint即可</li>\n</ul>\n<h3 id=\"坐标系\"><a href=\"#坐标系\" class=\"headerlink\" title=\"坐标系\"></a>坐标系</h3><ul>\n<li>与UIView一样，CALayer也提供了一套坐标变换的借口</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)convertPoint:(<span class=\"built_in\">CGPoint</span>)p fromLayer:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">CALayer</span> *)l;</div><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)convertPoint:(<span class=\"built_in\">CGPoint</span>)p toLayer:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">CALayer</span> *)l;</div><div class=\"line\">- (<span class=\"built_in\">CGRect</span>)convertRect:(<span class=\"built_in\">CGRect</span>)r fromLayer:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">CALayer</span> *)l;</div><div class=\"line\">- (<span class=\"built_in\">CGRect</span>)convertRect:(<span class=\"built_in\">CGRect</span>)r toLayer:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">CALayer</span> *)l;</div></pre></td></tr></table></figure>\n<h3 id=\"翻转的几何结构\"><a href=\"#翻转的几何结构\" class=\"headerlink\" title=\"翻转的几何结构\"></a>翻转的几何结构</h3><ul>\n<li>ios上坐标系原点为左上角，macOS上坐标系原点为左下角。</li>\n<li>CALayer的<code>geometryFlipped</code>属性决定了图层的坐标是否相对于父图层翻转。</li>\n</ul>\n<h3 id=\"z坐标轴\"><a href=\"#z坐标轴\" class=\"headerlink\" title=\"z坐标轴\"></a>z坐标轴</h3><ul>\n<li>zPosition：表示图层空间z轴上的位置</li>\n<li>zPosition除了可以改变z轴的位置，还可以用来改变图层的先后顺序，如图，如果设置了绿色view的zPosition，绿色View就可以覆盖在蓝色view之上。但是通过这种方法改变视图的层次，是不能改变视图的响应事件的顺序的。</li>\n</ul>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/d673bc31fdbe28367ad557ac739a60fd.png\" alt=\"zPositon\"></p>\n<ul>\n<li>anchorPointZ表示z轴上锚点的位置</li>\n</ul>\n<h3 id=\"Hit-Testing\"><a href=\"#Hit-Testing\" class=\"headerlink\" title=\"Hit Testing\"></a>Hit Testing</h3><ul>\n<li>CALayer不能处理点击事件，但是他有一系列方法帮你处理事件。</li>\n<li><code>- (BOOL)containsPoint:(CGPoint)p;</code>用于判断一个点是否属于一个图层</li>\n<li><code>- (nullable CALayer *)hitTest:(CGPoint)p;</code>返回被点击的图层</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">UITouch</span> *&gt; *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event &#123;</div><div class=\"line\">    <span class=\"built_in\">UITouch</span> *touch = [touches anyObject];</div><div class=\"line\">    <span class=\"built_in\">CGPoint</span> point = [touch locationInView:<span class=\"keyword\">self</span>.view];</div><div class=\"line\"></div><div class=\"line\">    point = [<span class=\"keyword\">self</span>.layerView convertPoint:point fromView:<span class=\"keyword\">self</span>.view];</div><div class=\"line\">    <span class=\"built_in\">BOOL</span> ret = [<span class=\"keyword\">self</span>.layerView.layer containsPoint:point];</div><div class=\"line\">    <span class=\"keyword\">if</span> (ret) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"green\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    point = [<span class=\"keyword\">self</span>.buleView convertPoint:point fromView:<span class=\"keyword\">self</span>.layerView];</div><div class=\"line\">    ret = [<span class=\"keyword\">self</span>.buleView.layer containsPoint:point];</div><div class=\"line\">    <span class=\"keyword\">if</span> (ret) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"blue\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">CALayer</span> *layer = [<span class=\"keyword\">self</span>.view.layer hitTest:point];</div><div class=\"line\">    <span class=\"keyword\">if</span> (layer == <span class=\"keyword\">self</span>.layerView.layer) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"green\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(layer == <span class=\"keyword\">self</span>.buleView.layer) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"blue\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"第三章-图层集合学\"><a href=\"#第三章-图层集合学\" class=\"headerlink\" title=\"第三章 图层集合学\"></a>第三章 图层集合学</h2><h3 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h3><ul>\n<li>frame：图层的相对于父图层的外部坐标</li>\n<li>bounds：内部坐标</li>\n<li>center和position：相对于父图层anchorPoint所在的位置</li>\n<li>设置视图的frame，bounds和center，也就是相当于设置图层的frame，bounds和position</li>\n<li>一般情况下，frame中的size与bounds中的size是相同的，但是当视图旋转时，frame的size和bounds的size就不一样了，如下图</li>\n</ul>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/a592d9f689fe8a2818583430f5a8211d.png\" alt=\"frame&amp;bounds&amp;center\"></p>\n<h3 id=\"锚点\"><a href=\"#锚点\" class=\"headerlink\" title=\"锚点\"></a>锚点</h3><ul>\n<li>锚点是相对于父图层anchorPoint所在的位置。</li>\n<li>默认，锚点位于图层的中点，可以改变锚点的位置，描点改变，frame也会随之改变。</li>\n</ul>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/99c7a6ddc1d2b162816b2a9ef5ff568f.png\" alt=\"anchorPoint\"></p>\n<ul>\n<li>改变锚点，position不会改变，但是frame改变了。</li>\n<li>anchorPoint是View在旋转是的轴点，如果想改变view的旋转轴点，改变anchorPoint即可</li>\n</ul>\n<h3 id=\"坐标系\"><a href=\"#坐标系\" class=\"headerlink\" title=\"坐标系\"></a>坐标系</h3><ul>\n<li>与UIView一样，CALayer也提供了一套坐标变换的借口</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)convertPoint:(<span class=\"built_in\">CGPoint</span>)p fromLayer:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">CALayer</span> *)l;</div><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)convertPoint:(<span class=\"built_in\">CGPoint</span>)p toLayer:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">CALayer</span> *)l;</div><div class=\"line\">- (<span class=\"built_in\">CGRect</span>)convertRect:(<span class=\"built_in\">CGRect</span>)r fromLayer:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">CALayer</span> *)l;</div><div class=\"line\">- (<span class=\"built_in\">CGRect</span>)convertRect:(<span class=\"built_in\">CGRect</span>)r toLayer:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">CALayer</span> *)l;</div></pre></td></tr></table></figure>\n<h3 id=\"翻转的几何结构\"><a href=\"#翻转的几何结构\" class=\"headerlink\" title=\"翻转的几何结构\"></a>翻转的几何结构</h3><ul>\n<li>ios上坐标系原点为左上角，macOS上坐标系原点为左下角。</li>\n<li>CALayer的<code>geometryFlipped</code>属性决定了图层的坐标是否相对于父图层翻转。</li>\n</ul>\n<h3 id=\"z坐标轴\"><a href=\"#z坐标轴\" class=\"headerlink\" title=\"z坐标轴\"></a>z坐标轴</h3><ul>\n<li>zPosition：表示图层空间z轴上的位置</li>\n<li>zPosition除了可以改变z轴的位置，还可以用来改变图层的先后顺序，如图，如果设置了绿色view的zPosition，绿色View就可以覆盖在蓝色view之上。但是通过这种方法改变视图的层次，是不能改变视图的响应事件的顺序的。</li>\n</ul>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/d673bc31fdbe28367ad557ac739a60fd.png\" alt=\"zPositon\"></p>\n<ul>\n<li>anchorPointZ表示z轴上锚点的位置</li>\n</ul>\n<h3 id=\"Hit-Testing\"><a href=\"#Hit-Testing\" class=\"headerlink\" title=\"Hit Testing\"></a>Hit Testing</h3><ul>\n<li>CALayer不能处理点击事件，但是他有一系列方法帮你处理事件。</li>\n<li><code>- (BOOL)containsPoint:(CGPoint)p;</code>用于判断一个点是否属于一个图层</li>\n<li><code>- (nullable CALayer *)hitTest:(CGPoint)p;</code>返回被点击的图层</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">UITouch</span> *&gt; *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event &#123;</div><div class=\"line\">    <span class=\"built_in\">UITouch</span> *touch = [touches anyObject];</div><div class=\"line\">    <span class=\"built_in\">CGPoint</span> point = [touch locationInView:<span class=\"keyword\">self</span>.view];</div><div class=\"line\"></div><div class=\"line\">    point = [<span class=\"keyword\">self</span>.layerView convertPoint:point fromView:<span class=\"keyword\">self</span>.view];</div><div class=\"line\">    <span class=\"built_in\">BOOL</span> ret = [<span class=\"keyword\">self</span>.layerView.layer containsPoint:point];</div><div class=\"line\">    <span class=\"keyword\">if</span> (ret) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"green\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    point = [<span class=\"keyword\">self</span>.buleView convertPoint:point fromView:<span class=\"keyword\">self</span>.layerView];</div><div class=\"line\">    ret = [<span class=\"keyword\">self</span>.buleView.layer containsPoint:point];</div><div class=\"line\">    <span class=\"keyword\">if</span> (ret) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"blue\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">CALayer</span> *layer = [<span class=\"keyword\">self</span>.view.layer hitTest:point];</div><div class=\"line\">    <span class=\"keyword\">if</span> (layer == <span class=\"keyword\">self</span>.layerView.layer) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"green\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(layer == <span class=\"keyword\">self</span>.buleView.layer) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"blue\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"layout":"post","title":"自动打包工具shenzhen使用简介","_content":"\nDailyBuild几乎是每一个iOS开发每天都必做的事情，尤其是到了项目测试阶段，每天都要打好几个安装包给测试同学去测试，如果使用以前的老方法，就得先手动Clean，然后Archive，然后创建响应的目录，把安装包和dSYM文件都拷进去，然后再上传到FTP，所有的这些操作，手动做下来至少得七八分钟，每天如果打三个包，那么将近半个小时就浪费在了打包上。\n\n为了节约打包话费的时间，出现了很多自动打包的工具，比较著名的有facebook的[xctool](https://github.com/facebook/xctool)以及Mattt Thompson大神的[shenzhen](https://github.com/nomad/shenzhen)（深圳，名字也很有意思，😄），本文主要介绍一下[shenzhen](https://github.com/nomad/shenzhen)的用法。\n\n[shenzhen](https://github.com/nomad/shenzhen)最大的特点就是它除了能个打包外，还可以发布，可以发布到[iTunes Connect](https://itunesconnect.apple.com)，也可以发布到[FIR.im](http://fir.im/)，[蒲公英](http://www.pgyer.com/)等第三方应用托管平台。让我们可以一键时间打包发布。\n\n## 安装\n\n使用gem安装\n\n```\n$ sudo gem install shenzhen\n```\n\n## 使用\n\n### 打包\n\n```\nipa build -w lazyaudio.xcworkspace --clean -d /Users/liujinlong/Desktop/App -s MyApp --ipa AppName.ipa -c Debug --verbose\n```\n\n说明：\n\n* -w 表示编译的workspace，如果没有创建workspace，可以使用-p来指定项目名\n* --clean 表示在编译前进行clean操作\n* -d 指定的是打包后生成的*.ipa和*.dSYM文件存放的目录，可以是不存在的目录，如果目录不存在，会自动创建\n* -s 指定scheme，如果存在多个scheme，需要明确指定的，如果不指定，在执行时会出现选项，进行选择\n* -ipa 指定生成的ipa的名称，注意要添加.ipa\n* -c 指定configuration，这里可以指定是以Debug还是以Release方法进行编译，注意第一个字母要大写，否则会出错\n* --verbose打印，更多log\n* 如果项目使用了CocoaPods，应该使用-w指定workspace进行编译，并且要明确指定编译哪个scheme\n\n### 发布\n\n发布的命令的很多，具体可以参考github的[README](https://github.com/nomad/shenzhen/blob/master/README.md)，这里只介绍上传到FTP一种\n\n```\nipa distribute:ftp --host 127.0.0.1 -port 8080 -f /Users/liujinlong/Desktop/App/AppName.ipa -u username -p 123456 --path /iOSApp/v1.1.2/20160101 --mkdir\n```\n\n说明：\n\n* --host 指定FTP服务器主机\n* --port 指定FTP服务器端口\n* -f 指定要上传的ipa文件的路径\n* -u 指定FTP服务器用户名\n* -p 指定FTP服务器密码\n* --path 指定FTP服务器路径\n* --mkdir 如果指定的FTP服务器路径不存在，则创建路径\n\n有了[shenzhen](https://github.com/nomad/shenzhen)这个工具，我们的打包工作就变得异常轻松，下面是我使用[shenzhen](https://github.com/nomad/shenzhen)写的一个shell脚本，可以一个命令完成打包并上传到FTP。\n\nGithub: [BuildIPAScript](https://github.com/liujinlongxa/BuildIPAScript)\n","source":"_posts/2016-01-01-自动打包工具shenzhen使用简介.md","raw":"---\nlayout: post\ntitle: \"自动打包工具shenzhen使用简介\"\ncategories: \"iOS开发\"\n---\n\nDailyBuild几乎是每一个iOS开发每天都必做的事情，尤其是到了项目测试阶段，每天都要打好几个安装包给测试同学去测试，如果使用以前的老方法，就得先手动Clean，然后Archive，然后创建响应的目录，把安装包和dSYM文件都拷进去，然后再上传到FTP，所有的这些操作，手动做下来至少得七八分钟，每天如果打三个包，那么将近半个小时就浪费在了打包上。\n\n为了节约打包话费的时间，出现了很多自动打包的工具，比较著名的有facebook的[xctool](https://github.com/facebook/xctool)以及Mattt Thompson大神的[shenzhen](https://github.com/nomad/shenzhen)（深圳，名字也很有意思，😄），本文主要介绍一下[shenzhen](https://github.com/nomad/shenzhen)的用法。\n\n[shenzhen](https://github.com/nomad/shenzhen)最大的特点就是它除了能个打包外，还可以发布，可以发布到[iTunes Connect](https://itunesconnect.apple.com)，也可以发布到[FIR.im](http://fir.im/)，[蒲公英](http://www.pgyer.com/)等第三方应用托管平台。让我们可以一键时间打包发布。\n\n## 安装\n\n使用gem安装\n\n```\n$ sudo gem install shenzhen\n```\n\n## 使用\n\n### 打包\n\n```\nipa build -w lazyaudio.xcworkspace --clean -d /Users/liujinlong/Desktop/App -s MyApp --ipa AppName.ipa -c Debug --verbose\n```\n\n说明：\n\n* -w 表示编译的workspace，如果没有创建workspace，可以使用-p来指定项目名\n* --clean 表示在编译前进行clean操作\n* -d 指定的是打包后生成的*.ipa和*.dSYM文件存放的目录，可以是不存在的目录，如果目录不存在，会自动创建\n* -s 指定scheme，如果存在多个scheme，需要明确指定的，如果不指定，在执行时会出现选项，进行选择\n* -ipa 指定生成的ipa的名称，注意要添加.ipa\n* -c 指定configuration，这里可以指定是以Debug还是以Release方法进行编译，注意第一个字母要大写，否则会出错\n* --verbose打印，更多log\n* 如果项目使用了CocoaPods，应该使用-w指定workspace进行编译，并且要明确指定编译哪个scheme\n\n### 发布\n\n发布的命令的很多，具体可以参考github的[README](https://github.com/nomad/shenzhen/blob/master/README.md)，这里只介绍上传到FTP一种\n\n```\nipa distribute:ftp --host 127.0.0.1 -port 8080 -f /Users/liujinlong/Desktop/App/AppName.ipa -u username -p 123456 --path /iOSApp/v1.1.2/20160101 --mkdir\n```\n\n说明：\n\n* --host 指定FTP服务器主机\n* --port 指定FTP服务器端口\n* -f 指定要上传的ipa文件的路径\n* -u 指定FTP服务器用户名\n* -p 指定FTP服务器密码\n* --path 指定FTP服务器路径\n* --mkdir 如果指定的FTP服务器路径不存在，则创建路径\n\n有了[shenzhen](https://github.com/nomad/shenzhen)这个工具，我们的打包工作就变得异常轻松，下面是我使用[shenzhen](https://github.com/nomad/shenzhen)写的一个shell脚本，可以一个命令完成打包并上传到FTP。\n\nGithub: [BuildIPAScript](https://github.com/liujinlongxa/BuildIPAScript)\n","slug":"自动打包工具shenzhen使用简介","published":1,"date":"2015-12-31T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oabc001ezrm06kmh07a9","content":"<p>DailyBuild几乎是每一个iOS开发每天都必做的事情，尤其是到了项目测试阶段，每天都要打好几个安装包给测试同学去测试，如果使用以前的老方法，就得先手动Clean，然后Archive，然后创建响应的目录，把安装包和dSYM文件都拷进去，然后再上传到FTP，所有的这些操作，手动做下来至少得七八分钟，每天如果打三个包，那么将近半个小时就浪费在了打包上。</p>\n<p>为了节约打包话费的时间，出现了很多自动打包的工具，比较著名的有facebook的<a href=\"https://github.com/facebook/xctool\" target=\"_blank\" rel=\"external\">xctool</a>以及Mattt Thompson大神的<a href=\"https://github.com/nomad/shenzhen\" target=\"_blank\" rel=\"external\">shenzhen</a>（深圳，名字也很有意思，😄），本文主要介绍一下<a href=\"https://github.com/nomad/shenzhen\" target=\"_blank\" rel=\"external\">shenzhen</a>的用法。</p>\n<p><a href=\"https://github.com/nomad/shenzhen\" target=\"_blank\" rel=\"external\">shenzhen</a>最大的特点就是它除了能个打包外，还可以发布，可以发布到<a href=\"https://itunesconnect.apple.com\" target=\"_blank\" rel=\"external\">iTunes Connect</a>，也可以发布到<a href=\"http://fir.im/\" target=\"_blank\" rel=\"external\">FIR.im</a>，<a href=\"http://www.pgyer.com/\" target=\"_blank\" rel=\"external\">蒲公英</a>等第三方应用托管平台。让我们可以一键时间打包发布。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>使用gem安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo gem install shenzhen</div></pre></td></tr></table></figure>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ipa build -w lazyaudio.xcworkspace --clean -d /Users/liujinlong/Desktop/App -s MyApp --ipa AppName.ipa -c Debug --verbose</div></pre></td></tr></table></figure>\n<p>说明：</p>\n<ul>\n<li>-w 表示编译的workspace，如果没有创建workspace，可以使用-p来指定项目名</li>\n<li>–clean 表示在编译前进行clean操作</li>\n<li>-d 指定的是打包后生成的<em>.ipa和</em>.dSYM文件存放的目录，可以是不存在的目录，如果目录不存在，会自动创建</li>\n<li>-s 指定scheme，如果存在多个scheme，需要明确指定的，如果不指定，在执行时会出现选项，进行选择</li>\n<li>-ipa 指定生成的ipa的名称，注意要添加.ipa</li>\n<li>-c 指定configuration，这里可以指定是以Debug还是以Release方法进行编译，注意第一个字母要大写，否则会出错</li>\n<li>–verbose打印，更多log</li>\n<li>如果项目使用了CocoaPods，应该使用-w指定workspace进行编译，并且要明确指定编译哪个scheme</li>\n</ul>\n<h3 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h3><p>发布的命令的很多，具体可以参考github的<a href=\"https://github.com/nomad/shenzhen/blob/master/README.md\" target=\"_blank\" rel=\"external\">README</a>，这里只介绍上传到FTP一种</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ipa distribute:ftp --host 127.0.0.1 -port 8080 -f /Users/liujinlong/Desktop/App/AppName.ipa -u username -p 123456 --path /iOSApp/v1.1.2/20160101 --mkdir</div></pre></td></tr></table></figure>\n<p>说明：</p>\n<ul>\n<li>–host 指定FTP服务器主机</li>\n<li>–port 指定FTP服务器端口</li>\n<li>-f 指定要上传的ipa文件的路径</li>\n<li>-u 指定FTP服务器用户名</li>\n<li>-p 指定FTP服务器密码</li>\n<li>–path 指定FTP服务器路径</li>\n<li>–mkdir 如果指定的FTP服务器路径不存在，则创建路径</li>\n</ul>\n<p>有了<a href=\"https://github.com/nomad/shenzhen\" target=\"_blank\" rel=\"external\">shenzhen</a>这个工具，我们的打包工作就变得异常轻松，下面是我使用<a href=\"https://github.com/nomad/shenzhen\" target=\"_blank\" rel=\"external\">shenzhen</a>写的一个shell脚本，可以一个命令完成打包并上传到FTP。</p>\n<p>Github: <a href=\"https://github.com/liujinlongxa/BuildIPAScript\" target=\"_blank\" rel=\"external\">BuildIPAScript</a></p>\n","excerpt":"","more":"<p>DailyBuild几乎是每一个iOS开发每天都必做的事情，尤其是到了项目测试阶段，每天都要打好几个安装包给测试同学去测试，如果使用以前的老方法，就得先手动Clean，然后Archive，然后创建响应的目录，把安装包和dSYM文件都拷进去，然后再上传到FTP，所有的这些操作，手动做下来至少得七八分钟，每天如果打三个包，那么将近半个小时就浪费在了打包上。</p>\n<p>为了节约打包话费的时间，出现了很多自动打包的工具，比较著名的有facebook的<a href=\"https://github.com/facebook/xctool\">xctool</a>以及Mattt Thompson大神的<a href=\"https://github.com/nomad/shenzhen\">shenzhen</a>（深圳，名字也很有意思，😄），本文主要介绍一下<a href=\"https://github.com/nomad/shenzhen\">shenzhen</a>的用法。</p>\n<p><a href=\"https://github.com/nomad/shenzhen\">shenzhen</a>最大的特点就是它除了能个打包外，还可以发布，可以发布到<a href=\"https://itunesconnect.apple.com\">iTunes Connect</a>，也可以发布到<a href=\"http://fir.im/\">FIR.im</a>，<a href=\"http://www.pgyer.com/\">蒲公英</a>等第三方应用托管平台。让我们可以一键时间打包发布。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>使用gem安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo gem install shenzhen</div></pre></td></tr></table></figure>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ipa build -w lazyaudio.xcworkspace --clean -d /Users/liujinlong/Desktop/App -s MyApp --ipa AppName.ipa -c Debug --verbose</div></pre></td></tr></table></figure>\n<p>说明：</p>\n<ul>\n<li>-w 表示编译的workspace，如果没有创建workspace，可以使用-p来指定项目名</li>\n<li>–clean 表示在编译前进行clean操作</li>\n<li>-d 指定的是打包后生成的<em>.ipa和</em>.dSYM文件存放的目录，可以是不存在的目录，如果目录不存在，会自动创建</li>\n<li>-s 指定scheme，如果存在多个scheme，需要明确指定的，如果不指定，在执行时会出现选项，进行选择</li>\n<li>-ipa 指定生成的ipa的名称，注意要添加.ipa</li>\n<li>-c 指定configuration，这里可以指定是以Debug还是以Release方法进行编译，注意第一个字母要大写，否则会出错</li>\n<li>–verbose打印，更多log</li>\n<li>如果项目使用了CocoaPods，应该使用-w指定workspace进行编译，并且要明确指定编译哪个scheme</li>\n</ul>\n<h3 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h3><p>发布的命令的很多，具体可以参考github的<a href=\"https://github.com/nomad/shenzhen/blob/master/README.md\">README</a>，这里只介绍上传到FTP一种</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ipa distribute:ftp --host 127.0.0.1 -port 8080 -f /Users/liujinlong/Desktop/App/AppName.ipa -u username -p 123456 --path /iOSApp/v1.1.2/20160101 --mkdir</div></pre></td></tr></table></figure>\n<p>说明：</p>\n<ul>\n<li>–host 指定FTP服务器主机</li>\n<li>–port 指定FTP服务器端口</li>\n<li>-f 指定要上传的ipa文件的路径</li>\n<li>-u 指定FTP服务器用户名</li>\n<li>-p 指定FTP服务器密码</li>\n<li>–path 指定FTP服务器路径</li>\n<li>–mkdir 如果指定的FTP服务器路径不存在，则创建路径</li>\n</ul>\n<p>有了<a href=\"https://github.com/nomad/shenzhen\">shenzhen</a>这个工具，我们的打包工作就变得异常轻松，下面是我使用<a href=\"https://github.com/nomad/shenzhen\">shenzhen</a>写的一个shell脚本，可以一个命令完成打包并上传到FTP。</p>\n<p>Github: <a href=\"https://github.com/liujinlongxa/BuildIPAScript\">BuildIPAScript</a></p>\n"},{"layout":"post","title":"iOS开发企业证书申请过程全记录","_content":"\n最近帮公司申请了企业开发者证书，中间也遇到了不少坑，下面是整个过程的一个完整记录，包括申请邓白氏编码的过程，希望对大家有所帮助。\n\n### 申请邓白氏编码\n\n1. 注册企业开发者账号之前，要先申请[邓白氏编码](http://baike.baidu.com/link?url=dzCD0bvR7RV_I_3KBXQtse65aaKmEO8_ghvPq7M9Y3V6-H-omCBMvpOMNImYwvKYdBBdhkvaD2oTmgiTYd9FHq)，申请地址p[https://developer.apple.com/support/D-U-N-S/](https://developer.apple.com/support/D-U-N-S/)，首先填写公司信息，然后提交申请\n![1.1.1](http://7xn88v.com1.z0.glb.clouddn.com/b1ee643bd69fb351c1048b0f4c620ca2.png)\n![1.1.2](http://7xn88v.com1.z0.glb.clouddn.com/7bd0b2899cdc677a901febad7306fba2.png)\n2. 过一会会收到一封邮件，大概内容就是正在申请邓氏码，大概什么时候完成，还有一个requestID\n![1.2.1](http://7xn88v.com1.z0.glb.clouddn.com/5a8e972d91eb408774c787acf066c713.png)\n3. 又过了两天，接到了上海一家公司的电话，他跟我确认了一下邮箱，接着他会给你这个邮箱发一封邮件，要求你提供以下公司信息\n![1.3.1](http://7xn88v.com1.z0.glb.clouddn.com/810e19e549cbac41c918fdd9f794c025.png)\n4. 回复这封邮件，过一会又会收到一封邮件，内容如下\n![1.4.1](http://7xn88v.com1.z0.glb.clouddn.com/f1de6028777c7874a1593ec0119da0a6.png)\n5. 有过了不到一天的时间，就收到了申请的邓氏码，虽然他邮件上要求14个工作日再去使用邓氏码，但是根据我的尝试，我只等了不到两天就可以使用了。\n\n### 注册企业开发者账号\n\n1. 注册一个AppleID，这个就不用说了，这里要注意的一点是，你在注册AppleID时必须使用你真实姓名的拼音去注册，否则苹果会给你发邮件让你改成真实姓名，我就遇到了这一点。\n![2.1.1](http://7xn88v.com1.z0.glb.clouddn.com/66506633bad28c995b24039688dda30e.png)\n2. 用你注册的AppleID登录苹果开发者中心，在最底部点击Enterprise Program，注意不是Developer Program。\n![2.2.1](http://7xn88v.com1.z0.glb.clouddn.com/939056f54db775460ceb68e2506e0003.png)\n![2.2.2](http://7xn88v.com1.z0.glb.clouddn.com/2281829dbb65193c65e248e581e595b3.png)\n![2.2.3](http://7xn88v.com1.z0.glb.clouddn.com/0aa47a0de740fdcd44c8197dafd43006.png)\n3. Entity Type选择“Company/Organization”，然后点击继续\n![2.3.1](http://7xn88v.com1.z0.glb.clouddn.com/81c91b2b12845c24d0376ac599769625.png)\n4. 填写资料，然后点击继续\n![2.4.1](http://7xn88v.com1.z0.glb.clouddn.com/f04ef93f3b1298058add7700888fbb97.png)\n5. 确认信息，这里要注意一点，苹果显示的地址有字数限制，所以如果你的公司地址很长，这里可能会显示不全，这是正常的。确认完成后，点击提交。\n![2.4.1](http://7xn88v.com1.z0.glb.clouddn.com/2bad2013936e0dfe82b8e0b5bbc1a7ec.png)\n6. 过一会会收到一封邮件，提示你的申请已经被接受\n7. 又过了两天，苹果会打电话来确认一些信息，然后就可以接着走下面的流程了，进入开发者中心，点击Review Now\n![2.7.1](http://7xn88v.com1.z0.glb.clouddn.com/dade54e4af9cc6126cb099e6656bf59f.png)\n8. 点击继续，然后就到了付款的阶段\n![2.8.1](http://7xn88v.com1.z0.glb.clouddn.com/249c8652294855c003063ab3cb1d04df.png)\n9. 点击Purchase，然后要重新登录一次AppleID，然后就是填写付款信息，这里要注意的是使用的信用卡一定是要同时具有银联标志和VISA标志的卡，我尝试过，使用仅支持银联或者VISA的信用卡是不能支付成功的。\n10. 支付完成后，这个企业开发者证书就申请完了，登录开发者中心，显示的开发者类型就是企业开发者（in-house)\n![2.10.1](http://7xn88v.com1.z0.glb.clouddn.com/6c79710a8bb20bf59439b3de749e1839.png)\n\n以上就算是我申请苹果企业开发者证书的全过程，希望对大家有所帮助\n","source":"_posts/2016-04-10-iOS开发企业证书申请过程全记录.md","raw":"---\nlayout: post\ntitle: \"iOS开发企业证书申请过程全记录\"\ncategories: \"iOS开发\"\n---\n\n最近帮公司申请了企业开发者证书，中间也遇到了不少坑，下面是整个过程的一个完整记录，包括申请邓白氏编码的过程，希望对大家有所帮助。\n\n### 申请邓白氏编码\n\n1. 注册企业开发者账号之前，要先申请[邓白氏编码](http://baike.baidu.com/link?url=dzCD0bvR7RV_I_3KBXQtse65aaKmEO8_ghvPq7M9Y3V6-H-omCBMvpOMNImYwvKYdBBdhkvaD2oTmgiTYd9FHq)，申请地址p[https://developer.apple.com/support/D-U-N-S/](https://developer.apple.com/support/D-U-N-S/)，首先填写公司信息，然后提交申请\n![1.1.1](http://7xn88v.com1.z0.glb.clouddn.com/b1ee643bd69fb351c1048b0f4c620ca2.png)\n![1.1.2](http://7xn88v.com1.z0.glb.clouddn.com/7bd0b2899cdc677a901febad7306fba2.png)\n2. 过一会会收到一封邮件，大概内容就是正在申请邓氏码，大概什么时候完成，还有一个requestID\n![1.2.1](http://7xn88v.com1.z0.glb.clouddn.com/5a8e972d91eb408774c787acf066c713.png)\n3. 又过了两天，接到了上海一家公司的电话，他跟我确认了一下邮箱，接着他会给你这个邮箱发一封邮件，要求你提供以下公司信息\n![1.3.1](http://7xn88v.com1.z0.glb.clouddn.com/810e19e549cbac41c918fdd9f794c025.png)\n4. 回复这封邮件，过一会又会收到一封邮件，内容如下\n![1.4.1](http://7xn88v.com1.z0.glb.clouddn.com/f1de6028777c7874a1593ec0119da0a6.png)\n5. 有过了不到一天的时间，就收到了申请的邓氏码，虽然他邮件上要求14个工作日再去使用邓氏码，但是根据我的尝试，我只等了不到两天就可以使用了。\n\n### 注册企业开发者账号\n\n1. 注册一个AppleID，这个就不用说了，这里要注意的一点是，你在注册AppleID时必须使用你真实姓名的拼音去注册，否则苹果会给你发邮件让你改成真实姓名，我就遇到了这一点。\n![2.1.1](http://7xn88v.com1.z0.glb.clouddn.com/66506633bad28c995b24039688dda30e.png)\n2. 用你注册的AppleID登录苹果开发者中心，在最底部点击Enterprise Program，注意不是Developer Program。\n![2.2.1](http://7xn88v.com1.z0.glb.clouddn.com/939056f54db775460ceb68e2506e0003.png)\n![2.2.2](http://7xn88v.com1.z0.glb.clouddn.com/2281829dbb65193c65e248e581e595b3.png)\n![2.2.3](http://7xn88v.com1.z0.glb.clouddn.com/0aa47a0de740fdcd44c8197dafd43006.png)\n3. Entity Type选择“Company/Organization”，然后点击继续\n![2.3.1](http://7xn88v.com1.z0.glb.clouddn.com/81c91b2b12845c24d0376ac599769625.png)\n4. 填写资料，然后点击继续\n![2.4.1](http://7xn88v.com1.z0.glb.clouddn.com/f04ef93f3b1298058add7700888fbb97.png)\n5. 确认信息，这里要注意一点，苹果显示的地址有字数限制，所以如果你的公司地址很长，这里可能会显示不全，这是正常的。确认完成后，点击提交。\n![2.4.1](http://7xn88v.com1.z0.glb.clouddn.com/2bad2013936e0dfe82b8e0b5bbc1a7ec.png)\n6. 过一会会收到一封邮件，提示你的申请已经被接受\n7. 又过了两天，苹果会打电话来确认一些信息，然后就可以接着走下面的流程了，进入开发者中心，点击Review Now\n![2.7.1](http://7xn88v.com1.z0.glb.clouddn.com/dade54e4af9cc6126cb099e6656bf59f.png)\n8. 点击继续，然后就到了付款的阶段\n![2.8.1](http://7xn88v.com1.z0.glb.clouddn.com/249c8652294855c003063ab3cb1d04df.png)\n9. 点击Purchase，然后要重新登录一次AppleID，然后就是填写付款信息，这里要注意的是使用的信用卡一定是要同时具有银联标志和VISA标志的卡，我尝试过，使用仅支持银联或者VISA的信用卡是不能支付成功的。\n10. 支付完成后，这个企业开发者证书就申请完了，登录开发者中心，显示的开发者类型就是企业开发者（in-house)\n![2.10.1](http://7xn88v.com1.z0.glb.clouddn.com/6c79710a8bb20bf59439b3de749e1839.png)\n\n以上就算是我申请苹果企业开发者证书的全过程，希望对大家有所帮助\n","slug":"iOS开发企业证书申请过程全记录","published":1,"date":"2016-04-09T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oabe001gzrm0fbnje7xv","content":"<p>最近帮公司申请了企业开发者证书，中间也遇到了不少坑，下面是整个过程的一个完整记录，包括申请邓白氏编码的过程，希望对大家有所帮助。</p>\n<h3 id=\"申请邓白氏编码\"><a href=\"#申请邓白氏编码\" class=\"headerlink\" title=\"申请邓白氏编码\"></a>申请邓白氏编码</h3><ol>\n<li>注册企业开发者账号之前，要先申请<a href=\"http://baike.baidu.com/link?url=dzCD0bvR7RV_I_3KBXQtse65aaKmEO8_ghvPq7M9Y3V6-H-omCBMvpOMNImYwvKYdBBdhkvaD2oTmgiTYd9FHq\" target=\"_blank\" rel=\"external\">邓白氏编码</a>，申请地址p<a href=\"https://developer.apple.com/support/D-U-N-S/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/support/D-U-N-S/</a>，首先填写公司信息，然后提交申请<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/b1ee643bd69fb351c1048b0f4c620ca2.png\" alt=\"1.1.1\"><br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/7bd0b2899cdc677a901febad7306fba2.png\" alt=\"1.1.2\"></li>\n<li>过一会会收到一封邮件，大概内容就是正在申请邓氏码，大概什么时候完成，还有一个requestID<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/5a8e972d91eb408774c787acf066c713.png\" alt=\"1.2.1\"></li>\n<li>又过了两天，接到了上海一家公司的电话，他跟我确认了一下邮箱，接着他会给你这个邮箱发一封邮件，要求你提供以下公司信息<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/810e19e549cbac41c918fdd9f794c025.png\" alt=\"1.3.1\"></li>\n<li>回复这封邮件，过一会又会收到一封邮件，内容如下<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/f1de6028777c7874a1593ec0119da0a6.png\" alt=\"1.4.1\"></li>\n<li>有过了不到一天的时间，就收到了申请的邓氏码，虽然他邮件上要求14个工作日再去使用邓氏码，但是根据我的尝试，我只等了不到两天就可以使用了。</li>\n</ol>\n<h3 id=\"注册企业开发者账号\"><a href=\"#注册企业开发者账号\" class=\"headerlink\" title=\"注册企业开发者账号\"></a>注册企业开发者账号</h3><ol>\n<li>注册一个AppleID，这个就不用说了，这里要注意的一点是，你在注册AppleID时必须使用你真实姓名的拼音去注册，否则苹果会给你发邮件让你改成真实姓名，我就遇到了这一点。<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/66506633bad28c995b24039688dda30e.png\" alt=\"2.1.1\"></li>\n<li>用你注册的AppleID登录苹果开发者中心，在最底部点击Enterprise Program，注意不是Developer Program。<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/939056f54db775460ceb68e2506e0003.png\" alt=\"2.2.1\"><br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/2281829dbb65193c65e248e581e595b3.png\" alt=\"2.2.2\"><br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/0aa47a0de740fdcd44c8197dafd43006.png\" alt=\"2.2.3\"></li>\n<li>Entity Type选择“Company/Organization”，然后点击继续<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/81c91b2b12845c24d0376ac599769625.png\" alt=\"2.3.1\"></li>\n<li>填写资料，然后点击继续<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/f04ef93f3b1298058add7700888fbb97.png\" alt=\"2.4.1\"></li>\n<li>确认信息，这里要注意一点，苹果显示的地址有字数限制，所以如果你的公司地址很长，这里可能会显示不全，这是正常的。确认完成后，点击提交。<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/2bad2013936e0dfe82b8e0b5bbc1a7ec.png\" alt=\"2.4.1\"></li>\n<li>过一会会收到一封邮件，提示你的申请已经被接受</li>\n<li>又过了两天，苹果会打电话来确认一些信息，然后就可以接着走下面的流程了，进入开发者中心，点击Review Now<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/dade54e4af9cc6126cb099e6656bf59f.png\" alt=\"2.7.1\"></li>\n<li>点击继续，然后就到了付款的阶段<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/249c8652294855c003063ab3cb1d04df.png\" alt=\"2.8.1\"></li>\n<li>点击Purchase，然后要重新登录一次AppleID，然后就是填写付款信息，这里要注意的是使用的信用卡一定是要同时具有银联标志和VISA标志的卡，我尝试过，使用仅支持银联或者VISA的信用卡是不能支付成功的。</li>\n<li>支付完成后，这个企业开发者证书就申请完了，登录开发者中心，显示的开发者类型就是企业开发者（in-house)<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/6c79710a8bb20bf59439b3de749e1839.png\" alt=\"2.10.1\"></li>\n</ol>\n<p>以上就算是我申请苹果企业开发者证书的全过程，希望对大家有所帮助</p>\n","excerpt":"","more":"<p>最近帮公司申请了企业开发者证书，中间也遇到了不少坑，下面是整个过程的一个完整记录，包括申请邓白氏编码的过程，希望对大家有所帮助。</p>\n<h3 id=\"申请邓白氏编码\"><a href=\"#申请邓白氏编码\" class=\"headerlink\" title=\"申请邓白氏编码\"></a>申请邓白氏编码</h3><ol>\n<li>注册企业开发者账号之前，要先申请<a href=\"http://baike.baidu.com/link?url=dzCD0bvR7RV_I_3KBXQtse65aaKmEO8_ghvPq7M9Y3V6-H-omCBMvpOMNImYwvKYdBBdhkvaD2oTmgiTYd9FHq\">邓白氏编码</a>，申请地址p<a href=\"https://developer.apple.com/support/D-U-N-S/\">https://developer.apple.com/support/D-U-N-S/</a>，首先填写公司信息，然后提交申请<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/b1ee643bd69fb351c1048b0f4c620ca2.png\" alt=\"1.1.1\"><br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/7bd0b2899cdc677a901febad7306fba2.png\" alt=\"1.1.2\"></li>\n<li>过一会会收到一封邮件，大概内容就是正在申请邓氏码，大概什么时候完成，还有一个requestID<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/5a8e972d91eb408774c787acf066c713.png\" alt=\"1.2.1\"></li>\n<li>又过了两天，接到了上海一家公司的电话，他跟我确认了一下邮箱，接着他会给你这个邮箱发一封邮件，要求你提供以下公司信息<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/810e19e549cbac41c918fdd9f794c025.png\" alt=\"1.3.1\"></li>\n<li>回复这封邮件，过一会又会收到一封邮件，内容如下<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/f1de6028777c7874a1593ec0119da0a6.png\" alt=\"1.4.1\"></li>\n<li>有过了不到一天的时间，就收到了申请的邓氏码，虽然他邮件上要求14个工作日再去使用邓氏码，但是根据我的尝试，我只等了不到两天就可以使用了。</li>\n</ol>\n<h3 id=\"注册企业开发者账号\"><a href=\"#注册企业开发者账号\" class=\"headerlink\" title=\"注册企业开发者账号\"></a>注册企业开发者账号</h3><ol>\n<li>注册一个AppleID，这个就不用说了，这里要注意的一点是，你在注册AppleID时必须使用你真实姓名的拼音去注册，否则苹果会给你发邮件让你改成真实姓名，我就遇到了这一点。<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/66506633bad28c995b24039688dda30e.png\" alt=\"2.1.1\"></li>\n<li>用你注册的AppleID登录苹果开发者中心，在最底部点击Enterprise Program，注意不是Developer Program。<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/939056f54db775460ceb68e2506e0003.png\" alt=\"2.2.1\"><br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/2281829dbb65193c65e248e581e595b3.png\" alt=\"2.2.2\"><br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/0aa47a0de740fdcd44c8197dafd43006.png\" alt=\"2.2.3\"></li>\n<li>Entity Type选择“Company/Organization”，然后点击继续<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/81c91b2b12845c24d0376ac599769625.png\" alt=\"2.3.1\"></li>\n<li>填写资料，然后点击继续<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/f04ef93f3b1298058add7700888fbb97.png\" alt=\"2.4.1\"></li>\n<li>确认信息，这里要注意一点，苹果显示的地址有字数限制，所以如果你的公司地址很长，这里可能会显示不全，这是正常的。确认完成后，点击提交。<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/2bad2013936e0dfe82b8e0b5bbc1a7ec.png\" alt=\"2.4.1\"></li>\n<li>过一会会收到一封邮件，提示你的申请已经被接受</li>\n<li>又过了两天，苹果会打电话来确认一些信息，然后就可以接着走下面的流程了，进入开发者中心，点击Review Now<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/dade54e4af9cc6126cb099e6656bf59f.png\" alt=\"2.7.1\"></li>\n<li>点击继续，然后就到了付款的阶段<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/249c8652294855c003063ab3cb1d04df.png\" alt=\"2.8.1\"></li>\n<li>点击Purchase，然后要重新登录一次AppleID，然后就是填写付款信息，这里要注意的是使用的信用卡一定是要同时具有银联标志和VISA标志的卡，我尝试过，使用仅支持银联或者VISA的信用卡是不能支付成功的。</li>\n<li>支付完成后，这个企业开发者证书就申请完了，登录开发者中心，显示的开发者类型就是企业开发者（in-house)<br><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/6c79710a8bb20bf59439b3de749e1839.png\" alt=\"2.10.1\"></li>\n</ol>\n<p>以上就算是我申请苹果企业开发者证书的全过程，希望对大家有所帮助</p>\n"},{"layout":"post","title":"2016年5月开发问题记录","_content":"\n这是我最近工作中遇到的问题，做一个简单的记录。\n\n## 设置导航栏透明\n\n项目中有一个界面的导航栏是透明的，效果如下：\n\n![1-1](http://7xn88v.com1.z0.glb.clouddn.com/d2b06aad44ccf25b3088bf3268f6de26.png)\n\n我首先想到的是:\n\n```objectivec\nself.navigationController.navigationBar.barTintColor = [UIColor clearColor];\n```\n\n但是设置了没有效果，然后又是一顿Google，找到了如下的解决方案：\n\n```objectivec\n// 设置导航栏背景图为一个透明的空图片\n[self.lmrNavigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];\n// 设置导航栏的阴影背景图为一个透明的空图片\nself.lmrNavigationBar.shadowImage = [UIImage new];\n// 设置导航栏为半透明\nself.lmrNavigationBar.translucent = YES;\n```\n\n## 设置UIPageControl左对齐\n\nUIPageControl默认是居中对齐的，要设置它左对齐，需要进行在布局是，根据UIPageControl点的个数，计算UIPageControl的中心点X的坐标。代码如下：\n\n```objectivec\n- (void)layoutSubviews {\n    CGSize pageSize = [self.pageControl sizeForNumberOfPages:self.pageControl.numberOfPages];\n    [self.pageControl setCenterX:20 + pageSize.width / 2];\n    [self.pageControl setOriginY:CGRectGetHeight(self.frame) - 14 - CGRectGetHeight(self.pageControl.frame)];\n}\n```\n\n效果如下：\n\n![2-1](http://7xn88v.com1.z0.glb.clouddn.com/664bd5d66be86fc7d0327fa63c0b8958.png)\n\n## 设置UILabel的内边距\n\n项目中要实现如下的一个标签（不可点击）：\n\n![3-1](http://7xn88v.com1.z0.glb.clouddn.com/dab95307496966b3e7f51b6f8fa22308.png)\n\n一种方案是直接使用UIButton来实现，因为UIButton有titleEdgeInsets属性，可以设置文字的内边距，我这里尝试使用了UILabel来实现，UILabel默认是不可以设置内边距的，但是可以通过自定义Label来实现，实现代码如下：\n\n```objectivec\n#import \"LMRPaddingLabel.h\"\n@implementation LMRPaddingLabel\n\n- (void)drawTextInRect:(CGRect)rect {\n    UIEdgeInsets insets = {2, 2, 2, 2};\n    [super drawTextInRect:UIEdgeInsetsInsetRect(rect, insets)];\n}\n\n- (CGSize)intrinsicContentSize {\n    CGSize size = [super intrinsicContentSize];\n    return CGSizeMake(size.width + 4, size.height + 4);\n}\n\n@end\n```\n\n这样，LMRPaddingLabel就会有2个点的内边距，相关问题可参考：[ios add left padding to uilabel](http://stackoverflow.com/questions/19437579/ios-add-left-padding-to-uilabel)\n\n## 长按手势默认会触发两次\n\n给一个View添加了一个UILongPressGestureRecognizer，长按这个View，默认会触发两次，一次是经过了minimumPressDuration长的时间，另一次是手指离开时，可以通过手势的state属性来区分，代码如下：\n\n```objectivec\n-  (void)handleLongPress:(UILongPressGestureRecognizer*)sender {\n    if (sender.state == UIGestureRecognizerStateEnded) {\n      NSLog(@\"UIGestureRecognizerStateEnded\");\n    //Do Whatever You want on End of Gesture\n     }\n    else if (sender.state == UIGestureRecognizerStateBegan){\n       NSLog(@\"UIGestureRecognizerStateBegan.\");\n   //Do Whatever You want on Began of Gesture\n     }\n  }\n```\n\n相关问题可参考：[UILongPressGestureRecognizer gets called twice when pressing down](http://stackoverflow.com/questions/3319591/uilongpressgesturerecognizer-gets-called-twice-when-pressing-down)\n\n## 使用RAC绑定可重用的Cell\n\n一般来讲，我们会为每一个复杂View创建一个对应的ViewModel，然后使用RAC（ReactiveCocoa）对View与ViewModel进行绑定（Binding），View与ViewModel之间始终是一一对应的，但是在UITableview中就有问题了，由于UITableviewCell的重用机制，实际创建的Cell个数要少于对应的ViewModel的数量，这样如果还是使用RAC进行简单的数据绑定的话，就会出现重复绑定的问题。\n\n解决方案就是在Cell发生重用后，解除Cell与之前的ViewModel的绑定，然后把Cell与新的ViewModel进行绑定。RAC中有一个方法`takeUntil`可以实现在指定信号发出前，一直订阅某一信号，一旦指定信号发出，就不再订阅某一信号，就相当于接触绑定。\n\n实例代码如下：\n\n```objectivec\n\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n{    \n    UITableViewCell *cell =\n        [tableView dequeueReusableCellWithIdentifier:REUSABLE_CELL_ID];\n\n    UILabel *label = (UILabel *)[cell viewWithTag:VIEW_TAG];\n    Model *someModel = [self getModelFromIndexPath:indexPath];\n\n    //  `takeUntil:` makes the RACObserve() signal complete (and thus breaks the subscription)\n    //  when the cell is recycled.\n\n    RAC(label, text) = [RACObserve(someModel, someKey)\n                            takeUntil:cell.rac_prepareForReuseSignal];\n\n    return cell;\n}\n\n```\n\n这里信号rac_prepareForReuseSignal即为Cell发生重用时发出的信号。\n\n相关问题可参考：[Example of Reactive Cocoa binding for a reusable cell.](https://gist.github.com/bunnyhero/9988574)\n\n## 使用NSURLSession发送同步请求\n\n最近项目中用到了同步请求，使用NSURLConnection发送同步请求非常简单，直接调用NSURLConnection的类方法`+sendSynchronousRequest:`就可以了，不过由于苹果官方不建议使用NSURLConnection，而NSURLSession又没有直接的同步请求的方法，所以就查了一下如何使用NSURLSession发送同步请求，结果如下，可以使用下面的方法发送同步请求：\n\n```objectivec\n#import \"NSURLSession+SynchronousTask.h\"\n\n@implementation NSURLSession (SynchronousTask)\n\n#pragma mark - NSURLSessionDataTask\n\n- (nullable NSData *)sendSynchronousDataTaskWithURL:(nonnull NSURL *)url returningResponse:(NSURLResponse *_Nullable*_Nullable)response error:(NSError *_Nullable*_Nullable)error {\n    return [self sendSynchronousDataTaskWithRequest:[NSURLRequest requestWithURL:url] returningResponse:response error:error];\n}\n\n- (nullable NSData *)sendSynchronousDataTaskWithRequest:(nonnull NSURLRequest *)request returningResponse:(NSURLResponse *_Nullable*_Nullable)response error:(NSError *_Nullable*_Nullable)error {\n    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\n    __block NSData *data = nil;\n    [[self dataTaskWithRequest:request completionHandler:^(NSData *taskData, NSURLResponse *taskResponse, NSError *taskError) {\n        data = taskData;\n        if (response) {\n            *response = taskResponse;\n        }\n        if (error) {\n            *error = taskError;\n        }\n        dispatch_semaphore_signal(semaphore);\n    }] resume];\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n\n    return data;\n}\n\n@end\n```\n\n这里使用的GCD的信号量做同步，使用时直接调用NSURLSession的这个分类的方法即可实现同步请求。\n\n## iOS7上自动布局的坑：Assertion failure in -[UITableView layoutSublayersOfLayer:]的错误\n\n最近在开发中遇到了“Assertion failure in -[UITableView layoutSublayersOfLayer:]”错误，而且只在iOS7上出现，iOS8及以上都是正常了，于是一阵Google，发现原来这个iOS7上自动布局的一个坑，造成这个错误主要有两个原因：\n\n1. 在添加UITableviewCell的子视图时，加在了Cell上而不是加在Cell的ContentView上，并且使用自动布局来布局\n2. 给UITableview添加了子视图，并且使用自动布局来布局，即`[tableView addSubview:someView]`\n\n对于第一个问题比较好解决，一般Cell的子视图都是加在Cell的ContentView上的，如果有那个视图没有加在ContentView上，改过来就可以了，只不过找起来可能比较麻烦。\n\n第二个问题就比较麻烦了，有时候我们确实需要给UITableview上加一个子视图，例如，加一个ErrorView或LoadingView等，这是如果使用自动布局设置了这个子视图与Tableview之间的约束，就会出现这个错误。解决方法就是不要使用自动布局，改用Frame的方法去设置子视图的位置，这样就不会报错了。针对iSO7专门做一下适配，如果大于iOS7可以继续使用自动布局。\n\n因为自动布局是在iOS6上才出现的，所以iOS6，包括iOS7上的自动布局都不是很成熟，有很多坑，这就需要我们不多的总结，才能避免再次掉进坑里。\n\n## Masonry不能用来更新XIB上设置的约束\n\n使用XIB加载的视图，如果在XIB上设置了自动布局的约束，在代码中想更新约束，是不能使用Masonry的mas_updateConstraints方法来更新约束的。解决方法就是把要更新的约束通过IBOutlet连接到代码中，然后在代码里更新这个约束，不过这个方法比较麻烦，暂时还没有找到其他更好的方法。\n","source":"_posts/2016-05-08-2016年5月开发问题记录.md","raw":"---\nlayout: post\ntitle: \"2016年5月开发问题记录\"\ncategories: \"iOS Tips\"\n---\n\n这是我最近工作中遇到的问题，做一个简单的记录。\n\n## 设置导航栏透明\n\n项目中有一个界面的导航栏是透明的，效果如下：\n\n![1-1](http://7xn88v.com1.z0.glb.clouddn.com/d2b06aad44ccf25b3088bf3268f6de26.png)\n\n我首先想到的是:\n\n```objectivec\nself.navigationController.navigationBar.barTintColor = [UIColor clearColor];\n```\n\n但是设置了没有效果，然后又是一顿Google，找到了如下的解决方案：\n\n```objectivec\n// 设置导航栏背景图为一个透明的空图片\n[self.lmrNavigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];\n// 设置导航栏的阴影背景图为一个透明的空图片\nself.lmrNavigationBar.shadowImage = [UIImage new];\n// 设置导航栏为半透明\nself.lmrNavigationBar.translucent = YES;\n```\n\n## 设置UIPageControl左对齐\n\nUIPageControl默认是居中对齐的，要设置它左对齐，需要进行在布局是，根据UIPageControl点的个数，计算UIPageControl的中心点X的坐标。代码如下：\n\n```objectivec\n- (void)layoutSubviews {\n    CGSize pageSize = [self.pageControl sizeForNumberOfPages:self.pageControl.numberOfPages];\n    [self.pageControl setCenterX:20 + pageSize.width / 2];\n    [self.pageControl setOriginY:CGRectGetHeight(self.frame) - 14 - CGRectGetHeight(self.pageControl.frame)];\n}\n```\n\n效果如下：\n\n![2-1](http://7xn88v.com1.z0.glb.clouddn.com/664bd5d66be86fc7d0327fa63c0b8958.png)\n\n## 设置UILabel的内边距\n\n项目中要实现如下的一个标签（不可点击）：\n\n![3-1](http://7xn88v.com1.z0.glb.clouddn.com/dab95307496966b3e7f51b6f8fa22308.png)\n\n一种方案是直接使用UIButton来实现，因为UIButton有titleEdgeInsets属性，可以设置文字的内边距，我这里尝试使用了UILabel来实现，UILabel默认是不可以设置内边距的，但是可以通过自定义Label来实现，实现代码如下：\n\n```objectivec\n#import \"LMRPaddingLabel.h\"\n@implementation LMRPaddingLabel\n\n- (void)drawTextInRect:(CGRect)rect {\n    UIEdgeInsets insets = {2, 2, 2, 2};\n    [super drawTextInRect:UIEdgeInsetsInsetRect(rect, insets)];\n}\n\n- (CGSize)intrinsicContentSize {\n    CGSize size = [super intrinsicContentSize];\n    return CGSizeMake(size.width + 4, size.height + 4);\n}\n\n@end\n```\n\n这样，LMRPaddingLabel就会有2个点的内边距，相关问题可参考：[ios add left padding to uilabel](http://stackoverflow.com/questions/19437579/ios-add-left-padding-to-uilabel)\n\n## 长按手势默认会触发两次\n\n给一个View添加了一个UILongPressGestureRecognizer，长按这个View，默认会触发两次，一次是经过了minimumPressDuration长的时间，另一次是手指离开时，可以通过手势的state属性来区分，代码如下：\n\n```objectivec\n-  (void)handleLongPress:(UILongPressGestureRecognizer*)sender {\n    if (sender.state == UIGestureRecognizerStateEnded) {\n      NSLog(@\"UIGestureRecognizerStateEnded\");\n    //Do Whatever You want on End of Gesture\n     }\n    else if (sender.state == UIGestureRecognizerStateBegan){\n       NSLog(@\"UIGestureRecognizerStateBegan.\");\n   //Do Whatever You want on Began of Gesture\n     }\n  }\n```\n\n相关问题可参考：[UILongPressGestureRecognizer gets called twice when pressing down](http://stackoverflow.com/questions/3319591/uilongpressgesturerecognizer-gets-called-twice-when-pressing-down)\n\n## 使用RAC绑定可重用的Cell\n\n一般来讲，我们会为每一个复杂View创建一个对应的ViewModel，然后使用RAC（ReactiveCocoa）对View与ViewModel进行绑定（Binding），View与ViewModel之间始终是一一对应的，但是在UITableview中就有问题了，由于UITableviewCell的重用机制，实际创建的Cell个数要少于对应的ViewModel的数量，这样如果还是使用RAC进行简单的数据绑定的话，就会出现重复绑定的问题。\n\n解决方案就是在Cell发生重用后，解除Cell与之前的ViewModel的绑定，然后把Cell与新的ViewModel进行绑定。RAC中有一个方法`takeUntil`可以实现在指定信号发出前，一直订阅某一信号，一旦指定信号发出，就不再订阅某一信号，就相当于接触绑定。\n\n实例代码如下：\n\n```objectivec\n\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n{    \n    UITableViewCell *cell =\n        [tableView dequeueReusableCellWithIdentifier:REUSABLE_CELL_ID];\n\n    UILabel *label = (UILabel *)[cell viewWithTag:VIEW_TAG];\n    Model *someModel = [self getModelFromIndexPath:indexPath];\n\n    //  `takeUntil:` makes the RACObserve() signal complete (and thus breaks the subscription)\n    //  when the cell is recycled.\n\n    RAC(label, text) = [RACObserve(someModel, someKey)\n                            takeUntil:cell.rac_prepareForReuseSignal];\n\n    return cell;\n}\n\n```\n\n这里信号rac_prepareForReuseSignal即为Cell发生重用时发出的信号。\n\n相关问题可参考：[Example of Reactive Cocoa binding for a reusable cell.](https://gist.github.com/bunnyhero/9988574)\n\n## 使用NSURLSession发送同步请求\n\n最近项目中用到了同步请求，使用NSURLConnection发送同步请求非常简单，直接调用NSURLConnection的类方法`+sendSynchronousRequest:`就可以了，不过由于苹果官方不建议使用NSURLConnection，而NSURLSession又没有直接的同步请求的方法，所以就查了一下如何使用NSURLSession发送同步请求，结果如下，可以使用下面的方法发送同步请求：\n\n```objectivec\n#import \"NSURLSession+SynchronousTask.h\"\n\n@implementation NSURLSession (SynchronousTask)\n\n#pragma mark - NSURLSessionDataTask\n\n- (nullable NSData *)sendSynchronousDataTaskWithURL:(nonnull NSURL *)url returningResponse:(NSURLResponse *_Nullable*_Nullable)response error:(NSError *_Nullable*_Nullable)error {\n    return [self sendSynchronousDataTaskWithRequest:[NSURLRequest requestWithURL:url] returningResponse:response error:error];\n}\n\n- (nullable NSData *)sendSynchronousDataTaskWithRequest:(nonnull NSURLRequest *)request returningResponse:(NSURLResponse *_Nullable*_Nullable)response error:(NSError *_Nullable*_Nullable)error {\n    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\n    __block NSData *data = nil;\n    [[self dataTaskWithRequest:request completionHandler:^(NSData *taskData, NSURLResponse *taskResponse, NSError *taskError) {\n        data = taskData;\n        if (response) {\n            *response = taskResponse;\n        }\n        if (error) {\n            *error = taskError;\n        }\n        dispatch_semaphore_signal(semaphore);\n    }] resume];\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n\n    return data;\n}\n\n@end\n```\n\n这里使用的GCD的信号量做同步，使用时直接调用NSURLSession的这个分类的方法即可实现同步请求。\n\n## iOS7上自动布局的坑：Assertion failure in -[UITableView layoutSublayersOfLayer:]的错误\n\n最近在开发中遇到了“Assertion failure in -[UITableView layoutSublayersOfLayer:]”错误，而且只在iOS7上出现，iOS8及以上都是正常了，于是一阵Google，发现原来这个iOS7上自动布局的一个坑，造成这个错误主要有两个原因：\n\n1. 在添加UITableviewCell的子视图时，加在了Cell上而不是加在Cell的ContentView上，并且使用自动布局来布局\n2. 给UITableview添加了子视图，并且使用自动布局来布局，即`[tableView addSubview:someView]`\n\n对于第一个问题比较好解决，一般Cell的子视图都是加在Cell的ContentView上的，如果有那个视图没有加在ContentView上，改过来就可以了，只不过找起来可能比较麻烦。\n\n第二个问题就比较麻烦了，有时候我们确实需要给UITableview上加一个子视图，例如，加一个ErrorView或LoadingView等，这是如果使用自动布局设置了这个子视图与Tableview之间的约束，就会出现这个错误。解决方法就是不要使用自动布局，改用Frame的方法去设置子视图的位置，这样就不会报错了。针对iSO7专门做一下适配，如果大于iOS7可以继续使用自动布局。\n\n因为自动布局是在iOS6上才出现的，所以iOS6，包括iOS7上的自动布局都不是很成熟，有很多坑，这就需要我们不多的总结，才能避免再次掉进坑里。\n\n## Masonry不能用来更新XIB上设置的约束\n\n使用XIB加载的视图，如果在XIB上设置了自动布局的约束，在代码中想更新约束，是不能使用Masonry的mas_updateConstraints方法来更新约束的。解决方法就是把要更新的约束通过IBOutlet连接到代码中，然后在代码里更新这个约束，不过这个方法比较麻烦，暂时还没有找到其他更好的方法。\n","slug":"2016年5月开发问题记录","published":1,"date":"2016-05-07T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oabf001izrm07t41z7pp","content":"<p>这是我最近工作中遇到的问题，做一个简单的记录。</p>\n<h2 id=\"设置导航栏透明\"><a href=\"#设置导航栏透明\" class=\"headerlink\" title=\"设置导航栏透明\"></a>设置导航栏透明</h2><p>项目中有一个界面的导航栏是透明的，效果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/d2b06aad44ccf25b3088bf3268f6de26.png\" alt=\"1-1\"></p>\n<p>我首先想到的是:</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.navigationController.navigationBar.barTintColor = [<span class=\"built_in\">UIColor</span> clearColor];</div></pre></td></tr></table></figure>\n<p>但是设置了没有效果，然后又是一顿Google，找到了如下的解决方案：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 设置导航栏背景图为一个透明的空图片</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.lmrNavigationBar setBackgroundImage:[<span class=\"built_in\">UIImage</span> new] forBarMetrics:<span class=\"built_in\">UIBarMetricsDefault</span>];</div><div class=\"line\"><span class=\"comment\">// 设置导航栏的阴影背景图为一个透明的空图片</span></div><div class=\"line\"><span class=\"keyword\">self</span>.lmrNavigationBar.shadowImage = [<span class=\"built_in\">UIImage</span> new];</div><div class=\"line\"><span class=\"comment\">// 设置导航栏为半透明</span></div><div class=\"line\"><span class=\"keyword\">self</span>.lmrNavigationBar.translucent = <span class=\"literal\">YES</span>;</div></pre></td></tr></table></figure>\n<h2 id=\"设置UIPageControl左对齐\"><a href=\"#设置UIPageControl左对齐\" class=\"headerlink\" title=\"设置UIPageControl左对齐\"></a>设置UIPageControl左对齐</h2><p>UIPageControl默认是居中对齐的，要设置它左对齐，需要进行在布局是，根据UIPageControl点的个数，计算UIPageControl的中心点X的坐标。代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)layoutSubviews &#123;</div><div class=\"line\">    <span class=\"built_in\">CGSize</span> pageSize = [<span class=\"keyword\">self</span>.pageControl sizeForNumberOfPages:<span class=\"keyword\">self</span>.pageControl.numberOfPages];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.pageControl setCenterX:<span class=\"number\">20</span> + pageSize.width / <span class=\"number\">2</span>];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.pageControl setOriginY:<span class=\"built_in\">CGRectGetHeight</span>(<span class=\"keyword\">self</span>.frame) - <span class=\"number\">14</span> - <span class=\"built_in\">CGRectGetHeight</span>(<span class=\"keyword\">self</span>.pageControl.frame)];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/664bd5d66be86fc7d0327fa63c0b8958.png\" alt=\"2-1\"></p>\n<h2 id=\"设置UILabel的内边距\"><a href=\"#设置UILabel的内边距\" class=\"headerlink\" title=\"设置UILabel的内边距\"></a>设置UILabel的内边距</h2><p>项目中要实现如下的一个标签（不可点击）：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/dab95307496966b3e7f51b6f8fa22308.png\" alt=\"3-1\"></p>\n<p>一种方案是直接使用UIButton来实现，因为UIButton有titleEdgeInsets属性，可以设置文字的内边距，我这里尝试使用了UILabel来实现，UILabel默认是不可以设置内边距的，但是可以通过自定义Label来实现，实现代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"LMRPaddingLabel.h\"</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">LMRPaddingLabel</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)drawTextInRect:(<span class=\"built_in\">CGRect</span>)rect &#123;</div><div class=\"line\">    <span class=\"built_in\">UIEdgeInsets</span> insets = &#123;<span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>&#125;;</div><div class=\"line\">    [<span class=\"keyword\">super</span> drawTextInRect:<span class=\"built_in\">UIEdgeInsetsInsetRect</span>(rect, insets)];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">CGSize</span>)intrinsicContentSize &#123;</div><div class=\"line\">    <span class=\"built_in\">CGSize</span> size = [<span class=\"keyword\">super</span> intrinsicContentSize];</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">CGSizeMake</span>(size.width + <span class=\"number\">4</span>, size.height + <span class=\"number\">4</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>这样，LMRPaddingLabel就会有2个点的内边距，相关问题可参考：<a href=\"http://stackoverflow.com/questions/19437579/ios-add-left-padding-to-uilabel\" target=\"_blank\" rel=\"external\">ios add left padding to uilabel</a></p>\n<h2 id=\"长按手势默认会触发两次\"><a href=\"#长按手势默认会触发两次\" class=\"headerlink\" title=\"长按手势默认会触发两次\"></a>长按手势默认会触发两次</h2><p>给一个View添加了一个UILongPressGestureRecognizer，长按这个View，默认会触发两次，一次是经过了minimumPressDuration长的时间，另一次是手指离开时，可以通过手势的state属性来区分，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">-  (<span class=\"keyword\">void</span>)handleLongPress:(<span class=\"built_in\">UILongPressGestureRecognizer</span>*)sender &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (sender.state == <span class=\"built_in\">UIGestureRecognizerStateEnded</span>) &#123;</div><div class=\"line\">      <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"UIGestureRecognizerStateEnded\"</span>);</div><div class=\"line\">    <span class=\"comment\">//Do Whatever You want on End of Gesture</span></div><div class=\"line\">     &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sender.state == <span class=\"built_in\">UIGestureRecognizerStateBegan</span>)&#123;</div><div class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"UIGestureRecognizerStateBegan.\"</span>);</div><div class=\"line\">   <span class=\"comment\">//Do Whatever You want on Began of Gesture</span></div><div class=\"line\">     &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>相关问题可参考：<a href=\"http://stackoverflow.com/questions/3319591/uilongpressgesturerecognizer-gets-called-twice-when-pressing-down\" target=\"_blank\" rel=\"external\">UILongPressGestureRecognizer gets called twice when pressing down</a></p>\n<h2 id=\"使用RAC绑定可重用的Cell\"><a href=\"#使用RAC绑定可重用的Cell\" class=\"headerlink\" title=\"使用RAC绑定可重用的Cell\"></a>使用RAC绑定可重用的Cell</h2><p>一般来讲，我们会为每一个复杂View创建一个对应的ViewModel，然后使用RAC（ReactiveCocoa）对View与ViewModel进行绑定（Binding），View与ViewModel之间始终是一一对应的，但是在UITableview中就有问题了，由于UITableviewCell的重用机制，实际创建的Cell个数要少于对应的ViewModel的数量，这样如果还是使用RAC进行简单的数据绑定的话，就会出现重复绑定的问题。</p>\n<p>解决方案就是在Cell发生重用后，解除Cell与之前的ViewModel的绑定，然后把Cell与新的ViewModel进行绑定。RAC中有一个方法<code>takeUntil</code>可以实现在指定信号发出前，一直订阅某一信号，一旦指定信号发出，就不再订阅某一信号，就相当于接触绑定。</p>\n<p>实例代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">UITableViewCell</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath</div><div class=\"line\">&#123;    </div><div class=\"line\">    <span class=\"built_in\">UITableViewCell</span> *cell =</div><div class=\"line\">        [tableView dequeueReusableCellWithIdentifier:REUSABLE_CELL_ID];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">UILabel</span> *label = (<span class=\"built_in\">UILabel</span> *)[cell viewWithTag:VIEW_TAG];</div><div class=\"line\">    Model *someModel = [<span class=\"keyword\">self</span> getModelFromIndexPath:indexPath];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//  `takeUntil:` makes the RACObserve() signal complete (and thus breaks the subscription)</span></div><div class=\"line\">    <span class=\"comment\">//  when the cell is recycled.</span></div><div class=\"line\"></div><div class=\"line\">    RAC(label, text) = [RACObserve(someModel, someKey)</div><div class=\"line\">                            takeUntil:cell.rac_prepareForReuseSignal];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> cell;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里信号rac_prepareForReuseSignal即为Cell发生重用时发出的信号。</p>\n<p>相关问题可参考：<a href=\"https://gist.github.com/bunnyhero/9988574\" target=\"_blank\" rel=\"external\">Example of Reactive Cocoa binding for a reusable cell.</a></p>\n<h2 id=\"使用NSURLSession发送同步请求\"><a href=\"#使用NSURLSession发送同步请求\" class=\"headerlink\" title=\"使用NSURLSession发送同步请求\"></a>使用NSURLSession发送同步请求</h2><p>最近项目中用到了同步请求，使用NSURLConnection发送同步请求非常简单，直接调用NSURLConnection的类方法<code>+sendSynchronousRequest:</code>就可以了，不过由于苹果官方不建议使用NSURLConnection，而NSURLSession又没有直接的同步请求的方法，所以就查了一下如何使用NSURLSession发送同步请求，结果如下，可以使用下面的方法发送同步请求：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"NSURLSession+SynchronousTask.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSURLSession</span> (<span class=\"title\">SynchronousTask</span>)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#pragma mark - NSURLSessionDataTask</span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSData</span> *)sendSynchronousDataTaskWithURL:(<span class=\"keyword\">nonnull</span> <span class=\"built_in\">NSURL</span> *)url returningResponse:(<span class=\"built_in\">NSURLResponse</span> *_Nullable*_Nullable)response error:(<span class=\"built_in\">NSError</span> *_Nullable*_Nullable)error &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> sendSynchronousDataTaskWithRequest:[<span class=\"built_in\">NSURLRequest</span> requestWithURL:url] returningResponse:response error:error];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSData</span> *)sendSynchronousDataTaskWithRequest:(<span class=\"keyword\">nonnull</span> <span class=\"built_in\">NSURLRequest</span> *)request returningResponse:(<span class=\"built_in\">NSURLResponse</span> *_Nullable*_Nullable)response error:(<span class=\"built_in\">NSError</span> *_Nullable*_Nullable)error &#123;</div><div class=\"line\">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class=\"number\">0</span>);</div><div class=\"line\">    __block <span class=\"built_in\">NSData</span> *data = <span class=\"literal\">nil</span>;</div><div class=\"line\">    [[<span class=\"keyword\">self</span> dataTaskWithRequest:request completionHandler:^(<span class=\"built_in\">NSData</span> *taskData, <span class=\"built_in\">NSURLResponse</span> *taskResponse, <span class=\"built_in\">NSError</span> *taskError) &#123;</div><div class=\"line\">        data = taskData;</div><div class=\"line\">        <span class=\"keyword\">if</span> (response) &#123;</div><div class=\"line\">            *response = taskResponse;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (error) &#123;</div><div class=\"line\">            *error = taskError;</div><div class=\"line\">        &#125;</div><div class=\"line\">        dispatch_semaphore_signal(semaphore);</div><div class=\"line\">    &#125;] resume];</div><div class=\"line\">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> data;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>这里使用的GCD的信号量做同步，使用时直接调用NSURLSession的这个分类的方法即可实现同步请求。</p>\n<h2 id=\"iOS7上自动布局的坑：Assertion-failure-in-UITableView-layoutSublayersOfLayer-的错误\"><a href=\"#iOS7上自动布局的坑：Assertion-failure-in-UITableView-layoutSublayersOfLayer-的错误\" class=\"headerlink\" title=\"iOS7上自动布局的坑：Assertion failure in -[UITableView layoutSublayersOfLayer:]的错误\"></a>iOS7上自动布局的坑：Assertion failure in -[UITableView layoutSublayersOfLayer:]的错误</h2><p>最近在开发中遇到了“Assertion failure in -[UITableView layoutSublayersOfLayer:]”错误，而且只在iOS7上出现，iOS8及以上都是正常了，于是一阵Google，发现原来这个iOS7上自动布局的一个坑，造成这个错误主要有两个原因：</p>\n<ol>\n<li>在添加UITableviewCell的子视图时，加在了Cell上而不是加在Cell的ContentView上，并且使用自动布局来布局</li>\n<li>给UITableview添加了子视图，并且使用自动布局来布局，即<code>[tableView addSubview:someView]</code></li>\n</ol>\n<p>对于第一个问题比较好解决，一般Cell的子视图都是加在Cell的ContentView上的，如果有那个视图没有加在ContentView上，改过来就可以了，只不过找起来可能比较麻烦。</p>\n<p>第二个问题就比较麻烦了，有时候我们确实需要给UITableview上加一个子视图，例如，加一个ErrorView或LoadingView等，这是如果使用自动布局设置了这个子视图与Tableview之间的约束，就会出现这个错误。解决方法就是不要使用自动布局，改用Frame的方法去设置子视图的位置，这样就不会报错了。针对iSO7专门做一下适配，如果大于iOS7可以继续使用自动布局。</p>\n<p>因为自动布局是在iOS6上才出现的，所以iOS6，包括iOS7上的自动布局都不是很成熟，有很多坑，这就需要我们不多的总结，才能避免再次掉进坑里。</p>\n<h2 id=\"Masonry不能用来更新XIB上设置的约束\"><a href=\"#Masonry不能用来更新XIB上设置的约束\" class=\"headerlink\" title=\"Masonry不能用来更新XIB上设置的约束\"></a>Masonry不能用来更新XIB上设置的约束</h2><p>使用XIB加载的视图，如果在XIB上设置了自动布局的约束，在代码中想更新约束，是不能使用Masonry的mas_updateConstraints方法来更新约束的。解决方法就是把要更新的约束通过IBOutlet连接到代码中，然后在代码里更新这个约束，不过这个方法比较麻烦，暂时还没有找到其他更好的方法。</p>\n","excerpt":"","more":"<p>这是我最近工作中遇到的问题，做一个简单的记录。</p>\n<h2 id=\"设置导航栏透明\"><a href=\"#设置导航栏透明\" class=\"headerlink\" title=\"设置导航栏透明\"></a>设置导航栏透明</h2><p>项目中有一个界面的导航栏是透明的，效果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/d2b06aad44ccf25b3088bf3268f6de26.png\" alt=\"1-1\"></p>\n<p>我首先想到的是:</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.navigationController.navigationBar.barTintColor = [<span class=\"built_in\">UIColor</span> clearColor];</div></pre></td></tr></table></figure>\n<p>但是设置了没有效果，然后又是一顿Google，找到了如下的解决方案：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 设置导航栏背景图为一个透明的空图片</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.lmrNavigationBar setBackgroundImage:[<span class=\"built_in\">UIImage</span> new] forBarMetrics:<span class=\"built_in\">UIBarMetricsDefault</span>];</div><div class=\"line\"><span class=\"comment\">// 设置导航栏的阴影背景图为一个透明的空图片</span></div><div class=\"line\"><span class=\"keyword\">self</span>.lmrNavigationBar.shadowImage = [<span class=\"built_in\">UIImage</span> new];</div><div class=\"line\"><span class=\"comment\">// 设置导航栏为半透明</span></div><div class=\"line\"><span class=\"keyword\">self</span>.lmrNavigationBar.translucent = <span class=\"literal\">YES</span>;</div></pre></td></tr></table></figure>\n<h2 id=\"设置UIPageControl左对齐\"><a href=\"#设置UIPageControl左对齐\" class=\"headerlink\" title=\"设置UIPageControl左对齐\"></a>设置UIPageControl左对齐</h2><p>UIPageControl默认是居中对齐的，要设置它左对齐，需要进行在布局是，根据UIPageControl点的个数，计算UIPageControl的中心点X的坐标。代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)layoutSubviews &#123;</div><div class=\"line\">    <span class=\"built_in\">CGSize</span> pageSize = [<span class=\"keyword\">self</span>.pageControl sizeForNumberOfPages:<span class=\"keyword\">self</span>.pageControl.numberOfPages];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.pageControl setCenterX:<span class=\"number\">20</span> + pageSize.width / <span class=\"number\">2</span>];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.pageControl setOriginY:<span class=\"built_in\">CGRectGetHeight</span>(<span class=\"keyword\">self</span>.frame) - <span class=\"number\">14</span> - <span class=\"built_in\">CGRectGetHeight</span>(<span class=\"keyword\">self</span>.pageControl.frame)];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/664bd5d66be86fc7d0327fa63c0b8958.png\" alt=\"2-1\"></p>\n<h2 id=\"设置UILabel的内边距\"><a href=\"#设置UILabel的内边距\" class=\"headerlink\" title=\"设置UILabel的内边距\"></a>设置UILabel的内边距</h2><p>项目中要实现如下的一个标签（不可点击）：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/dab95307496966b3e7f51b6f8fa22308.png\" alt=\"3-1\"></p>\n<p>一种方案是直接使用UIButton来实现，因为UIButton有titleEdgeInsets属性，可以设置文字的内边距，我这里尝试使用了UILabel来实现，UILabel默认是不可以设置内边距的，但是可以通过自定义Label来实现，实现代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"LMRPaddingLabel.h\"</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">LMRPaddingLabel</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)drawTextInRect:(<span class=\"built_in\">CGRect</span>)rect &#123;</div><div class=\"line\">    <span class=\"built_in\">UIEdgeInsets</span> insets = &#123;<span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>&#125;;</div><div class=\"line\">    [<span class=\"keyword\">super</span> drawTextInRect:<span class=\"built_in\">UIEdgeInsetsInsetRect</span>(rect, insets)];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">CGSize</span>)intrinsicContentSize &#123;</div><div class=\"line\">    <span class=\"built_in\">CGSize</span> size = [<span class=\"keyword\">super</span> intrinsicContentSize];</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">CGSizeMake</span>(size.width + <span class=\"number\">4</span>, size.height + <span class=\"number\">4</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>这样，LMRPaddingLabel就会有2个点的内边距，相关问题可参考：<a href=\"http://stackoverflow.com/questions/19437579/ios-add-left-padding-to-uilabel\">ios add left padding to uilabel</a></p>\n<h2 id=\"长按手势默认会触发两次\"><a href=\"#长按手势默认会触发两次\" class=\"headerlink\" title=\"长按手势默认会触发两次\"></a>长按手势默认会触发两次</h2><p>给一个View添加了一个UILongPressGestureRecognizer，长按这个View，默认会触发两次，一次是经过了minimumPressDuration长的时间，另一次是手指离开时，可以通过手势的state属性来区分，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">-  (<span class=\"keyword\">void</span>)handleLongPress:(<span class=\"built_in\">UILongPressGestureRecognizer</span>*)sender &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (sender.state == <span class=\"built_in\">UIGestureRecognizerStateEnded</span>) &#123;</div><div class=\"line\">      <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"UIGestureRecognizerStateEnded\"</span>);</div><div class=\"line\">    <span class=\"comment\">//Do Whatever You want on End of Gesture</span></div><div class=\"line\">     &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sender.state == <span class=\"built_in\">UIGestureRecognizerStateBegan</span>)&#123;</div><div class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"UIGestureRecognizerStateBegan.\"</span>);</div><div class=\"line\">   <span class=\"comment\">//Do Whatever You want on Began of Gesture</span></div><div class=\"line\">     &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>相关问题可参考：<a href=\"http://stackoverflow.com/questions/3319591/uilongpressgesturerecognizer-gets-called-twice-when-pressing-down\">UILongPressGestureRecognizer gets called twice when pressing down</a></p>\n<h2 id=\"使用RAC绑定可重用的Cell\"><a href=\"#使用RAC绑定可重用的Cell\" class=\"headerlink\" title=\"使用RAC绑定可重用的Cell\"></a>使用RAC绑定可重用的Cell</h2><p>一般来讲，我们会为每一个复杂View创建一个对应的ViewModel，然后使用RAC（ReactiveCocoa）对View与ViewModel进行绑定（Binding），View与ViewModel之间始终是一一对应的，但是在UITableview中就有问题了，由于UITableviewCell的重用机制，实际创建的Cell个数要少于对应的ViewModel的数量，这样如果还是使用RAC进行简单的数据绑定的话，就会出现重复绑定的问题。</p>\n<p>解决方案就是在Cell发生重用后，解除Cell与之前的ViewModel的绑定，然后把Cell与新的ViewModel进行绑定。RAC中有一个方法<code>takeUntil</code>可以实现在指定信号发出前，一直订阅某一信号，一旦指定信号发出，就不再订阅某一信号，就相当于接触绑定。</p>\n<p>实例代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">UITableViewCell</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath</div><div class=\"line\">&#123;    </div><div class=\"line\">    <span class=\"built_in\">UITableViewCell</span> *cell =</div><div class=\"line\">        [tableView dequeueReusableCellWithIdentifier:REUSABLE_CELL_ID];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">UILabel</span> *label = (<span class=\"built_in\">UILabel</span> *)[cell viewWithTag:VIEW_TAG];</div><div class=\"line\">    Model *someModel = [<span class=\"keyword\">self</span> getModelFromIndexPath:indexPath];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//  `takeUntil:` makes the RACObserve() signal complete (and thus breaks the subscription)</span></div><div class=\"line\">    <span class=\"comment\">//  when the cell is recycled.</span></div><div class=\"line\"></div><div class=\"line\">    RAC(label, text) = [RACObserve(someModel, someKey)</div><div class=\"line\">                            takeUntil:cell.rac_prepareForReuseSignal];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> cell;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里信号rac_prepareForReuseSignal即为Cell发生重用时发出的信号。</p>\n<p>相关问题可参考：<a href=\"https://gist.github.com/bunnyhero/9988574\">Example of Reactive Cocoa binding for a reusable cell.</a></p>\n<h2 id=\"使用NSURLSession发送同步请求\"><a href=\"#使用NSURLSession发送同步请求\" class=\"headerlink\" title=\"使用NSURLSession发送同步请求\"></a>使用NSURLSession发送同步请求</h2><p>最近项目中用到了同步请求，使用NSURLConnection发送同步请求非常简单，直接调用NSURLConnection的类方法<code>+sendSynchronousRequest:</code>就可以了，不过由于苹果官方不建议使用NSURLConnection，而NSURLSession又没有直接的同步请求的方法，所以就查了一下如何使用NSURLSession发送同步请求，结果如下，可以使用下面的方法发送同步请求：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"NSURLSession+SynchronousTask.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSURLSession</span> (<span class=\"title\">SynchronousTask</span>)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#pragma mark - NSURLSessionDataTask</span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSData</span> *)sendSynchronousDataTaskWithURL:(<span class=\"keyword\">nonnull</span> <span class=\"built_in\">NSURL</span> *)url returningResponse:(<span class=\"built_in\">NSURLResponse</span> *_Nullable*_Nullable)response error:(<span class=\"built_in\">NSError</span> *_Nullable*_Nullable)error &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> sendSynchronousDataTaskWithRequest:[<span class=\"built_in\">NSURLRequest</span> requestWithURL:url] returningResponse:response error:error];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSData</span> *)sendSynchronousDataTaskWithRequest:(<span class=\"keyword\">nonnull</span> <span class=\"built_in\">NSURLRequest</span> *)request returningResponse:(<span class=\"built_in\">NSURLResponse</span> *_Nullable*_Nullable)response error:(<span class=\"built_in\">NSError</span> *_Nullable*_Nullable)error &#123;</div><div class=\"line\">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class=\"number\">0</span>);</div><div class=\"line\">    __block <span class=\"built_in\">NSData</span> *data = <span class=\"literal\">nil</span>;</div><div class=\"line\">    [[<span class=\"keyword\">self</span> dataTaskWithRequest:request completionHandler:^(<span class=\"built_in\">NSData</span> *taskData, <span class=\"built_in\">NSURLResponse</span> *taskResponse, <span class=\"built_in\">NSError</span> *taskError) &#123;</div><div class=\"line\">        data = taskData;</div><div class=\"line\">        <span class=\"keyword\">if</span> (response) &#123;</div><div class=\"line\">            *response = taskResponse;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (error) &#123;</div><div class=\"line\">            *error = taskError;</div><div class=\"line\">        &#125;</div><div class=\"line\">        dispatch_semaphore_signal(semaphore);</div><div class=\"line\">    &#125;] resume];</div><div class=\"line\">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> data;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>这里使用的GCD的信号量做同步，使用时直接调用NSURLSession的这个分类的方法即可实现同步请求。</p>\n<h2 id=\"iOS7上自动布局的坑：Assertion-failure-in-UITableView-layoutSublayersOfLayer-的错误\"><a href=\"#iOS7上自动布局的坑：Assertion-failure-in-UITableView-layoutSublayersOfLayer-的错误\" class=\"headerlink\" title=\"iOS7上自动布局的坑：Assertion failure in -[UITableView layoutSublayersOfLayer:]的错误\"></a>iOS7上自动布局的坑：Assertion failure in -[UITableView layoutSublayersOfLayer:]的错误</h2><p>最近在开发中遇到了“Assertion failure in -[UITableView layoutSublayersOfLayer:]”错误，而且只在iOS7上出现，iOS8及以上都是正常了，于是一阵Google，发现原来这个iOS7上自动布局的一个坑，造成这个错误主要有两个原因：</p>\n<ol>\n<li>在添加UITableviewCell的子视图时，加在了Cell上而不是加在Cell的ContentView上，并且使用自动布局来布局</li>\n<li>给UITableview添加了子视图，并且使用自动布局来布局，即<code>[tableView addSubview:someView]</code></li>\n</ol>\n<p>对于第一个问题比较好解决，一般Cell的子视图都是加在Cell的ContentView上的，如果有那个视图没有加在ContentView上，改过来就可以了，只不过找起来可能比较麻烦。</p>\n<p>第二个问题就比较麻烦了，有时候我们确实需要给UITableview上加一个子视图，例如，加一个ErrorView或LoadingView等，这是如果使用自动布局设置了这个子视图与Tableview之间的约束，就会出现这个错误。解决方法就是不要使用自动布局，改用Frame的方法去设置子视图的位置，这样就不会报错了。针对iSO7专门做一下适配，如果大于iOS7可以继续使用自动布局。</p>\n<p>因为自动布局是在iOS6上才出现的，所以iOS6，包括iOS7上的自动布局都不是很成熟，有很多坑，这就需要我们不多的总结，才能避免再次掉进坑里。</p>\n<h2 id=\"Masonry不能用来更新XIB上设置的约束\"><a href=\"#Masonry不能用来更新XIB上设置的约束\" class=\"headerlink\" title=\"Masonry不能用来更新XIB上设置的约束\"></a>Masonry不能用来更新XIB上设置的约束</h2><p>使用XIB加载的视图，如果在XIB上设置了自动布局的约束，在代码中想更新约束，是不能使用Masonry的mas_updateConstraints方法来更新约束的。解决方法就是把要更新的约束通过IBOutlet连接到代码中，然后在代码里更新这个约束，不过这个方法比较麻烦，暂时还没有找到其他更好的方法。</p>\n"},{"layout":"post","title":"【翻译】MVVM Tutorial with ReactiveCocoa Part 2","_content":"\n原文地址：[MVVM Tutorial with ReactiveCocoa: Part 2/2](https://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2)\n\n----\n\nMVVM作为一种UI设计模式，正在成为一种非常流行的MVC模式的替代方案。\n\n在MVVM系列教程的第一部分，你已经了解了ReactiveCocoa是如何将ViewModels和他们各自的的View绑定起来的。\n\n![1](https://cdn5.raywenderlich.com/wp-content/uploads/2014/06/MVVMReactiveCocoa-700x121.png)\n\n下面是你创建的应用，一个搜索Flickr的APP。\n\n![2](https://cdn3.raywenderlich.com/wp-content/uploads/2014/06/FinishedApp-671x500.png)\n\n在 MVVM系列教程的第二部分以及最后一部分，你讲学会如果从应用程序的ViewModel中控制ViewController的导航。\n\n截止目前，你所开发的应用可以通过一个简单的字符串搜索Flickr，如果你需要当前的项目，可以从[这里](http://www.raywenderlich.com/wp-content/uploads/2014/06/FlickrSearchPart1Project1.zip)下载\n\n使用ReactiveCocoa构建的模型层服务提供搜索结果，对应的ViewModel能够简单地打印出响应结果。\n\n现在，是时候完成跳转到搜索结果界面的任务了。\n\n## 实现ViewModel导航\n\n搜索Flickr成功并返回正确的结果后，应用程序应该跳转到一个新的ViewController并显示这些搜索结果。\n\n当前应该程序只有单一的一个ViewModel，即RWTFlickrSearchViewModel类。为了达到预期的效果，你应该再创建一个ViewModel来描述返回的搜索结果视图。\n\n在ViewModel文件夹中一个名为RWTSearchResultsViewModel类，他继承自NSObject。代码如下：\n\n```objectivec\n@import Foundation;\n#import \"RWTViewModelServices.h\"\n#import \"RWTFlickrSearchResults.h\"\n\n@interface RWTSearchResultsViewModel : NSObject\n\n- (instancetype)initWithSearchResults:(RWTFlickrSearchResults *)results services:(id<RWTViewModelServices>)services;\n\n@property (strong, nonatomic) NSString *title;\n@property (strong, nonatomic) NSArray *searchResults;\n\n@end\n```\n\n上面的代码中添加了一些属性用于描述搜索结果视图，并且声明了一个包含一个RWTFlickrSearchResults参数（返回模型层的服务）的构造方法。\n\n打开RWTSearchResultsViewModel.m实现以下代码：\n\n```objectivec\n- (instancetype)initWithSearchResults:(RWTFlickrSearchResults *)results services:(id<RWTViewModelServices>)services {\n  if (self = [super init]) {\n    _title = results.searchString;\n    _searchResults = results.photos;\n  }\n  return self;\n}\n```\n\n这样RWTSearchResultsViewModel就完成了。\n\n回忆第一部分的内容，ViewModel应该在对应的View创建之前就已经创建好了，下面就是要完成各个ViewModel对应了View了。\n\n打开RWTSearchResultsViewController.h文件，导入对应的ViewModel头文件，并且添加一个初始化方法，代码如下：\n\n```objectivec\n#import \"RWTSearchResultsViewModel.h\"\n\n@interface RWTSearchResultsViewController : UIViewController\n\n- (instancetype)initWithViewModel:(RWTSearchResultsViewModel *)viewModel;\n\n@end\n```\n\n打开RWTSearchResultsViewController.m文件，并且在顶部的类扩展中添加一个私有属性，如下：\n\n```objectivec\n@property (strong, nonatomic) RWTSearchResultsViewModel *viewModel;\n```\n\n进一步完成初始化方法的实现，如下：\n\n```objectivec\n- (instancetype)initWithViewModel:(RWTSearchResultsViewModel *)viewModel {\n  if (self = [super init]) {\n    _viewModel = viewModel;\n  }\n  return self;\n}\n```\n\n这一步中，你将关注视图导航是如何工作的。\n\n你的应用程序现在有两个ViewModel，但是这里你将面临一个难题！我该怎么在视图控制器切换的同时也把对应的ViewModel进行切换。\n\nViewModel不能直接持有View的引用，所以，有什么巧妙的方法可以实现这个呢？\n\n答案已经在RWTViewModelServices协议中展现了。它当前被用来获得一个模型层的引用，你将用这个协议来实现ViewModel的切换。\n\n打开RWTViewModelServices.h并且添加如下方法到协议中去。\n\n```objectivec\n- (void)pushViewModel:(id)viewModel;\n```\n\n从概念上讲，ViewModel层驱动着整个App，这一层的逻辑决定着界面上会显示什么，以及界面之间切换的方式和时机。\n\n这个方法允许ViewModel也像UINavigationController那样可以从一个ViewModel以Push的方法切换到另一个ViewModel。\n\n在实现这个协议之前，你应该先是这个方法在ViewModel层可以工作。\n\n打开RWTFlickrSearchViewModel.m文件并导入新添加的ViewModel。\n\n```objectivec\n#import \"RWTSearchResultsViewModel.h\"\n```\n\n在同一文件更新executeSearchSignal方法的实现，代码如下：\n\n```objectivec\n- (RACSignal *)executeSearchSignal {\n  return [[[self.services getFlickrSearchService]\n    flickrSearchSignal:self.searchText]\n    doNext:^(id result) {\n      RWTSearchResultsViewModel *resultsViewModel =\n        [[RWTSearchResultsViewModel alloc] initWithSearchResults:result services:self.services];\n      [self.services pushViewModel:resultsViewModel];\n    }];\n}\n```\n\n上面的代码在搜索信号执行过程中添加了一个doNext操作，在doNext的block中创建了一个新的ViewModel来展示搜索结果，然后通过ViewModel的services的push操作切换到这个新的ViewModel上。\n\n现在，该更新代码，实现这个协议并达到切换ViewModel同时切换ViewController的效果。为了实现这个效果，我们需要在代码中引用导航控制器。\n\n打开RWTViewModelServicesImpl.h并且添加如下初始化方法：\n\n```objectivec\n- (instancetype)initWithNavigationController:(UINavigationController *)navigationController;\n```\n\n打开RWTViewModelServicesImpl.m并且添加下面的头文件：\n\n```objectivec\n#import \"RWTSearchResultsViewController.h\"\n```\n\n然后添加一个私有属性：\n\n```objectivec\n@property (weak, nonatomic) UINavigationController *navigationController;\n```\n\n然后在同一个文件完成方法的实现：\n\n```objectivec\n- (instancetype)initWithNavigationController:(UINavigationController *)navigationController {\n  if (self = [super init]) {\n    _searchService = [RWTFlickrSearchImpl new];\n    _navigationController = navigationController;\n  }\n  return self;\n}\n```\n\n上述代码用来把传过来的导航控制器引用记录下来。\n\n最后，添加一个新的方法：\n\n```objectivec\n- (void)pushViewModel:(id)viewModel {\n  id viewController;\n\n  if ([viewModel isKindOfClass:RWTSearchResultsViewModel.class]) {\n    viewController = [[RWTSearchResultsViewController alloc] initWithViewModel:viewModel];\n  } else {\n    NSLog(@\"an unknown ViewModel was pushed!\");\n  }\n\n  [self.navigationController pushViewController:viewController animated:YES];\n}\n```\n\n上述代码会根据ViewModel的类型来判断该显示那个视图。\n\n一般来说，View和ViewModel是一一对应的关系，但是你一定可以举出反例。\n\n最后一步，打开RWTAppDelegate.m，将createInitialViewController方法中创建RWTViewModelServicesImpl的一行改为如下代码：\n\n```objectivec\nself.viewModelServices = [[RWTViewModelServicesImpl alloc] initWithNavigationController:self.navigationController];\n```\n\n编译并运行程序，输入一个搜索关键字然后点击Go，可以观察到应用程序将切换到一个新的View/ViewModel。\n\n![3](https://cdn4.raywenderlich.com/wp-content/uploads/2014/06/BlankView-281x500.png)\n\n界面是空白的，别着急，待会你将修复这个问题。\n\n现在，可以庆祝一下，你已经实现了一个含有多个ViewModel并且可以通过ViewModel来切换界面的应用程序了。\n\n> 小贴士：John Gossman是一名微软WPF团队的工程师，他创造了MVVM模式。他说测试MVVM的一种方法就是你的应用程序应该脱离UI也可以运行。\n\n> 你的应用程序通过了这个测试。如果你不确信，可以通过单元测试来执行一个搜索或从一个ViewModel切换到另一个ViewModel。\n\n现在，你已经有了一个非常纯净的解决方案，下面要开始绑定UI了。\n\n## 呈现搜索结果列表\n\n搜索结果视图控制器RWTSearchResultsViewController在nib中定义了一个UITableview，下一步就是讲ViewModel中的内容展现在这个列表中。\n\n打开RWTSearchResultsViewController.m，添加一个类扩展，让他实现UITableViewDataSource协议，如下：\n\n```objectivec\n@interface RWTSearchResultsViewController () <UITableViewDataSource>\n```\n\n在同一文件中重写viewDidLoad方法，代码如下：\n\n```objectivec\n- (void)viewDidLoad {\n  [super viewDidLoad];\n\n  [self.searchResultsTable registerClass:UITableViewCell.class\n                  forCellReuseIdentifier:@\"cell\"];\n  self.searchResultsTable.dataSource = self;\n\n  [self bindViewModel];\n}\n```\n\n这些操作会在tableview初始化时执行一次，并绑定ViewModel。请忽略上面的Cell Identifier的硬编码，这个待会会删掉。\n\n然后在同一文件中，添加bindViewModel方法。\n\n```objectivec\n- (void)bindViewModel {\n  self.title = self.viewModel.title;\n}\n```\n\n当前并没有添加太多代码。ViewModel有两个属性，一个是标题，另一个是将要展示在列表中的搜索结果的数组。\n\n因此，你该如何把这些搜索结果绑定到Tableview上呢？\n\nReactiveCocoa可以绑定简单的属性到UIKit上，但是无法处理复杂的Tableview的数据绑定。\n\n不用焦急，还有其他方法。可以使用传统的代理方法实现。\n\n在同一文件中，添加如下两个dataSource的代理方法：\n\n```objectivec\n- (NSInteger)tableView:(UITableView *)tableView\n numberOfRowsInSection:(NSInteger)section {\n  return self.viewModel.searchResults.count;\n}\n\n- (UITableViewCell *)tableView:(UITableView *)tableView\n         cellForRowAtIndexPath:(NSIndexPath *)indexPath {\n  UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"cell\"];\n  cell.textLabel.text = [self.viewModel.searchResults[indexPath.row] title];\n  return cell;\n}\n```\n\n第一个方法用来告诉Tableview搜索结果的个数，第二个方法根据ViewModel返回一个相应的Cell。这就够了，不是吗？\n\n编译并运行程序，就可以看到数据了\n\n![4](https://cdn2.raywenderlich.com/wp-content/uploads/2014/06/PopulatedTable-281x500.png)\n\n## 更好的Tableview数据绑定方法\n\n这种绑定Tableview数据的方法的缺点就是很快就会使视图控制器的代码变得很大。手动绑定数据的方法看起来也不是很优雅。\n\n这个问题困扰着我，因此我着手解决这个问题。\n\n从理论上讲，ViewModel的搜索结果数据中的每一项自身也是一个与Cell一一对应的ViewModel。在我的一篇最近的[博客](http://www.scottlogic.com/blog/2014/05/11/reactivecocoa-tableview-binding.html)中，我创建了一个通用的绑定辅助类，叫做CETableViewBindingHelper，这个类允许你使用每一个子ViewModel创建一个视图。这个类可以用来辅助实现datasource协议。\n\n这个CETableViewBindingHelper类的构造方法如下：\n\n```objectivec\n+ (instancetype) bindingHelperForTableView:(UITableView *)tableView\n                              sourceSignal:(RACSignal *)source\n                          selectionCommand:(RACCommand *)selection\n                              templateCell:(UINib *)templateCellNib;\n```\n\n你仅仅只需要创建一个辅助类的引用，就可以用来绑定一个View的数组。这个构造方法的参数如下：\n\n1. 需要加载ViewModel数组的Tableview\n2. 一个source的信号用来监控数据的变化\n3. 一个在选中一个Cell后要执行的命令\n4. cell视图的nib\n\nnib文件定义的Cell必须实现CEReactiveView协议。\n\n项目中已经包含了一个用于展示搜索结果的Cell视图。打开RWTSearchResultsTableViewCell.h导入协议头文件：\n\n```objectivec\n#import \"CEReactiveView.h\"\n```\n\n实现这个协议：\n\n```objectivec\n@interface RWTSearchResultsTableViewCell : UITableViewCell <CEReactiveView>\n```\n\n下一步就是实现协议方法，打开RWTSearchResultsTableViewCell.m，导入如下内容：\n\n```objectivec\n#import <SDWebImage/UIImageView+WebCache.h>\n#import \"RWTFlickrPhoto.h\"\n```\n\n然后添加如下方法：\n\n```objectivec\n- (void)bindViewModel:(id)viewModel {\n  RWTFlickrPhoto *photo = viewModel;\n  self.titleLabel.text = photo.title;\n\n  self.imageThumbnailView.contentMode = UIViewContentModeScaleToFill;\n\n  [self.imageThumbnailView setImageWithURL:photo.url];\n}\n```\n\n现在RWTSearchResultsViewModel的searchResults属性包含了一个RWTFlickrPhoto的引用的数组。\n\n你刚刚添加的bindViewModel方法中用到了SDWebImage框架，这是一个非常有用的用来在后台加载图片的第三方框架。\n\nsetImageWithURL:是SDWebImage添加的一个UIImageView的分类方法。\n\n最后一步是用绑定辅助类去展示列表。\n\n打开RWTSearchResultsViewController.m导入辅助类头文件：\n\n```objectivec\n#import \"CETableViewBindingHelper.h\"\n```\n\n在同一文件中删除UITableDataSource协议以及实现的两个协议方法。\n\n下一步，在类扩展中添加一个如下的属性：\n\n```objectivec\n@property (strong, nonatomic) CETableViewBindingHelper *bindingHelper;\n```\n\n在同一文件中，删除你之前添加的ViewDidload方法中的内容，然后添加如下代码到ViewDidLoad中：\n\n```objectivec\n- (void)viewDidLoad {\n  [super viewDidLoad];\n  [self bindViewModel];\n}\n```\n\n最后，在bindViewModel方法的最后添加如下代码：\n\n```objectivec\nUINib *nib = [UINib nibWithNibName:@\"RWTSearchResultsTableViewCell\" bundle:nil];\n\nself.bindingHelper =\n  [CETableViewBindingHelper bindingHelperForTableView:self.searchResultsTable\n                                         sourceSignal:RACObserve(self.viewModel, searchResults)\n                                     selectionCommand:nil\n                                         templateCell:nib];\n```\n\n上述代码从nib文件中创建了一个UINIb类型的引用，并且创建了一个绑定辅助类的对象。通过观察ViewModel中的searchResults属性来创建一个sourceSignal。\n\n编译并运行，结果如下：\n\n![5](http://www.raywenderlich.com/wp-content/uploads/2014/06/UsingTheBindingHelper.png)\n\n这就是一种更加又要的绑定数组到Tableview的方法。\n\n## 一些UI的个性化\n\n到目前为止，这篇教程始终重点叫的都是如何根据MVVM模式构建你的应用程序。我想你已经忍不住想添加一些个性化的东西了。\n\n自从iOS7发布后，已经过了1年了，[运动设计](http://www.beyondkinetic.com/motion-ui-design-principles)获得了更大的知名度，许多设计人员现在倾向于微妙的动画和流体行为。\n\n这一步中，你将在照片上添加一个微妙的视差滚动效果，棒极了。\n\n打开RWTSearchResultsTableViewCell.h添加如下方法：\n\n```objectivec\n- (void) setParallax:(CGFloat)value;\n```\n\n列表视图的每个Cell将使用这个方法来为每个Cell做视觉偏移。\n\n打开 RWTSearchResultsTableViewCell.m 文件添加如下代码：\n\n```objectivec\n- (void)setParallax:(CGFloat)value {\n  self.imageThumbnailView.transform = CGAffineTransformMakeTranslation(0, value);\n}\n```\n\n打开RWTSearchResultsViewController.m导入如下头文件：\n\n```objectivec\n#import \"RWTSearchResultsTableViewCell.h\"\n```\n\n在同一个文件的类扩展中实现UITableViewDelegate的协议，如下：\n\n```objectivec\n@interface RWTSearchResultsViewController () <UITableViewDataSource, UITableViewDelegate>\n```\n\n你刚刚添加了一个绑定辅助类，并且把他设置为列表视图的代理，是他可以响应列表中行的选中动作。\n\n在bindViewModel方法中设置绑定辅助类的代理：\n\n```objectivec\nself.bindingHelper.delegate = self;\n```\n\n在同一文件中添加scrollViewDidScroll方法的实现，如下：\n\n```objectivec\n- (void)scrollViewDidScroll:(UIScrollView *)scrollView {\n  NSArray *cells = [self.searchResultsTable visibleCells];\n  for (RWTSearchResultsTableViewCell *cell in cells) {\n    CGFloat value = -40 + (cell.frame.origin.y - self.searchResultsTable.contentOffset.y) / 5;\n    [cell setParallax:value];\n  }\n}\n```\n\n每当列表视图滚动时，就会调用这个方法。在这个方法中，遍历所有可见的Cell，然后计算出一个偏移量，然后给每一个Cell设置一个视觉偏移。实际的偏移量将根据每一个Cell在列表视图可见部分的位置而定。\n\n编译并运行程序，就可以看到一个视差效果。\n\n![5](http://www.raywenderlich.com/wp-content/uploads/2014/06/ParallaxAnimation.gif)\n\n回到之前Views和ViewModels的工作。\n\n## 根据评论和点赞数查询\n\n界面上应该在每一张图片的底部右侧显示评论数和点赞数。但是，当前从nib创建的文件仅仅只是显示了一个123的假数据。\n\n在你使用真实数据之前，你需要在模型层添加这个功能。\n\n在Model文件夹中添加一个新的继承自NSObject的类RWTFlickrPhotoMetadata，打开RWTFlickrPhotoMetadata.h添加如下代码：\n\n```objectivec\n@property (nonatomic) NSUInteger favorites;\n@property (nonatomic) NSUInteger comments;\n```\n\n打开 RWTFlickrPhotoMetadata.m实现description方法：\n\n```objectivec\n- (NSString *)description {\n  return [NSString stringWithFormat:@\"metadata: comments=%lU, faves=%lU\",\n          self.comments, self.favorites];\n}\n```\n\n这个方法用于测试新添加的获取第一张照片的元数据的接口返回的数据是否正确。结果将被打印出来。\n\n编译并运行，搜索一些照片，当结果显示时，你将看到如下log将被打印出来。\n\n```objectivec\n2014-06-04 07:27:26.813 RWTFlickrSearch[76828:70b] metadata: comments=120, faves=434\n```\n\n## 取得元数据赋给可见的Cell\n\n你可以将当前的代码扩展成获取所有搜索结果的元数据。\n\n但是，如果结果有100张图片，你就要调用200次API接口，每张图片两次。许多API都有一个调用频率限制，这个操作可能会导致API Key被锁定，最少也是暂时不能用。\n\n其实，你只需要获取到当前在列表视图中显示的几张图片的元数据。因此，你该怎样实现这样的行为呢？你应该已经猜到了，你需要一个可以意识到他是否显示的一个ViewModel。\n\n当前的RWTSearchResultsViewModel对外暴漏了一个展示在视图上的RWTFlickrPhoto数组的接口，这些模型层的对象会被保留给View。为了能够添加一个可见性的概念，你将把这些在ViewModels里的模型对象封装起来。\n\n在ViewModel文件夹中添加一个NSObject的子类RWTSearchResultsItemViewModel，打开头文件，添加如下内容：\n\n```objectivec\n@import Foundation;\n#import \"RWTFlickrPhoto.h\"\n#import \"RWTViewModelServices.h\"\n\n@interface RWTSearchResultsItemViewModel : NSObject\n\n- (instancetype) initWithPhoto:(RWTFlickrPhoto *)photo services:(id<RWTViewModelServices>)services;\n\n@property (nonatomic) BOOL isVisible;\n@property (strong, nonatomic) NSString *title;\n@property (strong, nonatomic) NSURL *url;\n@property (strong, nonatomic) NSNumber *favorites;\n@property (strong, nonatomic) NSNumber *comments;\n\n@end\n```\n\n如你所见，这个ViewModel封装了RWTFlickrPhoto模型对象。\n\n这个ViewModel的属性混合了如下内容：\n\n* 对外的模型属性（title，url）\n* 会动态更新的图像元数据模型（favorites，comments）\n* isVisible用来指示ViewModel是否可见或不可见\n\n打开RWTSearchResultsItemViewModel.m导入如下头文件：\n\n```objectivec\n#import <ReactiveCocoa/ReactiveCocoa.h>\n#import <ReactiveCocoa/RACEXTScope.h>\n#import \"RWTFlickrPhotoMetadata.h\"\n```\n\n然后在类扩展中添加如下私有属性：\n\n```objectivec\n@interface RWTSearchResultsItemViewModel ()\n\n@property (weak, nonatomic) id<RWTViewModelServices> services;\n@property (strong, nonatomic) RWTFlickrPhoto *photo;\n\n@end\n```\n\n在同一文件中实现如下方法：\n\n```objectivec\n- (instancetype)initWithPhoto:(RWTFlickrPhoto *)photo services:(id<RWTViewModelServices>)services {\n  self = [super init];\n  if (self) {\n    _title = photo.title;\n    _url = photo.url;\n    _services = services;\n    _photo = photo;\n\n    [self initialize];\n  }\n  return  self;\n}\n```\n\n然后添加一个initialize方法，注意了，这是关键的地方：\n\n```objectivec\n- (void)initialize {\n  RACSignal *fetchMetadata =\n    [RACObserve(self, isVisible)\n     filter:^BOOL(NSNumber *visible) {\n       return [visible boolValue];\n     }];\n\n  @weakify(self)\n  [fetchMetadata subscribeNext:^(id x) {\n    @strongify(self)\n    [[[self.services getFlickrSearchService] flickrImageMetadata:self.photo.identifier]\n     subscribeNext:^(RWTFlickrPhotoMetadata *x) {\n       self.favorites = @(x.favorites);\n       self.comments = @(x.comments);\n     }];\n  }];\n}\n```\n\n方法的第一部分创建了一个用于监听isVisible属性的信号fetchMetadate，并且根据isVisible的值进行了过滤。结果就是只有当isVisible为true时这个信号才会发出Next Value。\n\n接下来一部分就是订阅这个信号以便开始请求flickrImageMetadata方法。当这个内嵌的信号触发Next时，将更新赞数和评论数。\n\n总的来说，当isVisible为true时，将触发Flickr请求，然后在未来的某个点更新comments和favorites属性。\n\n为了使这个新的ViewModel能够使用，打开RWTSearchResultsViewModel.m导入如下头文件：\n\n```objectivec\n#import <LinqToObjectiveC/NSArray+LinqExtensions.h>\n#import \"RWTSearchResultsItemViewModel.h\"\n```\n\n在初始化方法中，删除当前的代码，然后设置_searchResults如下：\n\n```objectivec\n_searchResults =\n  [results.photos linq_select:^id(RWTFlickrPhoto *photo) {\n    return [[RWTSearchResultsItemViewModel alloc]\n              initWithPhoto:photo services:services];\n  }];\n```\n\n这段代码将每一个模型对象封装成了一个ViewModel。\n\n最后一步就是根据视图设置isVisible属性，使得这些新的属性能够生效。\n\n打开RWTSearchResultsTableViewCell.m添加如下头文件：\n\n```objectivec\n#import \"RWTSearchResultsItemViewModel.h\"\n```\n\n在同一文件中，改变bindViewModel方法的第一行代码，使用新添加的ViewModel。\n\n```objectivec\nRWTSearchResultsItemViewModel *photo = viewModel;\n```\n\n在同一方法中添加如下代码：\n\n```objectivec\n[RACObserve(photo, favorites) subscribeNext:^(NSNumber *x) {\n  self.favouritesLabel.text = [x stringValue];\n  self.favouritesIcon.hidden = (x == nil);\n}];\n\n[RACObserve(photo, comments) subscribeNext:^(NSNumber *x) {\n  self.commentsLabel.text = [x stringValue];\n  self.commentsIcon.hidden = (x == nil);\n}];\n\nphoto.isVisible = YES;\n```\n\n这样当comments和favorites属性发生变化时，对应的lable以及image也会更新。\n\n最后一步，设置ViewModel的isVisible为YES。\n\n## 后记\n\n终于翻译完了，这是我第一次尝试翻译英文技术文章，前后断断续续用了大概两周的时间，真的很累，说实话，最后完全是为了翻译而去翻译的，而不是为了学习技术而去翻译的。不过这个过程中还是学到了不少东西。以后我还会坚持找一些经典的文章拿来翻译，不过不会翻译这么长的文章了，太累了。\n\n水平有限，很多地方翻译的不是很通顺，有些句子不知道怎么翻好，干脆就没有翻译，个中错误，以后有空会慢慢纠正。（2016-5-19）\n","source":"_posts/2016-05-09-MVVMTutorialwithReactiveCocoaPart2(翻译).md","raw":"---\nlayout: post\ntitle: \"【翻译】MVVM Tutorial with ReactiveCocoa Part 2\"\ncategories: \"iOS开发\"\n---\n\n原文地址：[MVVM Tutorial with ReactiveCocoa: Part 2/2](https://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2)\n\n----\n\nMVVM作为一种UI设计模式，正在成为一种非常流行的MVC模式的替代方案。\n\n在MVVM系列教程的第一部分，你已经了解了ReactiveCocoa是如何将ViewModels和他们各自的的View绑定起来的。\n\n![1](https://cdn5.raywenderlich.com/wp-content/uploads/2014/06/MVVMReactiveCocoa-700x121.png)\n\n下面是你创建的应用，一个搜索Flickr的APP。\n\n![2](https://cdn3.raywenderlich.com/wp-content/uploads/2014/06/FinishedApp-671x500.png)\n\n在 MVVM系列教程的第二部分以及最后一部分，你讲学会如果从应用程序的ViewModel中控制ViewController的导航。\n\n截止目前，你所开发的应用可以通过一个简单的字符串搜索Flickr，如果你需要当前的项目，可以从[这里](http://www.raywenderlich.com/wp-content/uploads/2014/06/FlickrSearchPart1Project1.zip)下载\n\n使用ReactiveCocoa构建的模型层服务提供搜索结果，对应的ViewModel能够简单地打印出响应结果。\n\n现在，是时候完成跳转到搜索结果界面的任务了。\n\n## 实现ViewModel导航\n\n搜索Flickr成功并返回正确的结果后，应用程序应该跳转到一个新的ViewController并显示这些搜索结果。\n\n当前应该程序只有单一的一个ViewModel，即RWTFlickrSearchViewModel类。为了达到预期的效果，你应该再创建一个ViewModel来描述返回的搜索结果视图。\n\n在ViewModel文件夹中一个名为RWTSearchResultsViewModel类，他继承自NSObject。代码如下：\n\n```objectivec\n@import Foundation;\n#import \"RWTViewModelServices.h\"\n#import \"RWTFlickrSearchResults.h\"\n\n@interface RWTSearchResultsViewModel : NSObject\n\n- (instancetype)initWithSearchResults:(RWTFlickrSearchResults *)results services:(id<RWTViewModelServices>)services;\n\n@property (strong, nonatomic) NSString *title;\n@property (strong, nonatomic) NSArray *searchResults;\n\n@end\n```\n\n上面的代码中添加了一些属性用于描述搜索结果视图，并且声明了一个包含一个RWTFlickrSearchResults参数（返回模型层的服务）的构造方法。\n\n打开RWTSearchResultsViewModel.m实现以下代码：\n\n```objectivec\n- (instancetype)initWithSearchResults:(RWTFlickrSearchResults *)results services:(id<RWTViewModelServices>)services {\n  if (self = [super init]) {\n    _title = results.searchString;\n    _searchResults = results.photos;\n  }\n  return self;\n}\n```\n\n这样RWTSearchResultsViewModel就完成了。\n\n回忆第一部分的内容，ViewModel应该在对应的View创建之前就已经创建好了，下面就是要完成各个ViewModel对应了View了。\n\n打开RWTSearchResultsViewController.h文件，导入对应的ViewModel头文件，并且添加一个初始化方法，代码如下：\n\n```objectivec\n#import \"RWTSearchResultsViewModel.h\"\n\n@interface RWTSearchResultsViewController : UIViewController\n\n- (instancetype)initWithViewModel:(RWTSearchResultsViewModel *)viewModel;\n\n@end\n```\n\n打开RWTSearchResultsViewController.m文件，并且在顶部的类扩展中添加一个私有属性，如下：\n\n```objectivec\n@property (strong, nonatomic) RWTSearchResultsViewModel *viewModel;\n```\n\n进一步完成初始化方法的实现，如下：\n\n```objectivec\n- (instancetype)initWithViewModel:(RWTSearchResultsViewModel *)viewModel {\n  if (self = [super init]) {\n    _viewModel = viewModel;\n  }\n  return self;\n}\n```\n\n这一步中，你将关注视图导航是如何工作的。\n\n你的应用程序现在有两个ViewModel，但是这里你将面临一个难题！我该怎么在视图控制器切换的同时也把对应的ViewModel进行切换。\n\nViewModel不能直接持有View的引用，所以，有什么巧妙的方法可以实现这个呢？\n\n答案已经在RWTViewModelServices协议中展现了。它当前被用来获得一个模型层的引用，你将用这个协议来实现ViewModel的切换。\n\n打开RWTViewModelServices.h并且添加如下方法到协议中去。\n\n```objectivec\n- (void)pushViewModel:(id)viewModel;\n```\n\n从概念上讲，ViewModel层驱动着整个App，这一层的逻辑决定着界面上会显示什么，以及界面之间切换的方式和时机。\n\n这个方法允许ViewModel也像UINavigationController那样可以从一个ViewModel以Push的方法切换到另一个ViewModel。\n\n在实现这个协议之前，你应该先是这个方法在ViewModel层可以工作。\n\n打开RWTFlickrSearchViewModel.m文件并导入新添加的ViewModel。\n\n```objectivec\n#import \"RWTSearchResultsViewModel.h\"\n```\n\n在同一文件更新executeSearchSignal方法的实现，代码如下：\n\n```objectivec\n- (RACSignal *)executeSearchSignal {\n  return [[[self.services getFlickrSearchService]\n    flickrSearchSignal:self.searchText]\n    doNext:^(id result) {\n      RWTSearchResultsViewModel *resultsViewModel =\n        [[RWTSearchResultsViewModel alloc] initWithSearchResults:result services:self.services];\n      [self.services pushViewModel:resultsViewModel];\n    }];\n}\n```\n\n上面的代码在搜索信号执行过程中添加了一个doNext操作，在doNext的block中创建了一个新的ViewModel来展示搜索结果，然后通过ViewModel的services的push操作切换到这个新的ViewModel上。\n\n现在，该更新代码，实现这个协议并达到切换ViewModel同时切换ViewController的效果。为了实现这个效果，我们需要在代码中引用导航控制器。\n\n打开RWTViewModelServicesImpl.h并且添加如下初始化方法：\n\n```objectivec\n- (instancetype)initWithNavigationController:(UINavigationController *)navigationController;\n```\n\n打开RWTViewModelServicesImpl.m并且添加下面的头文件：\n\n```objectivec\n#import \"RWTSearchResultsViewController.h\"\n```\n\n然后添加一个私有属性：\n\n```objectivec\n@property (weak, nonatomic) UINavigationController *navigationController;\n```\n\n然后在同一个文件完成方法的实现：\n\n```objectivec\n- (instancetype)initWithNavigationController:(UINavigationController *)navigationController {\n  if (self = [super init]) {\n    _searchService = [RWTFlickrSearchImpl new];\n    _navigationController = navigationController;\n  }\n  return self;\n}\n```\n\n上述代码用来把传过来的导航控制器引用记录下来。\n\n最后，添加一个新的方法：\n\n```objectivec\n- (void)pushViewModel:(id)viewModel {\n  id viewController;\n\n  if ([viewModel isKindOfClass:RWTSearchResultsViewModel.class]) {\n    viewController = [[RWTSearchResultsViewController alloc] initWithViewModel:viewModel];\n  } else {\n    NSLog(@\"an unknown ViewModel was pushed!\");\n  }\n\n  [self.navigationController pushViewController:viewController animated:YES];\n}\n```\n\n上述代码会根据ViewModel的类型来判断该显示那个视图。\n\n一般来说，View和ViewModel是一一对应的关系，但是你一定可以举出反例。\n\n最后一步，打开RWTAppDelegate.m，将createInitialViewController方法中创建RWTViewModelServicesImpl的一行改为如下代码：\n\n```objectivec\nself.viewModelServices = [[RWTViewModelServicesImpl alloc] initWithNavigationController:self.navigationController];\n```\n\n编译并运行程序，输入一个搜索关键字然后点击Go，可以观察到应用程序将切换到一个新的View/ViewModel。\n\n![3](https://cdn4.raywenderlich.com/wp-content/uploads/2014/06/BlankView-281x500.png)\n\n界面是空白的，别着急，待会你将修复这个问题。\n\n现在，可以庆祝一下，你已经实现了一个含有多个ViewModel并且可以通过ViewModel来切换界面的应用程序了。\n\n> 小贴士：John Gossman是一名微软WPF团队的工程师，他创造了MVVM模式。他说测试MVVM的一种方法就是你的应用程序应该脱离UI也可以运行。\n\n> 你的应用程序通过了这个测试。如果你不确信，可以通过单元测试来执行一个搜索或从一个ViewModel切换到另一个ViewModel。\n\n现在，你已经有了一个非常纯净的解决方案，下面要开始绑定UI了。\n\n## 呈现搜索结果列表\n\n搜索结果视图控制器RWTSearchResultsViewController在nib中定义了一个UITableview，下一步就是讲ViewModel中的内容展现在这个列表中。\n\n打开RWTSearchResultsViewController.m，添加一个类扩展，让他实现UITableViewDataSource协议，如下：\n\n```objectivec\n@interface RWTSearchResultsViewController () <UITableViewDataSource>\n```\n\n在同一文件中重写viewDidLoad方法，代码如下：\n\n```objectivec\n- (void)viewDidLoad {\n  [super viewDidLoad];\n\n  [self.searchResultsTable registerClass:UITableViewCell.class\n                  forCellReuseIdentifier:@\"cell\"];\n  self.searchResultsTable.dataSource = self;\n\n  [self bindViewModel];\n}\n```\n\n这些操作会在tableview初始化时执行一次，并绑定ViewModel。请忽略上面的Cell Identifier的硬编码，这个待会会删掉。\n\n然后在同一文件中，添加bindViewModel方法。\n\n```objectivec\n- (void)bindViewModel {\n  self.title = self.viewModel.title;\n}\n```\n\n当前并没有添加太多代码。ViewModel有两个属性，一个是标题，另一个是将要展示在列表中的搜索结果的数组。\n\n因此，你该如何把这些搜索结果绑定到Tableview上呢？\n\nReactiveCocoa可以绑定简单的属性到UIKit上，但是无法处理复杂的Tableview的数据绑定。\n\n不用焦急，还有其他方法。可以使用传统的代理方法实现。\n\n在同一文件中，添加如下两个dataSource的代理方法：\n\n```objectivec\n- (NSInteger)tableView:(UITableView *)tableView\n numberOfRowsInSection:(NSInteger)section {\n  return self.viewModel.searchResults.count;\n}\n\n- (UITableViewCell *)tableView:(UITableView *)tableView\n         cellForRowAtIndexPath:(NSIndexPath *)indexPath {\n  UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"cell\"];\n  cell.textLabel.text = [self.viewModel.searchResults[indexPath.row] title];\n  return cell;\n}\n```\n\n第一个方法用来告诉Tableview搜索结果的个数，第二个方法根据ViewModel返回一个相应的Cell。这就够了，不是吗？\n\n编译并运行程序，就可以看到数据了\n\n![4](https://cdn2.raywenderlich.com/wp-content/uploads/2014/06/PopulatedTable-281x500.png)\n\n## 更好的Tableview数据绑定方法\n\n这种绑定Tableview数据的方法的缺点就是很快就会使视图控制器的代码变得很大。手动绑定数据的方法看起来也不是很优雅。\n\n这个问题困扰着我，因此我着手解决这个问题。\n\n从理论上讲，ViewModel的搜索结果数据中的每一项自身也是一个与Cell一一对应的ViewModel。在我的一篇最近的[博客](http://www.scottlogic.com/blog/2014/05/11/reactivecocoa-tableview-binding.html)中，我创建了一个通用的绑定辅助类，叫做CETableViewBindingHelper，这个类允许你使用每一个子ViewModel创建一个视图。这个类可以用来辅助实现datasource协议。\n\n这个CETableViewBindingHelper类的构造方法如下：\n\n```objectivec\n+ (instancetype) bindingHelperForTableView:(UITableView *)tableView\n                              sourceSignal:(RACSignal *)source\n                          selectionCommand:(RACCommand *)selection\n                              templateCell:(UINib *)templateCellNib;\n```\n\n你仅仅只需要创建一个辅助类的引用，就可以用来绑定一个View的数组。这个构造方法的参数如下：\n\n1. 需要加载ViewModel数组的Tableview\n2. 一个source的信号用来监控数据的变化\n3. 一个在选中一个Cell后要执行的命令\n4. cell视图的nib\n\nnib文件定义的Cell必须实现CEReactiveView协议。\n\n项目中已经包含了一个用于展示搜索结果的Cell视图。打开RWTSearchResultsTableViewCell.h导入协议头文件：\n\n```objectivec\n#import \"CEReactiveView.h\"\n```\n\n实现这个协议：\n\n```objectivec\n@interface RWTSearchResultsTableViewCell : UITableViewCell <CEReactiveView>\n```\n\n下一步就是实现协议方法，打开RWTSearchResultsTableViewCell.m，导入如下内容：\n\n```objectivec\n#import <SDWebImage/UIImageView+WebCache.h>\n#import \"RWTFlickrPhoto.h\"\n```\n\n然后添加如下方法：\n\n```objectivec\n- (void)bindViewModel:(id)viewModel {\n  RWTFlickrPhoto *photo = viewModel;\n  self.titleLabel.text = photo.title;\n\n  self.imageThumbnailView.contentMode = UIViewContentModeScaleToFill;\n\n  [self.imageThumbnailView setImageWithURL:photo.url];\n}\n```\n\n现在RWTSearchResultsViewModel的searchResults属性包含了一个RWTFlickrPhoto的引用的数组。\n\n你刚刚添加的bindViewModel方法中用到了SDWebImage框架，这是一个非常有用的用来在后台加载图片的第三方框架。\n\nsetImageWithURL:是SDWebImage添加的一个UIImageView的分类方法。\n\n最后一步是用绑定辅助类去展示列表。\n\n打开RWTSearchResultsViewController.m导入辅助类头文件：\n\n```objectivec\n#import \"CETableViewBindingHelper.h\"\n```\n\n在同一文件中删除UITableDataSource协议以及实现的两个协议方法。\n\n下一步，在类扩展中添加一个如下的属性：\n\n```objectivec\n@property (strong, nonatomic) CETableViewBindingHelper *bindingHelper;\n```\n\n在同一文件中，删除你之前添加的ViewDidload方法中的内容，然后添加如下代码到ViewDidLoad中：\n\n```objectivec\n- (void)viewDidLoad {\n  [super viewDidLoad];\n  [self bindViewModel];\n}\n```\n\n最后，在bindViewModel方法的最后添加如下代码：\n\n```objectivec\nUINib *nib = [UINib nibWithNibName:@\"RWTSearchResultsTableViewCell\" bundle:nil];\n\nself.bindingHelper =\n  [CETableViewBindingHelper bindingHelperForTableView:self.searchResultsTable\n                                         sourceSignal:RACObserve(self.viewModel, searchResults)\n                                     selectionCommand:nil\n                                         templateCell:nib];\n```\n\n上述代码从nib文件中创建了一个UINIb类型的引用，并且创建了一个绑定辅助类的对象。通过观察ViewModel中的searchResults属性来创建一个sourceSignal。\n\n编译并运行，结果如下：\n\n![5](http://www.raywenderlich.com/wp-content/uploads/2014/06/UsingTheBindingHelper.png)\n\n这就是一种更加又要的绑定数组到Tableview的方法。\n\n## 一些UI的个性化\n\n到目前为止，这篇教程始终重点叫的都是如何根据MVVM模式构建你的应用程序。我想你已经忍不住想添加一些个性化的东西了。\n\n自从iOS7发布后，已经过了1年了，[运动设计](http://www.beyondkinetic.com/motion-ui-design-principles)获得了更大的知名度，许多设计人员现在倾向于微妙的动画和流体行为。\n\n这一步中，你将在照片上添加一个微妙的视差滚动效果，棒极了。\n\n打开RWTSearchResultsTableViewCell.h添加如下方法：\n\n```objectivec\n- (void) setParallax:(CGFloat)value;\n```\n\n列表视图的每个Cell将使用这个方法来为每个Cell做视觉偏移。\n\n打开 RWTSearchResultsTableViewCell.m 文件添加如下代码：\n\n```objectivec\n- (void)setParallax:(CGFloat)value {\n  self.imageThumbnailView.transform = CGAffineTransformMakeTranslation(0, value);\n}\n```\n\n打开RWTSearchResultsViewController.m导入如下头文件：\n\n```objectivec\n#import \"RWTSearchResultsTableViewCell.h\"\n```\n\n在同一个文件的类扩展中实现UITableViewDelegate的协议，如下：\n\n```objectivec\n@interface RWTSearchResultsViewController () <UITableViewDataSource, UITableViewDelegate>\n```\n\n你刚刚添加了一个绑定辅助类，并且把他设置为列表视图的代理，是他可以响应列表中行的选中动作。\n\n在bindViewModel方法中设置绑定辅助类的代理：\n\n```objectivec\nself.bindingHelper.delegate = self;\n```\n\n在同一文件中添加scrollViewDidScroll方法的实现，如下：\n\n```objectivec\n- (void)scrollViewDidScroll:(UIScrollView *)scrollView {\n  NSArray *cells = [self.searchResultsTable visibleCells];\n  for (RWTSearchResultsTableViewCell *cell in cells) {\n    CGFloat value = -40 + (cell.frame.origin.y - self.searchResultsTable.contentOffset.y) / 5;\n    [cell setParallax:value];\n  }\n}\n```\n\n每当列表视图滚动时，就会调用这个方法。在这个方法中，遍历所有可见的Cell，然后计算出一个偏移量，然后给每一个Cell设置一个视觉偏移。实际的偏移量将根据每一个Cell在列表视图可见部分的位置而定。\n\n编译并运行程序，就可以看到一个视差效果。\n\n![5](http://www.raywenderlich.com/wp-content/uploads/2014/06/ParallaxAnimation.gif)\n\n回到之前Views和ViewModels的工作。\n\n## 根据评论和点赞数查询\n\n界面上应该在每一张图片的底部右侧显示评论数和点赞数。但是，当前从nib创建的文件仅仅只是显示了一个123的假数据。\n\n在你使用真实数据之前，你需要在模型层添加这个功能。\n\n在Model文件夹中添加一个新的继承自NSObject的类RWTFlickrPhotoMetadata，打开RWTFlickrPhotoMetadata.h添加如下代码：\n\n```objectivec\n@property (nonatomic) NSUInteger favorites;\n@property (nonatomic) NSUInteger comments;\n```\n\n打开 RWTFlickrPhotoMetadata.m实现description方法：\n\n```objectivec\n- (NSString *)description {\n  return [NSString stringWithFormat:@\"metadata: comments=%lU, faves=%lU\",\n          self.comments, self.favorites];\n}\n```\n\n这个方法用于测试新添加的获取第一张照片的元数据的接口返回的数据是否正确。结果将被打印出来。\n\n编译并运行，搜索一些照片，当结果显示时，你将看到如下log将被打印出来。\n\n```objectivec\n2014-06-04 07:27:26.813 RWTFlickrSearch[76828:70b] metadata: comments=120, faves=434\n```\n\n## 取得元数据赋给可见的Cell\n\n你可以将当前的代码扩展成获取所有搜索结果的元数据。\n\n但是，如果结果有100张图片，你就要调用200次API接口，每张图片两次。许多API都有一个调用频率限制，这个操作可能会导致API Key被锁定，最少也是暂时不能用。\n\n其实，你只需要获取到当前在列表视图中显示的几张图片的元数据。因此，你该怎样实现这样的行为呢？你应该已经猜到了，你需要一个可以意识到他是否显示的一个ViewModel。\n\n当前的RWTSearchResultsViewModel对外暴漏了一个展示在视图上的RWTFlickrPhoto数组的接口，这些模型层的对象会被保留给View。为了能够添加一个可见性的概念，你将把这些在ViewModels里的模型对象封装起来。\n\n在ViewModel文件夹中添加一个NSObject的子类RWTSearchResultsItemViewModel，打开头文件，添加如下内容：\n\n```objectivec\n@import Foundation;\n#import \"RWTFlickrPhoto.h\"\n#import \"RWTViewModelServices.h\"\n\n@interface RWTSearchResultsItemViewModel : NSObject\n\n- (instancetype) initWithPhoto:(RWTFlickrPhoto *)photo services:(id<RWTViewModelServices>)services;\n\n@property (nonatomic) BOOL isVisible;\n@property (strong, nonatomic) NSString *title;\n@property (strong, nonatomic) NSURL *url;\n@property (strong, nonatomic) NSNumber *favorites;\n@property (strong, nonatomic) NSNumber *comments;\n\n@end\n```\n\n如你所见，这个ViewModel封装了RWTFlickrPhoto模型对象。\n\n这个ViewModel的属性混合了如下内容：\n\n* 对外的模型属性（title，url）\n* 会动态更新的图像元数据模型（favorites，comments）\n* isVisible用来指示ViewModel是否可见或不可见\n\n打开RWTSearchResultsItemViewModel.m导入如下头文件：\n\n```objectivec\n#import <ReactiveCocoa/ReactiveCocoa.h>\n#import <ReactiveCocoa/RACEXTScope.h>\n#import \"RWTFlickrPhotoMetadata.h\"\n```\n\n然后在类扩展中添加如下私有属性：\n\n```objectivec\n@interface RWTSearchResultsItemViewModel ()\n\n@property (weak, nonatomic) id<RWTViewModelServices> services;\n@property (strong, nonatomic) RWTFlickrPhoto *photo;\n\n@end\n```\n\n在同一文件中实现如下方法：\n\n```objectivec\n- (instancetype)initWithPhoto:(RWTFlickrPhoto *)photo services:(id<RWTViewModelServices>)services {\n  self = [super init];\n  if (self) {\n    _title = photo.title;\n    _url = photo.url;\n    _services = services;\n    _photo = photo;\n\n    [self initialize];\n  }\n  return  self;\n}\n```\n\n然后添加一个initialize方法，注意了，这是关键的地方：\n\n```objectivec\n- (void)initialize {\n  RACSignal *fetchMetadata =\n    [RACObserve(self, isVisible)\n     filter:^BOOL(NSNumber *visible) {\n       return [visible boolValue];\n     }];\n\n  @weakify(self)\n  [fetchMetadata subscribeNext:^(id x) {\n    @strongify(self)\n    [[[self.services getFlickrSearchService] flickrImageMetadata:self.photo.identifier]\n     subscribeNext:^(RWTFlickrPhotoMetadata *x) {\n       self.favorites = @(x.favorites);\n       self.comments = @(x.comments);\n     }];\n  }];\n}\n```\n\n方法的第一部分创建了一个用于监听isVisible属性的信号fetchMetadate，并且根据isVisible的值进行了过滤。结果就是只有当isVisible为true时这个信号才会发出Next Value。\n\n接下来一部分就是订阅这个信号以便开始请求flickrImageMetadata方法。当这个内嵌的信号触发Next时，将更新赞数和评论数。\n\n总的来说，当isVisible为true时，将触发Flickr请求，然后在未来的某个点更新comments和favorites属性。\n\n为了使这个新的ViewModel能够使用，打开RWTSearchResultsViewModel.m导入如下头文件：\n\n```objectivec\n#import <LinqToObjectiveC/NSArray+LinqExtensions.h>\n#import \"RWTSearchResultsItemViewModel.h\"\n```\n\n在初始化方法中，删除当前的代码，然后设置_searchResults如下：\n\n```objectivec\n_searchResults =\n  [results.photos linq_select:^id(RWTFlickrPhoto *photo) {\n    return [[RWTSearchResultsItemViewModel alloc]\n              initWithPhoto:photo services:services];\n  }];\n```\n\n这段代码将每一个模型对象封装成了一个ViewModel。\n\n最后一步就是根据视图设置isVisible属性，使得这些新的属性能够生效。\n\n打开RWTSearchResultsTableViewCell.m添加如下头文件：\n\n```objectivec\n#import \"RWTSearchResultsItemViewModel.h\"\n```\n\n在同一文件中，改变bindViewModel方法的第一行代码，使用新添加的ViewModel。\n\n```objectivec\nRWTSearchResultsItemViewModel *photo = viewModel;\n```\n\n在同一方法中添加如下代码：\n\n```objectivec\n[RACObserve(photo, favorites) subscribeNext:^(NSNumber *x) {\n  self.favouritesLabel.text = [x stringValue];\n  self.favouritesIcon.hidden = (x == nil);\n}];\n\n[RACObserve(photo, comments) subscribeNext:^(NSNumber *x) {\n  self.commentsLabel.text = [x stringValue];\n  self.commentsIcon.hidden = (x == nil);\n}];\n\nphoto.isVisible = YES;\n```\n\n这样当comments和favorites属性发生变化时，对应的lable以及image也会更新。\n\n最后一步，设置ViewModel的isVisible为YES。\n\n## 后记\n\n终于翻译完了，这是我第一次尝试翻译英文技术文章，前后断断续续用了大概两周的时间，真的很累，说实话，最后完全是为了翻译而去翻译的，而不是为了学习技术而去翻译的。不过这个过程中还是学到了不少东西。以后我还会坚持找一些经典的文章拿来翻译，不过不会翻译这么长的文章了，太累了。\n\n水平有限，很多地方翻译的不是很通顺，有些句子不知道怎么翻好，干脆就没有翻译，个中错误，以后有空会慢慢纠正。（2016-5-19）\n","slug":"MVVMTutorialwithReactiveCocoaPart2(翻译)","published":1,"date":"2016-05-08T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oabh001kzrm03q5yfmaa","content":"<p>原文地址：<a href=\"https://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2\" target=\"_blank\" rel=\"external\">MVVM Tutorial with ReactiveCocoa: Part 2/2</a></p>\n<hr>\n<p>MVVM作为一种UI设计模式，正在成为一种非常流行的MVC模式的替代方案。</p>\n<p>在MVVM系列教程的第一部分，你已经了解了ReactiveCocoa是如何将ViewModels和他们各自的的View绑定起来的。</p>\n<p><img src=\"https://cdn5.raywenderlich.com/wp-content/uploads/2014/06/MVVMReactiveCocoa-700x121.png\" alt=\"1\"></p>\n<p>下面是你创建的应用，一个搜索Flickr的APP。</p>\n<p><img src=\"https://cdn3.raywenderlich.com/wp-content/uploads/2014/06/FinishedApp-671x500.png\" alt=\"2\"></p>\n<p>在 MVVM系列教程的第二部分以及最后一部分，你讲学会如果从应用程序的ViewModel中控制ViewController的导航。</p>\n<p>截止目前，你所开发的应用可以通过一个简单的字符串搜索Flickr，如果你需要当前的项目，可以从<a href=\"http://www.raywenderlich.com/wp-content/uploads/2014/06/FlickrSearchPart1Project1.zip\" target=\"_blank\" rel=\"external\">这里</a>下载</p>\n<p>使用ReactiveCocoa构建的模型层服务提供搜索结果，对应的ViewModel能够简单地打印出响应结果。</p>\n<p>现在，是时候完成跳转到搜索结果界面的任务了。</p>\n<h2 id=\"实现ViewModel导航\"><a href=\"#实现ViewModel导航\" class=\"headerlink\" title=\"实现ViewModel导航\"></a>实现ViewModel导航</h2><p>搜索Flickr成功并返回正确的结果后，应用程序应该跳转到一个新的ViewController并显示这些搜索结果。</p>\n<p>当前应该程序只有单一的一个ViewModel，即RWTFlickrSearchViewModel类。为了达到预期的效果，你应该再创建一个ViewModel来描述返回的搜索结果视图。</p>\n<p>在ViewModel文件夹中一个名为RWTSearchResultsViewModel类，他继承自NSObject。代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@import</span> Foundation;</div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTViewModelServices.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTFlickrSearchResults.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">RWTSearchResultsViewModel</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithSearchResults:(RWTFlickrSearchResults *)results services:(<span class=\"keyword\">id</span>&lt;RWTViewModelServices&gt;)services;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSString</span> *title;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSArray</span> *searchResults;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>上面的代码中添加了一些属性用于描述搜索结果视图，并且声明了一个包含一个RWTFlickrSearchResults参数（返回模型层的服务）的构造方法。</p>\n<p>打开RWTSearchResultsViewModel.m实现以下代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithSearchResults:(RWTFlickrSearchResults *)results services:(<span class=\"keyword\">id</span>&lt;RWTViewModelServices&gt;)services &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</div><div class=\"line\">    _title = results.searchString;</div><div class=\"line\">    _searchResults = results.photos;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样RWTSearchResultsViewModel就完成了。</p>\n<p>回忆第一部分的内容，ViewModel应该在对应的View创建之前就已经创建好了，下面就是要完成各个ViewModel对应了View了。</p>\n<p>打开RWTSearchResultsViewController.h文件，导入对应的ViewModel头文件，并且添加一个初始化方法，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTSearchResultsViewModel.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">RWTSearchResultsViewController</span> : <span class=\"title\">UIViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithViewModel:(RWTSearchResultsViewModel *)viewModel;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>打开RWTSearchResultsViewController.m文件，并且在顶部的类扩展中添加一个私有属性，如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) RWTSearchResultsViewModel *viewModel;</div></pre></td></tr></table></figure>\n<p>进一步完成初始化方法的实现，如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithViewModel:(RWTSearchResultsViewModel *)viewModel &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</div><div class=\"line\">    _viewModel = viewModel;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这一步中，你将关注视图导航是如何工作的。</p>\n<p>你的应用程序现在有两个ViewModel，但是这里你将面临一个难题！我该怎么在视图控制器切换的同时也把对应的ViewModel进行切换。</p>\n<p>ViewModel不能直接持有View的引用，所以，有什么巧妙的方法可以实现这个呢？</p>\n<p>答案已经在RWTViewModelServices协议中展现了。它当前被用来获得一个模型层的引用，你将用这个协议来实现ViewModel的切换。</p>\n<p>打开RWTViewModelServices.h并且添加如下方法到协议中去。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)pushViewModel:(<span class=\"keyword\">id</span>)viewModel;</div></pre></td></tr></table></figure>\n<p>从概念上讲，ViewModel层驱动着整个App，这一层的逻辑决定着界面上会显示什么，以及界面之间切换的方式和时机。</p>\n<p>这个方法允许ViewModel也像UINavigationController那样可以从一个ViewModel以Push的方法切换到另一个ViewModel。</p>\n<p>在实现这个协议之前，你应该先是这个方法在ViewModel层可以工作。</p>\n<p>打开RWTFlickrSearchViewModel.m文件并导入新添加的ViewModel。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTSearchResultsViewModel.h\"</span></span></div></pre></td></tr></table></figure>\n<p>在同一文件更新executeSearchSignal方法的实现，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (RACSignal *)executeSearchSignal &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [[[<span class=\"keyword\">self</span>.services getFlickrSearchService]</div><div class=\"line\">    flickrSearchSignal:<span class=\"keyword\">self</span>.searchText]</div><div class=\"line\">    doNext:^(<span class=\"keyword\">id</span> result) &#123;</div><div class=\"line\">      RWTSearchResultsViewModel *resultsViewModel =</div><div class=\"line\">        [[RWTSearchResultsViewModel alloc] initWithSearchResults:result services:<span class=\"keyword\">self</span>.services];</div><div class=\"line\">      [<span class=\"keyword\">self</span>.services pushViewModel:resultsViewModel];</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码在搜索信号执行过程中添加了一个doNext操作，在doNext的block中创建了一个新的ViewModel来展示搜索结果，然后通过ViewModel的services的push操作切换到这个新的ViewModel上。</p>\n<p>现在，该更新代码，实现这个协议并达到切换ViewModel同时切换ViewController的效果。为了实现这个效果，我们需要在代码中引用导航控制器。</p>\n<p>打开RWTViewModelServicesImpl.h并且添加如下初始化方法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithNavigationController:(<span class=\"built_in\">UINavigationController</span> *)navigationController;</div></pre></td></tr></table></figure>\n<p>打开RWTViewModelServicesImpl.m并且添加下面的头文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTSearchResultsViewController.h\"</span></span></div></pre></td></tr></table></figure>\n<p>然后添加一个私有属性：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">UINavigationController</span> *navigationController;</div></pre></td></tr></table></figure>\n<p>然后在同一个文件完成方法的实现：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithNavigationController:(<span class=\"built_in\">UINavigationController</span> *)navigationController &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</div><div class=\"line\">    _searchService = [RWTFlickrSearchImpl new];</div><div class=\"line\">    _navigationController = navigationController;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述代码用来把传过来的导航控制器引用记录下来。</p>\n<p>最后，添加一个新的方法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)pushViewModel:(<span class=\"keyword\">id</span>)viewModel &#123;</div><div class=\"line\">  <span class=\"keyword\">id</span> viewController;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> ([viewModel isKindOfClass:RWTSearchResultsViewModel.class]) &#123;</div><div class=\"line\">    viewController = [[RWTSearchResultsViewController alloc] initWithViewModel:viewModel];</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"an unknown ViewModel was pushed!\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  [<span class=\"keyword\">self</span>.navigationController pushViewController:viewController animated:<span class=\"literal\">YES</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述代码会根据ViewModel的类型来判断该显示那个视图。</p>\n<p>一般来说，View和ViewModel是一一对应的关系，但是你一定可以举出反例。</p>\n<p>最后一步，打开RWTAppDelegate.m，将createInitialViewController方法中创建RWTViewModelServicesImpl的一行改为如下代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.viewModelServices = [[RWTViewModelServicesImpl alloc] initWithNavigationController:<span class=\"keyword\">self</span>.navigationController];</div></pre></td></tr></table></figure>\n<p>编译并运行程序，输入一个搜索关键字然后点击Go，可以观察到应用程序将切换到一个新的View/ViewModel。</p>\n<p><img src=\"https://cdn4.raywenderlich.com/wp-content/uploads/2014/06/BlankView-281x500.png\" alt=\"3\"></p>\n<p>界面是空白的，别着急，待会你将修复这个问题。</p>\n<p>现在，可以庆祝一下，你已经实现了一个含有多个ViewModel并且可以通过ViewModel来切换界面的应用程序了。</p>\n<blockquote>\n<p>小贴士：John Gossman是一名微软WPF团队的工程师，他创造了MVVM模式。他说测试MVVM的一种方法就是你的应用程序应该脱离UI也可以运行。</p>\n<p>你的应用程序通过了这个测试。如果你不确信，可以通过单元测试来执行一个搜索或从一个ViewModel切换到另一个ViewModel。</p>\n</blockquote>\n<p>现在，你已经有了一个非常纯净的解决方案，下面要开始绑定UI了。</p>\n<h2 id=\"呈现搜索结果列表\"><a href=\"#呈现搜索结果列表\" class=\"headerlink\" title=\"呈现搜索结果列表\"></a>呈现搜索结果列表</h2><p>搜索结果视图控制器RWTSearchResultsViewController在nib中定义了一个UITableview，下一步就是讲ViewModel中的内容展现在这个列表中。</p>\n<p>打开RWTSearchResultsViewController.m，添加一个类扩展，让他实现UITableViewDataSource协议，如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">RWTSearchResultsViewController</span> () &lt;<span class=\"title\">UITableViewDataSource</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在同一文件中重写viewDidLoad方法，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">  [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">  [<span class=\"keyword\">self</span>.searchResultsTable registerClass:<span class=\"built_in\">UITableViewCell</span>.class</div><div class=\"line\">                  forCellReuseIdentifier:<span class=\"string\">@\"cell\"</span>];</div><div class=\"line\">  <span class=\"keyword\">self</span>.searchResultsTable.dataSource = <span class=\"keyword\">self</span>;</div><div class=\"line\"></div><div class=\"line\">  [<span class=\"keyword\">self</span> bindViewModel];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这些操作会在tableview初始化时执行一次，并绑定ViewModel。请忽略上面的Cell Identifier的硬编码，这个待会会删掉。</p>\n<p>然后在同一文件中，添加bindViewModel方法。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)bindViewModel &#123;</div><div class=\"line\">  <span class=\"keyword\">self</span>.title = <span class=\"keyword\">self</span>.viewModel.title;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当前并没有添加太多代码。ViewModel有两个属性，一个是标题，另一个是将要展示在列表中的搜索结果的数组。</p>\n<p>因此，你该如何把这些搜索结果绑定到Tableview上呢？</p>\n<p>ReactiveCocoa可以绑定简单的属性到UIKit上，但是无法处理复杂的Tableview的数据绑定。</p>\n<p>不用焦急，还有其他方法。可以使用传统的代理方法实现。</p>\n<p>在同一文件中，添加如下两个dataSource的代理方法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSInteger</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView</div><div class=\"line\"> numberOfRowsInSection:(<span class=\"built_in\">NSInteger</span>)section &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.viewModel.searchResults.count;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">UITableViewCell</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView</div><div class=\"line\">         cellForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</div><div class=\"line\">  <span class=\"built_in\">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:<span class=\"string\">@\"cell\"</span>];</div><div class=\"line\">  cell.textLabel.text = [<span class=\"keyword\">self</span>.viewModel.searchResults[indexPath.row] title];</div><div class=\"line\">  <span class=\"keyword\">return</span> cell;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第一个方法用来告诉Tableview搜索结果的个数，第二个方法根据ViewModel返回一个相应的Cell。这就够了，不是吗？</p>\n<p>编译并运行程序，就可以看到数据了</p>\n<p><img src=\"https://cdn2.raywenderlich.com/wp-content/uploads/2014/06/PopulatedTable-281x500.png\" alt=\"4\"></p>\n<h2 id=\"更好的Tableview数据绑定方法\"><a href=\"#更好的Tableview数据绑定方法\" class=\"headerlink\" title=\"更好的Tableview数据绑定方法\"></a>更好的Tableview数据绑定方法</h2><p>这种绑定Tableview数据的方法的缺点就是很快就会使视图控制器的代码变得很大。手动绑定数据的方法看起来也不是很优雅。</p>\n<p>这个问题困扰着我，因此我着手解决这个问题。</p>\n<p>从理论上讲，ViewModel的搜索结果数据中的每一项自身也是一个与Cell一一对应的ViewModel。在我的一篇最近的<a href=\"http://www.scottlogic.com/blog/2014/05/11/reactivecocoa-tableview-binding.html\" target=\"_blank\" rel=\"external\">博客</a>中，我创建了一个通用的绑定辅助类，叫做CETableViewBindingHelper，这个类允许你使用每一个子ViewModel创建一个视图。这个类可以用来辅助实现datasource协议。</p>\n<p>这个CETableViewBindingHelper类的构造方法如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"keyword\">instancetype</span>) bindingHelperForTableView:(<span class=\"built_in\">UITableView</span> *)tableView</div><div class=\"line\">                              sourceSignal:(RACSignal *)source</div><div class=\"line\">                          selectionCommand:(RACCommand *)selection</div><div class=\"line\">                              templateCell:(<span class=\"built_in\">UINib</span> *)templateCellNib;</div></pre></td></tr></table></figure>\n<p>你仅仅只需要创建一个辅助类的引用，就可以用来绑定一个View的数组。这个构造方法的参数如下：</p>\n<ol>\n<li>需要加载ViewModel数组的Tableview</li>\n<li>一个source的信号用来监控数据的变化</li>\n<li>一个在选中一个Cell后要执行的命令</li>\n<li>cell视图的nib</li>\n</ol>\n<p>nib文件定义的Cell必须实现CEReactiveView协议。</p>\n<p>项目中已经包含了一个用于展示搜索结果的Cell视图。打开RWTSearchResultsTableViewCell.h导入协议头文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CEReactiveView.h\"</span></span></div></pre></td></tr></table></figure>\n<p>实现这个协议：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">RWTSearchResultsTableViewCell</span> : <span class=\"title\">UITableViewCell</span> &lt;<span class=\"title\">CEReactiveView</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>下一步就是实现协议方法，打开RWTSearchResultsTableViewCell.m，导入如下内容：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;SDWebImage/UIImageView+WebCache.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTFlickrPhoto.h\"</span></span></div></pre></td></tr></table></figure>\n<p>然后添加如下方法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)bindViewModel:(<span class=\"keyword\">id</span>)viewModel &#123;</div><div class=\"line\">  RWTFlickrPhoto *photo = viewModel;</div><div class=\"line\">  <span class=\"keyword\">self</span>.titleLabel.text = photo.title;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">self</span>.imageThumbnailView.contentMode = <span class=\"built_in\">UIViewContentModeScaleToFill</span>;</div><div class=\"line\"></div><div class=\"line\">  [<span class=\"keyword\">self</span>.imageThumbnailView setImageWithURL:photo.url];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在RWTSearchResultsViewModel的searchResults属性包含了一个RWTFlickrPhoto的引用的数组。</p>\n<p>你刚刚添加的bindViewModel方法中用到了SDWebImage框架，这是一个非常有用的用来在后台加载图片的第三方框架。</p>\n<p>setImageWithURL:是SDWebImage添加的一个UIImageView的分类方法。</p>\n<p>最后一步是用绑定辅助类去展示列表。</p>\n<p>打开RWTSearchResultsViewController.m导入辅助类头文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CETableViewBindingHelper.h\"</span></span></div></pre></td></tr></table></figure>\n<p>在同一文件中删除UITableDataSource协议以及实现的两个协议方法。</p>\n<p>下一步，在类扩展中添加一个如下的属性：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) CETableViewBindingHelper *bindingHelper;</div></pre></td></tr></table></figure>\n<p>在同一文件中，删除你之前添加的ViewDidload方法中的内容，然后添加如下代码到ViewDidLoad中：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">  [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">  [<span class=\"keyword\">self</span> bindViewModel];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后，在bindViewModel方法的最后添加如下代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UINib</span> *nib = [<span class=\"built_in\">UINib</span> nibWithNibName:<span class=\"string\">@\"RWTSearchResultsTableViewCell\"</span> bundle:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">self</span>.bindingHelper =</div><div class=\"line\">  [CETableViewBindingHelper bindingHelperForTableView:<span class=\"keyword\">self</span>.searchResultsTable</div><div class=\"line\">                                         sourceSignal:RACObserve(<span class=\"keyword\">self</span>.viewModel, searchResults)</div><div class=\"line\">                                     selectionCommand:<span class=\"literal\">nil</span></div><div class=\"line\">                                         templateCell:nib];</div></pre></td></tr></table></figure>\n<p>上述代码从nib文件中创建了一个UINIb类型的引用，并且创建了一个绑定辅助类的对象。通过观察ViewModel中的searchResults属性来创建一个sourceSignal。</p>\n<p>编译并运行，结果如下：</p>\n<p><img src=\"http://www.raywenderlich.com/wp-content/uploads/2014/06/UsingTheBindingHelper.png\" alt=\"5\"></p>\n<p>这就是一种更加又要的绑定数组到Tableview的方法。</p>\n<h2 id=\"一些UI的个性化\"><a href=\"#一些UI的个性化\" class=\"headerlink\" title=\"一些UI的个性化\"></a>一些UI的个性化</h2><p>到目前为止，这篇教程始终重点叫的都是如何根据MVVM模式构建你的应用程序。我想你已经忍不住想添加一些个性化的东西了。</p>\n<p>自从iOS7发布后，已经过了1年了，<a href=\"http://www.beyondkinetic.com/motion-ui-design-principles\" target=\"_blank\" rel=\"external\">运动设计</a>获得了更大的知名度，许多设计人员现在倾向于微妙的动画和流体行为。</p>\n<p>这一步中，你将在照片上添加一个微妙的视差滚动效果，棒极了。</p>\n<p>打开RWTSearchResultsTableViewCell.h添加如下方法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>) setParallax:(<span class=\"built_in\">CGFloat</span>)value;</div></pre></td></tr></table></figure>\n<p>列表视图的每个Cell将使用这个方法来为每个Cell做视觉偏移。</p>\n<p>打开 RWTSearchResultsTableViewCell.m 文件添加如下代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)setParallax:(<span class=\"built_in\">CGFloat</span>)value &#123;</div><div class=\"line\">  <span class=\"keyword\">self</span>.imageThumbnailView.transform = <span class=\"built_in\">CGAffineTransformMakeTranslation</span>(<span class=\"number\">0</span>, value);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>打开RWTSearchResultsViewController.m导入如下头文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTSearchResultsTableViewCell.h\"</span></span></div></pre></td></tr></table></figure>\n<p>在同一个文件的类扩展中实现UITableViewDelegate的协议，如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">RWTSearchResultsViewController</span> () &lt;<span class=\"title\">UITableViewDataSource</span>, <span class=\"title\">UITableViewDelegate</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>你刚刚添加了一个绑定辅助类，并且把他设置为列表视图的代理，是他可以响应列表中行的选中动作。</p>\n<p>在bindViewModel方法中设置绑定辅助类的代理：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.bindingHelper.delegate = <span class=\"keyword\">self</span>;</div></pre></td></tr></table></figure>\n<p>在同一文件中添加scrollViewDidScroll方法的实现，如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewDidScroll:(<span class=\"built_in\">UIScrollView</span> *)scrollView &#123;</div><div class=\"line\">  <span class=\"built_in\">NSArray</span> *cells = [<span class=\"keyword\">self</span>.searchResultsTable visibleCells];</div><div class=\"line\">  <span class=\"keyword\">for</span> (RWTSearchResultsTableViewCell *cell <span class=\"keyword\">in</span> cells) &#123;</div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> value = <span class=\"number\">-40</span> + (cell.frame.origin.y - <span class=\"keyword\">self</span>.searchResultsTable.contentOffset.y) / <span class=\"number\">5</span>;</div><div class=\"line\">    [cell setParallax:value];</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>每当列表视图滚动时，就会调用这个方法。在这个方法中，遍历所有可见的Cell，然后计算出一个偏移量，然后给每一个Cell设置一个视觉偏移。实际的偏移量将根据每一个Cell在列表视图可见部分的位置而定。</p>\n<p>编译并运行程序，就可以看到一个视差效果。</p>\n<p><img src=\"http://www.raywenderlich.com/wp-content/uploads/2014/06/ParallaxAnimation.gif\" alt=\"5\"></p>\n<p>回到之前Views和ViewModels的工作。</p>\n<h2 id=\"根据评论和点赞数查询\"><a href=\"#根据评论和点赞数查询\" class=\"headerlink\" title=\"根据评论和点赞数查询\"></a>根据评论和点赞数查询</h2><p>界面上应该在每一张图片的底部右侧显示评论数和点赞数。但是，当前从nib创建的文件仅仅只是显示了一个123的假数据。</p>\n<p>在你使用真实数据之前，你需要在模型层添加这个功能。</p>\n<p>在Model文件夹中添加一个新的继承自NSObject的类RWTFlickrPhotoMetadata，打开RWTFlickrPhotoMetadata.h添加如下代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span> favorites;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span> comments;</div></pre></td></tr></table></figure>\n<p>打开 RWTFlickrPhotoMetadata.m实现description方法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)description &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"metadata: comments=%lU, faves=%lU\"</span>,</div><div class=\"line\">          <span class=\"keyword\">self</span>.comments, <span class=\"keyword\">self</span>.favorites];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法用于测试新添加的获取第一张照片的元数据的接口返回的数据是否正确。结果将被打印出来。</p>\n<p>编译并运行，搜索一些照片，当结果显示时，你将看到如下log将被打印出来。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">2014</span><span class=\"number\">-06</span><span class=\"number\">-04</span> <span class=\"number\">07</span>:<span class=\"number\">27</span>:<span class=\"number\">26.813</span> RWTFlickrSearch[<span class=\"number\">76828</span>:<span class=\"number\">70</span>b] metadata: comments=<span class=\"number\">120</span>, faves=<span class=\"number\">434</span></div></pre></td></tr></table></figure>\n<h2 id=\"取得元数据赋给可见的Cell\"><a href=\"#取得元数据赋给可见的Cell\" class=\"headerlink\" title=\"取得元数据赋给可见的Cell\"></a>取得元数据赋给可见的Cell</h2><p>你可以将当前的代码扩展成获取所有搜索结果的元数据。</p>\n<p>但是，如果结果有100张图片，你就要调用200次API接口，每张图片两次。许多API都有一个调用频率限制，这个操作可能会导致API Key被锁定，最少也是暂时不能用。</p>\n<p>其实，你只需要获取到当前在列表视图中显示的几张图片的元数据。因此，你该怎样实现这样的行为呢？你应该已经猜到了，你需要一个可以意识到他是否显示的一个ViewModel。</p>\n<p>当前的RWTSearchResultsViewModel对外暴漏了一个展示在视图上的RWTFlickrPhoto数组的接口，这些模型层的对象会被保留给View。为了能够添加一个可见性的概念，你将把这些在ViewModels里的模型对象封装起来。</p>\n<p>在ViewModel文件夹中添加一个NSObject的子类RWTSearchResultsItemViewModel，打开头文件，添加如下内容：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@import</span> Foundation;</div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTFlickrPhoto.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTViewModelServices.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">RWTSearchResultsItemViewModel</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">instancetype</span>) initWithPhoto:(RWTFlickrPhoto *)photo services:(<span class=\"keyword\">id</span>&lt;RWTViewModelServices&gt;)services;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">BOOL</span> isVisible;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSString</span> *title;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSURL</span> *url;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSNumber</span> *favorites;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSNumber</span> *comments;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>如你所见，这个ViewModel封装了RWTFlickrPhoto模型对象。</p>\n<p>这个ViewModel的属性混合了如下内容：</p>\n<ul>\n<li>对外的模型属性（title，url）</li>\n<li>会动态更新的图像元数据模型（favorites，comments）</li>\n<li>isVisible用来指示ViewModel是否可见或不可见</li>\n</ul>\n<p>打开RWTSearchResultsItemViewModel.m导入如下头文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;ReactiveCocoa/ReactiveCocoa.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;ReactiveCocoa/RACEXTScope.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTFlickrPhotoMetadata.h\"</span></span></div></pre></td></tr></table></figure>\n<p>然后在类扩展中添加如下私有属性：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">RWTSearchResultsItemViewModel</span> ()</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">id</span>&lt;RWTViewModelServices&gt; services;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) RWTFlickrPhoto *photo;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>在同一文件中实现如下方法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithPhoto:(RWTFlickrPhoto *)photo services:(<span class=\"keyword\">id</span>&lt;RWTViewModelServices&gt;)services &#123;</div><div class=\"line\">  <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</div><div class=\"line\">    _title = photo.title;</div><div class=\"line\">    _url = photo.url;</div><div class=\"line\">    _services = services;</div><div class=\"line\">    _photo = photo;</div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">self</span> initialize];</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span>  <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后添加一个initialize方法，注意了，这是关键的地方：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)initialize &#123;</div><div class=\"line\">  RACSignal *fetchMetadata =</div><div class=\"line\">    [RACObserve(<span class=\"keyword\">self</span>, isVisible)</div><div class=\"line\">     filter:^<span class=\"built_in\">BOOL</span>(<span class=\"built_in\">NSNumber</span> *visible) &#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> [visible boolValue];</div><div class=\"line\">     &#125;];</div><div class=\"line\"></div><div class=\"line\">  @weakify(<span class=\"keyword\">self</span>)</div><div class=\"line\">  [fetchMetadata subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">    @strongify(<span class=\"keyword\">self</span>)</div><div class=\"line\">    [[[<span class=\"keyword\">self</span>.services getFlickrSearchService] flickrImageMetadata:<span class=\"keyword\">self</span>.photo.identifier]</div><div class=\"line\">     subscribeNext:^(RWTFlickrPhotoMetadata *x) &#123;</div><div class=\"line\">       <span class=\"keyword\">self</span>.favorites = @(x.favorites);</div><div class=\"line\">       <span class=\"keyword\">self</span>.comments = @(x.comments);</div><div class=\"line\">     &#125;];</div><div class=\"line\">  &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>方法的第一部分创建了一个用于监听isVisible属性的信号fetchMetadate，并且根据isVisible的值进行了过滤。结果就是只有当isVisible为true时这个信号才会发出Next Value。</p>\n<p>接下来一部分就是订阅这个信号以便开始请求flickrImageMetadata方法。当这个内嵌的信号触发Next时，将更新赞数和评论数。</p>\n<p>总的来说，当isVisible为true时，将触发Flickr请求，然后在未来的某个点更新comments和favorites属性。</p>\n<p>为了使这个新的ViewModel能够使用，打开RWTSearchResultsViewModel.m导入如下头文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;LinqToObjectiveC/NSArray+LinqExtensions.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTSearchResultsItemViewModel.h\"</span></span></div></pre></td></tr></table></figure>\n<p>在初始化方法中，删除当前的代码，然后设置_searchResults如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">_searchResults =</div><div class=\"line\">  [results.photos linq_select:^<span class=\"keyword\">id</span>(RWTFlickrPhoto *photo) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> [[RWTSearchResultsItemViewModel alloc]</div><div class=\"line\">              initWithPhoto:photo services:services];</div><div class=\"line\">  &#125;];</div></pre></td></tr></table></figure>\n<p>这段代码将每一个模型对象封装成了一个ViewModel。</p>\n<p>最后一步就是根据视图设置isVisible属性，使得这些新的属性能够生效。</p>\n<p>打开RWTSearchResultsTableViewCell.m添加如下头文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTSearchResultsItemViewModel.h\"</span></span></div></pre></td></tr></table></figure>\n<p>在同一文件中，改变bindViewModel方法的第一行代码，使用新添加的ViewModel。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">RWTSearchResultsItemViewModel *photo = viewModel;</div></pre></td></tr></table></figure>\n<p>在同一方法中添加如下代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">[RACObserve(photo, favorites) subscribeNext:^(<span class=\"built_in\">NSNumber</span> *x) &#123;</div><div class=\"line\">  <span class=\"keyword\">self</span>.favouritesLabel.text = [x stringValue];</div><div class=\"line\">  <span class=\"keyword\">self</span>.favouritesIcon.hidden = (x == <span class=\"literal\">nil</span>);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">[RACObserve(photo, comments) subscribeNext:^(<span class=\"built_in\">NSNumber</span> *x) &#123;</div><div class=\"line\">  <span class=\"keyword\">self</span>.commentsLabel.text = [x stringValue];</div><div class=\"line\">  <span class=\"keyword\">self</span>.commentsIcon.hidden = (x == <span class=\"literal\">nil</span>);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">photo.isVisible = <span class=\"literal\">YES</span>;</div></pre></td></tr></table></figure>\n<p>这样当comments和favorites属性发生变化时，对应的lable以及image也会更新。</p>\n<p>最后一步，设置ViewModel的isVisible为YES。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>终于翻译完了，这是我第一次尝试翻译英文技术文章，前后断断续续用了大概两周的时间，真的很累，说实话，最后完全是为了翻译而去翻译的，而不是为了学习技术而去翻译的。不过这个过程中还是学到了不少东西。以后我还会坚持找一些经典的文章拿来翻译，不过不会翻译这么长的文章了，太累了。</p>\n<p>水平有限，很多地方翻译的不是很通顺，有些句子不知道怎么翻好，干脆就没有翻译，个中错误，以后有空会慢慢纠正。（2016-5-19）</p>\n","excerpt":"","more":"<p>原文地址：<a href=\"https://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2\">MVVM Tutorial with ReactiveCocoa: Part 2/2</a></p>\n<hr>\n<p>MVVM作为一种UI设计模式，正在成为一种非常流行的MVC模式的替代方案。</p>\n<p>在MVVM系列教程的第一部分，你已经了解了ReactiveCocoa是如何将ViewModels和他们各自的的View绑定起来的。</p>\n<p><img src=\"https://cdn5.raywenderlich.com/wp-content/uploads/2014/06/MVVMReactiveCocoa-700x121.png\" alt=\"1\"></p>\n<p>下面是你创建的应用，一个搜索Flickr的APP。</p>\n<p><img src=\"https://cdn3.raywenderlich.com/wp-content/uploads/2014/06/FinishedApp-671x500.png\" alt=\"2\"></p>\n<p>在 MVVM系列教程的第二部分以及最后一部分，你讲学会如果从应用程序的ViewModel中控制ViewController的导航。</p>\n<p>截止目前，你所开发的应用可以通过一个简单的字符串搜索Flickr，如果你需要当前的项目，可以从<a href=\"http://www.raywenderlich.com/wp-content/uploads/2014/06/FlickrSearchPart1Project1.zip\">这里</a>下载</p>\n<p>使用ReactiveCocoa构建的模型层服务提供搜索结果，对应的ViewModel能够简单地打印出响应结果。</p>\n<p>现在，是时候完成跳转到搜索结果界面的任务了。</p>\n<h2 id=\"实现ViewModel导航\"><a href=\"#实现ViewModel导航\" class=\"headerlink\" title=\"实现ViewModel导航\"></a>实现ViewModel导航</h2><p>搜索Flickr成功并返回正确的结果后，应用程序应该跳转到一个新的ViewController并显示这些搜索结果。</p>\n<p>当前应该程序只有单一的一个ViewModel，即RWTFlickrSearchViewModel类。为了达到预期的效果，你应该再创建一个ViewModel来描述返回的搜索结果视图。</p>\n<p>在ViewModel文件夹中一个名为RWTSearchResultsViewModel类，他继承自NSObject。代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@import</span> Foundation;</div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTViewModelServices.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTFlickrSearchResults.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">RWTSearchResultsViewModel</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithSearchResults:(RWTFlickrSearchResults *)results services:(<span class=\"keyword\">id</span>&lt;RWTViewModelServices&gt;)services;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSString</span> *title;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSArray</span> *searchResults;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>上面的代码中添加了一些属性用于描述搜索结果视图，并且声明了一个包含一个RWTFlickrSearchResults参数（返回模型层的服务）的构造方法。</p>\n<p>打开RWTSearchResultsViewModel.m实现以下代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithSearchResults:(RWTFlickrSearchResults *)results services:(<span class=\"keyword\">id</span>&lt;RWTViewModelServices&gt;)services &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</div><div class=\"line\">    _title = results.searchString;</div><div class=\"line\">    _searchResults = results.photos;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样RWTSearchResultsViewModel就完成了。</p>\n<p>回忆第一部分的内容，ViewModel应该在对应的View创建之前就已经创建好了，下面就是要完成各个ViewModel对应了View了。</p>\n<p>打开RWTSearchResultsViewController.h文件，导入对应的ViewModel头文件，并且添加一个初始化方法，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTSearchResultsViewModel.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">RWTSearchResultsViewController</span> : <span class=\"title\">UIViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithViewModel:(RWTSearchResultsViewModel *)viewModel;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>打开RWTSearchResultsViewController.m文件，并且在顶部的类扩展中添加一个私有属性，如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) RWTSearchResultsViewModel *viewModel;</div></pre></td></tr></table></figure>\n<p>进一步完成初始化方法的实现，如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithViewModel:(RWTSearchResultsViewModel *)viewModel &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</div><div class=\"line\">    _viewModel = viewModel;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这一步中，你将关注视图导航是如何工作的。</p>\n<p>你的应用程序现在有两个ViewModel，但是这里你将面临一个难题！我该怎么在视图控制器切换的同时也把对应的ViewModel进行切换。</p>\n<p>ViewModel不能直接持有View的引用，所以，有什么巧妙的方法可以实现这个呢？</p>\n<p>答案已经在RWTViewModelServices协议中展现了。它当前被用来获得一个模型层的引用，你将用这个协议来实现ViewModel的切换。</p>\n<p>打开RWTViewModelServices.h并且添加如下方法到协议中去。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)pushViewModel:(<span class=\"keyword\">id</span>)viewModel;</div></pre></td></tr></table></figure>\n<p>从概念上讲，ViewModel层驱动着整个App，这一层的逻辑决定着界面上会显示什么，以及界面之间切换的方式和时机。</p>\n<p>这个方法允许ViewModel也像UINavigationController那样可以从一个ViewModel以Push的方法切换到另一个ViewModel。</p>\n<p>在实现这个协议之前，你应该先是这个方法在ViewModel层可以工作。</p>\n<p>打开RWTFlickrSearchViewModel.m文件并导入新添加的ViewModel。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTSearchResultsViewModel.h\"</span></span></div></pre></td></tr></table></figure>\n<p>在同一文件更新executeSearchSignal方法的实现，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (RACSignal *)executeSearchSignal &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [[[<span class=\"keyword\">self</span>.services getFlickrSearchService]</div><div class=\"line\">    flickrSearchSignal:<span class=\"keyword\">self</span>.searchText]</div><div class=\"line\">    doNext:^(<span class=\"keyword\">id</span> result) &#123;</div><div class=\"line\">      RWTSearchResultsViewModel *resultsViewModel =</div><div class=\"line\">        [[RWTSearchResultsViewModel alloc] initWithSearchResults:result services:<span class=\"keyword\">self</span>.services];</div><div class=\"line\">      [<span class=\"keyword\">self</span>.services pushViewModel:resultsViewModel];</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码在搜索信号执行过程中添加了一个doNext操作，在doNext的block中创建了一个新的ViewModel来展示搜索结果，然后通过ViewModel的services的push操作切换到这个新的ViewModel上。</p>\n<p>现在，该更新代码，实现这个协议并达到切换ViewModel同时切换ViewController的效果。为了实现这个效果，我们需要在代码中引用导航控制器。</p>\n<p>打开RWTViewModelServicesImpl.h并且添加如下初始化方法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithNavigationController:(<span class=\"built_in\">UINavigationController</span> *)navigationController;</div></pre></td></tr></table></figure>\n<p>打开RWTViewModelServicesImpl.m并且添加下面的头文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTSearchResultsViewController.h\"</span></span></div></pre></td></tr></table></figure>\n<p>然后添加一个私有属性：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">UINavigationController</span> *navigationController;</div></pre></td></tr></table></figure>\n<p>然后在同一个文件完成方法的实现：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithNavigationController:(<span class=\"built_in\">UINavigationController</span> *)navigationController &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</div><div class=\"line\">    _searchService = [RWTFlickrSearchImpl new];</div><div class=\"line\">    _navigationController = navigationController;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述代码用来把传过来的导航控制器引用记录下来。</p>\n<p>最后，添加一个新的方法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)pushViewModel:(<span class=\"keyword\">id</span>)viewModel &#123;</div><div class=\"line\">  <span class=\"keyword\">id</span> viewController;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> ([viewModel isKindOfClass:RWTSearchResultsViewModel.class]) &#123;</div><div class=\"line\">    viewController = [[RWTSearchResultsViewController alloc] initWithViewModel:viewModel];</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"an unknown ViewModel was pushed!\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  [<span class=\"keyword\">self</span>.navigationController pushViewController:viewController animated:<span class=\"literal\">YES</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述代码会根据ViewModel的类型来判断该显示那个视图。</p>\n<p>一般来说，View和ViewModel是一一对应的关系，但是你一定可以举出反例。</p>\n<p>最后一步，打开RWTAppDelegate.m，将createInitialViewController方法中创建RWTViewModelServicesImpl的一行改为如下代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.viewModelServices = [[RWTViewModelServicesImpl alloc] initWithNavigationController:<span class=\"keyword\">self</span>.navigationController];</div></pre></td></tr></table></figure>\n<p>编译并运行程序，输入一个搜索关键字然后点击Go，可以观察到应用程序将切换到一个新的View/ViewModel。</p>\n<p><img src=\"https://cdn4.raywenderlich.com/wp-content/uploads/2014/06/BlankView-281x500.png\" alt=\"3\"></p>\n<p>界面是空白的，别着急，待会你将修复这个问题。</p>\n<p>现在，可以庆祝一下，你已经实现了一个含有多个ViewModel并且可以通过ViewModel来切换界面的应用程序了。</p>\n<blockquote>\n<p>小贴士：John Gossman是一名微软WPF团队的工程师，他创造了MVVM模式。他说测试MVVM的一种方法就是你的应用程序应该脱离UI也可以运行。</p>\n<p>你的应用程序通过了这个测试。如果你不确信，可以通过单元测试来执行一个搜索或从一个ViewModel切换到另一个ViewModel。</p>\n</blockquote>\n<p>现在，你已经有了一个非常纯净的解决方案，下面要开始绑定UI了。</p>\n<h2 id=\"呈现搜索结果列表\"><a href=\"#呈现搜索结果列表\" class=\"headerlink\" title=\"呈现搜索结果列表\"></a>呈现搜索结果列表</h2><p>搜索结果视图控制器RWTSearchResultsViewController在nib中定义了一个UITableview，下一步就是讲ViewModel中的内容展现在这个列表中。</p>\n<p>打开RWTSearchResultsViewController.m，添加一个类扩展，让他实现UITableViewDataSource协议，如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">RWTSearchResultsViewController</span> () &lt;<span class=\"title\">UITableViewDataSource</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在同一文件中重写viewDidLoad方法，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">  [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">  [<span class=\"keyword\">self</span>.searchResultsTable registerClass:<span class=\"built_in\">UITableViewCell</span>.class</div><div class=\"line\">                  forCellReuseIdentifier:<span class=\"string\">@\"cell\"</span>];</div><div class=\"line\">  <span class=\"keyword\">self</span>.searchResultsTable.dataSource = <span class=\"keyword\">self</span>;</div><div class=\"line\"></div><div class=\"line\">  [<span class=\"keyword\">self</span> bindViewModel];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这些操作会在tableview初始化时执行一次，并绑定ViewModel。请忽略上面的Cell Identifier的硬编码，这个待会会删掉。</p>\n<p>然后在同一文件中，添加bindViewModel方法。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)bindViewModel &#123;</div><div class=\"line\">  <span class=\"keyword\">self</span>.title = <span class=\"keyword\">self</span>.viewModel.title;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当前并没有添加太多代码。ViewModel有两个属性，一个是标题，另一个是将要展示在列表中的搜索结果的数组。</p>\n<p>因此，你该如何把这些搜索结果绑定到Tableview上呢？</p>\n<p>ReactiveCocoa可以绑定简单的属性到UIKit上，但是无法处理复杂的Tableview的数据绑定。</p>\n<p>不用焦急，还有其他方法。可以使用传统的代理方法实现。</p>\n<p>在同一文件中，添加如下两个dataSource的代理方法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSInteger</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView</div><div class=\"line\"> numberOfRowsInSection:(<span class=\"built_in\">NSInteger</span>)section &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.viewModel.searchResults.count;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">UITableViewCell</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView</div><div class=\"line\">         cellForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</div><div class=\"line\">  <span class=\"built_in\">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:<span class=\"string\">@\"cell\"</span>];</div><div class=\"line\">  cell.textLabel.text = [<span class=\"keyword\">self</span>.viewModel.searchResults[indexPath.row] title];</div><div class=\"line\">  <span class=\"keyword\">return</span> cell;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第一个方法用来告诉Tableview搜索结果的个数，第二个方法根据ViewModel返回一个相应的Cell。这就够了，不是吗？</p>\n<p>编译并运行程序，就可以看到数据了</p>\n<p><img src=\"https://cdn2.raywenderlich.com/wp-content/uploads/2014/06/PopulatedTable-281x500.png\" alt=\"4\"></p>\n<h2 id=\"更好的Tableview数据绑定方法\"><a href=\"#更好的Tableview数据绑定方法\" class=\"headerlink\" title=\"更好的Tableview数据绑定方法\"></a>更好的Tableview数据绑定方法</h2><p>这种绑定Tableview数据的方法的缺点就是很快就会使视图控制器的代码变得很大。手动绑定数据的方法看起来也不是很优雅。</p>\n<p>这个问题困扰着我，因此我着手解决这个问题。</p>\n<p>从理论上讲，ViewModel的搜索结果数据中的每一项自身也是一个与Cell一一对应的ViewModel。在我的一篇最近的<a href=\"http://www.scottlogic.com/blog/2014/05/11/reactivecocoa-tableview-binding.html\">博客</a>中，我创建了一个通用的绑定辅助类，叫做CETableViewBindingHelper，这个类允许你使用每一个子ViewModel创建一个视图。这个类可以用来辅助实现datasource协议。</p>\n<p>这个CETableViewBindingHelper类的构造方法如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"keyword\">instancetype</span>) bindingHelperForTableView:(<span class=\"built_in\">UITableView</span> *)tableView</div><div class=\"line\">                              sourceSignal:(RACSignal *)source</div><div class=\"line\">                          selectionCommand:(RACCommand *)selection</div><div class=\"line\">                              templateCell:(<span class=\"built_in\">UINib</span> *)templateCellNib;</div></pre></td></tr></table></figure>\n<p>你仅仅只需要创建一个辅助类的引用，就可以用来绑定一个View的数组。这个构造方法的参数如下：</p>\n<ol>\n<li>需要加载ViewModel数组的Tableview</li>\n<li>一个source的信号用来监控数据的变化</li>\n<li>一个在选中一个Cell后要执行的命令</li>\n<li>cell视图的nib</li>\n</ol>\n<p>nib文件定义的Cell必须实现CEReactiveView协议。</p>\n<p>项目中已经包含了一个用于展示搜索结果的Cell视图。打开RWTSearchResultsTableViewCell.h导入协议头文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CEReactiveView.h\"</span></span></div></pre></td></tr></table></figure>\n<p>实现这个协议：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">RWTSearchResultsTableViewCell</span> : <span class=\"title\">UITableViewCell</span> &lt;<span class=\"title\">CEReactiveView</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>下一步就是实现协议方法，打开RWTSearchResultsTableViewCell.m，导入如下内容：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;SDWebImage/UIImageView+WebCache.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTFlickrPhoto.h\"</span></span></div></pre></td></tr></table></figure>\n<p>然后添加如下方法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)bindViewModel:(<span class=\"keyword\">id</span>)viewModel &#123;</div><div class=\"line\">  RWTFlickrPhoto *photo = viewModel;</div><div class=\"line\">  <span class=\"keyword\">self</span>.titleLabel.text = photo.title;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">self</span>.imageThumbnailView.contentMode = <span class=\"built_in\">UIViewContentModeScaleToFill</span>;</div><div class=\"line\"></div><div class=\"line\">  [<span class=\"keyword\">self</span>.imageThumbnailView setImageWithURL:photo.url];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在RWTSearchResultsViewModel的searchResults属性包含了一个RWTFlickrPhoto的引用的数组。</p>\n<p>你刚刚添加的bindViewModel方法中用到了SDWebImage框架，这是一个非常有用的用来在后台加载图片的第三方框架。</p>\n<p>setImageWithURL:是SDWebImage添加的一个UIImageView的分类方法。</p>\n<p>最后一步是用绑定辅助类去展示列表。</p>\n<p>打开RWTSearchResultsViewController.m导入辅助类头文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CETableViewBindingHelper.h\"</span></span></div></pre></td></tr></table></figure>\n<p>在同一文件中删除UITableDataSource协议以及实现的两个协议方法。</p>\n<p>下一步，在类扩展中添加一个如下的属性：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) CETableViewBindingHelper *bindingHelper;</div></pre></td></tr></table></figure>\n<p>在同一文件中，删除你之前添加的ViewDidload方法中的内容，然后添加如下代码到ViewDidLoad中：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">  [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">  [<span class=\"keyword\">self</span> bindViewModel];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后，在bindViewModel方法的最后添加如下代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UINib</span> *nib = [<span class=\"built_in\">UINib</span> nibWithNibName:<span class=\"string\">@\"RWTSearchResultsTableViewCell\"</span> bundle:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">self</span>.bindingHelper =</div><div class=\"line\">  [CETableViewBindingHelper bindingHelperForTableView:<span class=\"keyword\">self</span>.searchResultsTable</div><div class=\"line\">                                         sourceSignal:RACObserve(<span class=\"keyword\">self</span>.viewModel, searchResults)</div><div class=\"line\">                                     selectionCommand:<span class=\"literal\">nil</span></div><div class=\"line\">                                         templateCell:nib];</div></pre></td></tr></table></figure>\n<p>上述代码从nib文件中创建了一个UINIb类型的引用，并且创建了一个绑定辅助类的对象。通过观察ViewModel中的searchResults属性来创建一个sourceSignal。</p>\n<p>编译并运行，结果如下：</p>\n<p><img src=\"http://www.raywenderlich.com/wp-content/uploads/2014/06/UsingTheBindingHelper.png\" alt=\"5\"></p>\n<p>这就是一种更加又要的绑定数组到Tableview的方法。</p>\n<h2 id=\"一些UI的个性化\"><a href=\"#一些UI的个性化\" class=\"headerlink\" title=\"一些UI的个性化\"></a>一些UI的个性化</h2><p>到目前为止，这篇教程始终重点叫的都是如何根据MVVM模式构建你的应用程序。我想你已经忍不住想添加一些个性化的东西了。</p>\n<p>自从iOS7发布后，已经过了1年了，<a href=\"http://www.beyondkinetic.com/motion-ui-design-principles\">运动设计</a>获得了更大的知名度，许多设计人员现在倾向于微妙的动画和流体行为。</p>\n<p>这一步中，你将在照片上添加一个微妙的视差滚动效果，棒极了。</p>\n<p>打开RWTSearchResultsTableViewCell.h添加如下方法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>) setParallax:(<span class=\"built_in\">CGFloat</span>)value;</div></pre></td></tr></table></figure>\n<p>列表视图的每个Cell将使用这个方法来为每个Cell做视觉偏移。</p>\n<p>打开 RWTSearchResultsTableViewCell.m 文件添加如下代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)setParallax:(<span class=\"built_in\">CGFloat</span>)value &#123;</div><div class=\"line\">  <span class=\"keyword\">self</span>.imageThumbnailView.transform = <span class=\"built_in\">CGAffineTransformMakeTranslation</span>(<span class=\"number\">0</span>, value);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>打开RWTSearchResultsViewController.m导入如下头文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTSearchResultsTableViewCell.h\"</span></span></div></pre></td></tr></table></figure>\n<p>在同一个文件的类扩展中实现UITableViewDelegate的协议，如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">RWTSearchResultsViewController</span> () &lt;<span class=\"title\">UITableViewDataSource</span>, <span class=\"title\">UITableViewDelegate</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>你刚刚添加了一个绑定辅助类，并且把他设置为列表视图的代理，是他可以响应列表中行的选中动作。</p>\n<p>在bindViewModel方法中设置绑定辅助类的代理：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.bindingHelper.delegate = <span class=\"keyword\">self</span>;</div></pre></td></tr></table></figure>\n<p>在同一文件中添加scrollViewDidScroll方法的实现，如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewDidScroll:(<span class=\"built_in\">UIScrollView</span> *)scrollView &#123;</div><div class=\"line\">  <span class=\"built_in\">NSArray</span> *cells = [<span class=\"keyword\">self</span>.searchResultsTable visibleCells];</div><div class=\"line\">  <span class=\"keyword\">for</span> (RWTSearchResultsTableViewCell *cell <span class=\"keyword\">in</span> cells) &#123;</div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> value = <span class=\"number\">-40</span> + (cell.frame.origin.y - <span class=\"keyword\">self</span>.searchResultsTable.contentOffset.y) / <span class=\"number\">5</span>;</div><div class=\"line\">    [cell setParallax:value];</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>每当列表视图滚动时，就会调用这个方法。在这个方法中，遍历所有可见的Cell，然后计算出一个偏移量，然后给每一个Cell设置一个视觉偏移。实际的偏移量将根据每一个Cell在列表视图可见部分的位置而定。</p>\n<p>编译并运行程序，就可以看到一个视差效果。</p>\n<p><img src=\"http://www.raywenderlich.com/wp-content/uploads/2014/06/ParallaxAnimation.gif\" alt=\"5\"></p>\n<p>回到之前Views和ViewModels的工作。</p>\n<h2 id=\"根据评论和点赞数查询\"><a href=\"#根据评论和点赞数查询\" class=\"headerlink\" title=\"根据评论和点赞数查询\"></a>根据评论和点赞数查询</h2><p>界面上应该在每一张图片的底部右侧显示评论数和点赞数。但是，当前从nib创建的文件仅仅只是显示了一个123的假数据。</p>\n<p>在你使用真实数据之前，你需要在模型层添加这个功能。</p>\n<p>在Model文件夹中添加一个新的继承自NSObject的类RWTFlickrPhotoMetadata，打开RWTFlickrPhotoMetadata.h添加如下代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span> favorites;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span> comments;</div></pre></td></tr></table></figure>\n<p>打开 RWTFlickrPhotoMetadata.m实现description方法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)description &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"metadata: comments=%lU, faves=%lU\"</span>,</div><div class=\"line\">          <span class=\"keyword\">self</span>.comments, <span class=\"keyword\">self</span>.favorites];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法用于测试新添加的获取第一张照片的元数据的接口返回的数据是否正确。结果将被打印出来。</p>\n<p>编译并运行，搜索一些照片，当结果显示时，你将看到如下log将被打印出来。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">2014</span><span class=\"number\">-06</span><span class=\"number\">-04</span> <span class=\"number\">07</span>:<span class=\"number\">27</span>:<span class=\"number\">26.813</span> RWTFlickrSearch[<span class=\"number\">76828</span>:<span class=\"number\">70</span>b] metadata: comments=<span class=\"number\">120</span>, faves=<span class=\"number\">434</span></div></pre></td></tr></table></figure>\n<h2 id=\"取得元数据赋给可见的Cell\"><a href=\"#取得元数据赋给可见的Cell\" class=\"headerlink\" title=\"取得元数据赋给可见的Cell\"></a>取得元数据赋给可见的Cell</h2><p>你可以将当前的代码扩展成获取所有搜索结果的元数据。</p>\n<p>但是，如果结果有100张图片，你就要调用200次API接口，每张图片两次。许多API都有一个调用频率限制，这个操作可能会导致API Key被锁定，最少也是暂时不能用。</p>\n<p>其实，你只需要获取到当前在列表视图中显示的几张图片的元数据。因此，你该怎样实现这样的行为呢？你应该已经猜到了，你需要一个可以意识到他是否显示的一个ViewModel。</p>\n<p>当前的RWTSearchResultsViewModel对外暴漏了一个展示在视图上的RWTFlickrPhoto数组的接口，这些模型层的对象会被保留给View。为了能够添加一个可见性的概念，你将把这些在ViewModels里的模型对象封装起来。</p>\n<p>在ViewModel文件夹中添加一个NSObject的子类RWTSearchResultsItemViewModel，打开头文件，添加如下内容：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@import</span> Foundation;</div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTFlickrPhoto.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTViewModelServices.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">RWTSearchResultsItemViewModel</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">instancetype</span>) initWithPhoto:(RWTFlickrPhoto *)photo services:(<span class=\"keyword\">id</span>&lt;RWTViewModelServices&gt;)services;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">BOOL</span> isVisible;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSString</span> *title;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSURL</span> *url;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSNumber</span> *favorites;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSNumber</span> *comments;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>如你所见，这个ViewModel封装了RWTFlickrPhoto模型对象。</p>\n<p>这个ViewModel的属性混合了如下内容：</p>\n<ul>\n<li>对外的模型属性（title，url）</li>\n<li>会动态更新的图像元数据模型（favorites，comments）</li>\n<li>isVisible用来指示ViewModel是否可见或不可见</li>\n</ul>\n<p>打开RWTSearchResultsItemViewModel.m导入如下头文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;ReactiveCocoa/ReactiveCocoa.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;ReactiveCocoa/RACEXTScope.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTFlickrPhotoMetadata.h\"</span></span></div></pre></td></tr></table></figure>\n<p>然后在类扩展中添加如下私有属性：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">RWTSearchResultsItemViewModel</span> ()</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">id</span>&lt;RWTViewModelServices&gt; services;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) RWTFlickrPhoto *photo;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>在同一文件中实现如下方法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithPhoto:(RWTFlickrPhoto *)photo services:(<span class=\"keyword\">id</span>&lt;RWTViewModelServices&gt;)services &#123;</div><div class=\"line\">  <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</div><div class=\"line\">    _title = photo.title;</div><div class=\"line\">    _url = photo.url;</div><div class=\"line\">    _services = services;</div><div class=\"line\">    _photo = photo;</div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">self</span> initialize];</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span>  <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后添加一个initialize方法，注意了，这是关键的地方：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)initialize &#123;</div><div class=\"line\">  RACSignal *fetchMetadata =</div><div class=\"line\">    [RACObserve(<span class=\"keyword\">self</span>, isVisible)</div><div class=\"line\">     filter:^<span class=\"built_in\">BOOL</span>(<span class=\"built_in\">NSNumber</span> *visible) &#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> [visible boolValue];</div><div class=\"line\">     &#125;];</div><div class=\"line\"></div><div class=\"line\">  @weakify(<span class=\"keyword\">self</span>)</div><div class=\"line\">  [fetchMetadata subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</div><div class=\"line\">    @strongify(<span class=\"keyword\">self</span>)</div><div class=\"line\">    [[[<span class=\"keyword\">self</span>.services getFlickrSearchService] flickrImageMetadata:<span class=\"keyword\">self</span>.photo.identifier]</div><div class=\"line\">     subscribeNext:^(RWTFlickrPhotoMetadata *x) &#123;</div><div class=\"line\">       <span class=\"keyword\">self</span>.favorites = @(x.favorites);</div><div class=\"line\">       <span class=\"keyword\">self</span>.comments = @(x.comments);</div><div class=\"line\">     &#125;];</div><div class=\"line\">  &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>方法的第一部分创建了一个用于监听isVisible属性的信号fetchMetadate，并且根据isVisible的值进行了过滤。结果就是只有当isVisible为true时这个信号才会发出Next Value。</p>\n<p>接下来一部分就是订阅这个信号以便开始请求flickrImageMetadata方法。当这个内嵌的信号触发Next时，将更新赞数和评论数。</p>\n<p>总的来说，当isVisible为true时，将触发Flickr请求，然后在未来的某个点更新comments和favorites属性。</p>\n<p>为了使这个新的ViewModel能够使用，打开RWTSearchResultsViewModel.m导入如下头文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;LinqToObjectiveC/NSArray+LinqExtensions.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTSearchResultsItemViewModel.h\"</span></span></div></pre></td></tr></table></figure>\n<p>在初始化方法中，删除当前的代码，然后设置_searchResults如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">_searchResults =</div><div class=\"line\">  [results.photos linq_select:^<span class=\"keyword\">id</span>(RWTFlickrPhoto *photo) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> [[RWTSearchResultsItemViewModel alloc]</div><div class=\"line\">              initWithPhoto:photo services:services];</div><div class=\"line\">  &#125;];</div></pre></td></tr></table></figure>\n<p>这段代码将每一个模型对象封装成了一个ViewModel。</p>\n<p>最后一步就是根据视图设置isVisible属性，使得这些新的属性能够生效。</p>\n<p>打开RWTSearchResultsTableViewCell.m添加如下头文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RWTSearchResultsItemViewModel.h\"</span></span></div></pre></td></tr></table></figure>\n<p>在同一文件中，改变bindViewModel方法的第一行代码，使用新添加的ViewModel。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">RWTSearchResultsItemViewModel *photo = viewModel;</div></pre></td></tr></table></figure>\n<p>在同一方法中添加如下代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">[RACObserve(photo, favorites) subscribeNext:^(<span class=\"built_in\">NSNumber</span> *x) &#123;</div><div class=\"line\">  <span class=\"keyword\">self</span>.favouritesLabel.text = [x stringValue];</div><div class=\"line\">  <span class=\"keyword\">self</span>.favouritesIcon.hidden = (x == <span class=\"literal\">nil</span>);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">[RACObserve(photo, comments) subscribeNext:^(<span class=\"built_in\">NSNumber</span> *x) &#123;</div><div class=\"line\">  <span class=\"keyword\">self</span>.commentsLabel.text = [x stringValue];</div><div class=\"line\">  <span class=\"keyword\">self</span>.commentsIcon.hidden = (x == <span class=\"literal\">nil</span>);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">photo.isVisible = <span class=\"literal\">YES</span>;</div></pre></td></tr></table></figure>\n<p>这样当comments和favorites属性发生变化时，对应的lable以及image也会更新。</p>\n<p>最后一步，设置ViewModel的isVisible为YES。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>终于翻译完了，这是我第一次尝试翻译英文技术文章，前后断断续续用了大概两周的时间，真的很累，说实话，最后完全是为了翻译而去翻译的，而不是为了学习技术而去翻译的。不过这个过程中还是学到了不少东西。以后我还会坚持找一些经典的文章拿来翻译，不过不会翻译这么长的文章了，太累了。</p>\n<p>水平有限，很多地方翻译的不是很通顺，有些句子不知道怎么翻好，干脆就没有翻译，个中错误，以后有空会慢慢纠正。（2016-5-19）</p>\n"},{"layout":"post","title":"自定义NSOperation的那些事","_content":"\n最近在项目中负责一个下载模块，使用的是NSOperation+NSOperationQueue实现的，以前总以为自己对NSOperation已经很熟悉了，也写过很多Demo，但是到真正使用的时候，才发现里面还有很多细节的东西自己没有注意到，这篇博客算是对NSOperation的用法的一个总结。比较简单的NSBlockOperation以及NSInvocationOperation就不介绍，本文主要讲解一下自定义NSOperation的方法以及注意事项。\n\n很多技术Blog在介绍自定NSOperation时，思路都是大同小异，大致可以分为一下几步：\n\n1. 创建一个集成自NSOperation的类\n2. 重写NSOperation的main()方法，在main()方法中实现耗时操作\n3. 然后使用时创建自定义的NNSOperation对象，把它添加到NSOperationQueue中，这样就可以自动执行了\n\n其实，这只是自定义NSOperation的一种方法，而且是比较简单的一种方法，不需要自己去控制NSOperation的完成，取消等。另外一种方式是重写NSOperation的start方法，这种方法就需要你自己去控制NSOperation的完成，取消，执行等，而且有许多需要注意的地方。下面着重介绍一些第二种方法。\n\n废话不多说，直接上代码：\n\n```objectivec\n\n#import \"CustomOperation.h\"\n\n@implementation CustomOperation\n\n- (void)start {\n    [NSThread sleepForTimeInterval:3.0];\n    static NSInteger i = 0;\n    NSLog(@\"这是一个耗时操作：%@\", @(++i));\n}\n\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n\n        NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n        queue.maxConcurrentOperationCount = 1;\n\n        CustomOperation *op1 = [[CustomOperation alloc] init];\n        CustomOperation *op2 = [[CustomOperation alloc] init];\n        CustomOperation *op3 = [[CustomOperation alloc] init];\n\n        [queue addOperation:op1];\n        [queue addOperation:op2];\n        [queue addOperation:op3];\n\n        [[NSRunLoop mainRunLoop] run];\n    }\n    return 0;\n}\n```\n\n上述代码创建了一个NSOperation的子类CustomOperation，然后重写了start方法，在start方法中模拟了一个耗时操作，然后在main方法中创建一个NSOperationQueue并添加三个CustomOperation，执行结果是只有op1被执行，op2和op3一直没有被执行。这是因为，一个NSOperationQueue在判断一个Operation是否执行完成的标志是Operation的`- (BOOL)isFinished`方法返回YES，所以这里需要有一个变量来记录当前Operation执行的状态，修改代码，如下：\n\n```objectivec\n#import \"CustomOperation.h\"\n\ntypedef NS_ENUM(NSUInteger, OperationState) {\n    OperationStateReady,\n    OperationStateExecuting,\n    OperationStateFinished,\n};\n\n@interface CustomOperation ()\n\n@property (nonatomic, assign) OperationState state;\n\n@end\n\n@implementation CustomOperation\n\n- (instancetype)init {\n    if (self = [super init]) {\n        _state = OperationStateReady;\n    }\n    return self;\n}\n\n- (BOOL)isFinished {\n    return self.state == OperationStateFinished;\n}\n\n- (void)start {\n    self.state = OperationStateExecuting;\n    [NSThread sleepForTimeInterval:3.0];\n    static NSInteger i = 0;\n    NSLog(@\"这是一个耗时操作：%@\", @(++i));\n    self.state = OperationStateFinished;\n}\n\n@end\n```\n\n这里先定义个一个表示Operation状态的枚举，共有三种状态：\n\n1. OperationStateReady：准备状态，创建Operation后默认就是准备状态\n2. OperationStateExecuting：执行状态，Operation在执行过程中的状态\n3. OperationStateFinished：完成状态，Operation执行完成后的状态\n\n然后在main方法中先将状态置为执行状态，然后在耗时操作执行完后，将状态置为完成状态。有了状态之后，重写NSOperation的`- (BOOL)isFinished`方法，当状态为OperationStateFinished时返回YES，否则返回NO。这样，NSOperationQueue就可以知道操作已经执行完成。运行代码，现在三个Operation就可以按顺序执行了。\n\n继续完善代码\n\n```objectivec\n@implementation CustomOperation\n\n- (instancetype)init {\n    if (self = [super init]) {\n        _state = OperationStateReady;\n    }\n    return self;\n}\n\n- (BOOL)isFinished {\n    return self.state == OperationStateFinished;\n}\n\n- (BOOL)isExecuting {\n    return self.state == OperationStateExecuting;\n}\n\n- (BOOL)isReady {\n    return self.state == OperationStateReady && [super isReady];\n}\n\n- (void)cancel {\n    if (![self isExecuting] && ![self isFinished]) {\n        [super cancel];\n    }\n}\n\n- (void)start {\n\n    if (![self isReady]) {\n        return;\n    }\n\n    if ([self isCancelled]) {\n        return;\n    }\n\n    self.state = OperationStateExecuting;\n    [NSThread sleepForTimeInterval:3.0];\n    static NSInteger i = 0;\n    NSLog(@\"这是一个耗时操作：%@\", @(++i));\n    self.state = OperationStateFinished;\n}\n\n@end\n```\n\n这样，一个重写start方法的自定义NSOperation就完成了，这是CustomOperation支持Cancel操作，测试代码如下：\n\n```objectivec\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n\n        NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n        queue.maxConcurrentOperationCount = 1;\n\n        CustomOperation *op1 = [[CustomOperation alloc] init];\n        CustomOperation *op2 = [[CustomOperation alloc] init];\n        CustomOperation *op3 = [[CustomOperation alloc] init];\n\n        [queue addOperation:op1];\n        [queue addOperation:op2];\n        [queue addOperation:op3];\n\n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n            [op3 cancel];\n        });\n\n        [[NSRunLoop mainRunLoop] run];\n    }\n    return 0;\n}\n```\n\n运行代码，会发现只执行了op1和op2，达到了我们预期的效果。\n\n这就是一个完整的自定义NSOperation的方法，这里的关键点就是那几个状态。\n\n比较一下重写start函数的方法和重写main函数的方法，重写main函数实现起来更加简单，不需要自己控制Operation的状态，但是重写start函数更加灵活，可以根据自己的需求定制不同的状态。更加完善的实现可以参看[AFNetworking](https://github.com/AFNetworking/AFNetworking)的AFURLConnectionOperation实现，里面有很多值得学习的东西。\n\n参考资料：\n[NSOperation](http://nshipster.com/nsoperation/)\n","source":"_posts/2016-05-29-自定义NSOperation的那些事.md","raw":"---\nlayout: post\ntitle: \"自定义NSOperation的那些事\"\ncategories: \"iOS开发\"\n---\n\n最近在项目中负责一个下载模块，使用的是NSOperation+NSOperationQueue实现的，以前总以为自己对NSOperation已经很熟悉了，也写过很多Demo，但是到真正使用的时候，才发现里面还有很多细节的东西自己没有注意到，这篇博客算是对NSOperation的用法的一个总结。比较简单的NSBlockOperation以及NSInvocationOperation就不介绍，本文主要讲解一下自定义NSOperation的方法以及注意事项。\n\n很多技术Blog在介绍自定NSOperation时，思路都是大同小异，大致可以分为一下几步：\n\n1. 创建一个集成自NSOperation的类\n2. 重写NSOperation的main()方法，在main()方法中实现耗时操作\n3. 然后使用时创建自定义的NNSOperation对象，把它添加到NSOperationQueue中，这样就可以自动执行了\n\n其实，这只是自定义NSOperation的一种方法，而且是比较简单的一种方法，不需要自己去控制NSOperation的完成，取消等。另外一种方式是重写NSOperation的start方法，这种方法就需要你自己去控制NSOperation的完成，取消，执行等，而且有许多需要注意的地方。下面着重介绍一些第二种方法。\n\n废话不多说，直接上代码：\n\n```objectivec\n\n#import \"CustomOperation.h\"\n\n@implementation CustomOperation\n\n- (void)start {\n    [NSThread sleepForTimeInterval:3.0];\n    static NSInteger i = 0;\n    NSLog(@\"这是一个耗时操作：%@\", @(++i));\n}\n\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n\n        NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n        queue.maxConcurrentOperationCount = 1;\n\n        CustomOperation *op1 = [[CustomOperation alloc] init];\n        CustomOperation *op2 = [[CustomOperation alloc] init];\n        CustomOperation *op3 = [[CustomOperation alloc] init];\n\n        [queue addOperation:op1];\n        [queue addOperation:op2];\n        [queue addOperation:op3];\n\n        [[NSRunLoop mainRunLoop] run];\n    }\n    return 0;\n}\n```\n\n上述代码创建了一个NSOperation的子类CustomOperation，然后重写了start方法，在start方法中模拟了一个耗时操作，然后在main方法中创建一个NSOperationQueue并添加三个CustomOperation，执行结果是只有op1被执行，op2和op3一直没有被执行。这是因为，一个NSOperationQueue在判断一个Operation是否执行完成的标志是Operation的`- (BOOL)isFinished`方法返回YES，所以这里需要有一个变量来记录当前Operation执行的状态，修改代码，如下：\n\n```objectivec\n#import \"CustomOperation.h\"\n\ntypedef NS_ENUM(NSUInteger, OperationState) {\n    OperationStateReady,\n    OperationStateExecuting,\n    OperationStateFinished,\n};\n\n@interface CustomOperation ()\n\n@property (nonatomic, assign) OperationState state;\n\n@end\n\n@implementation CustomOperation\n\n- (instancetype)init {\n    if (self = [super init]) {\n        _state = OperationStateReady;\n    }\n    return self;\n}\n\n- (BOOL)isFinished {\n    return self.state == OperationStateFinished;\n}\n\n- (void)start {\n    self.state = OperationStateExecuting;\n    [NSThread sleepForTimeInterval:3.0];\n    static NSInteger i = 0;\n    NSLog(@\"这是一个耗时操作：%@\", @(++i));\n    self.state = OperationStateFinished;\n}\n\n@end\n```\n\n这里先定义个一个表示Operation状态的枚举，共有三种状态：\n\n1. OperationStateReady：准备状态，创建Operation后默认就是准备状态\n2. OperationStateExecuting：执行状态，Operation在执行过程中的状态\n3. OperationStateFinished：完成状态，Operation执行完成后的状态\n\n然后在main方法中先将状态置为执行状态，然后在耗时操作执行完后，将状态置为完成状态。有了状态之后，重写NSOperation的`- (BOOL)isFinished`方法，当状态为OperationStateFinished时返回YES，否则返回NO。这样，NSOperationQueue就可以知道操作已经执行完成。运行代码，现在三个Operation就可以按顺序执行了。\n\n继续完善代码\n\n```objectivec\n@implementation CustomOperation\n\n- (instancetype)init {\n    if (self = [super init]) {\n        _state = OperationStateReady;\n    }\n    return self;\n}\n\n- (BOOL)isFinished {\n    return self.state == OperationStateFinished;\n}\n\n- (BOOL)isExecuting {\n    return self.state == OperationStateExecuting;\n}\n\n- (BOOL)isReady {\n    return self.state == OperationStateReady && [super isReady];\n}\n\n- (void)cancel {\n    if (![self isExecuting] && ![self isFinished]) {\n        [super cancel];\n    }\n}\n\n- (void)start {\n\n    if (![self isReady]) {\n        return;\n    }\n\n    if ([self isCancelled]) {\n        return;\n    }\n\n    self.state = OperationStateExecuting;\n    [NSThread sleepForTimeInterval:3.0];\n    static NSInteger i = 0;\n    NSLog(@\"这是一个耗时操作：%@\", @(++i));\n    self.state = OperationStateFinished;\n}\n\n@end\n```\n\n这样，一个重写start方法的自定义NSOperation就完成了，这是CustomOperation支持Cancel操作，测试代码如下：\n\n```objectivec\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n\n        NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n        queue.maxConcurrentOperationCount = 1;\n\n        CustomOperation *op1 = [[CustomOperation alloc] init];\n        CustomOperation *op2 = [[CustomOperation alloc] init];\n        CustomOperation *op3 = [[CustomOperation alloc] init];\n\n        [queue addOperation:op1];\n        [queue addOperation:op2];\n        [queue addOperation:op3];\n\n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n            [op3 cancel];\n        });\n\n        [[NSRunLoop mainRunLoop] run];\n    }\n    return 0;\n}\n```\n\n运行代码，会发现只执行了op1和op2，达到了我们预期的效果。\n\n这就是一个完整的自定义NSOperation的方法，这里的关键点就是那几个状态。\n\n比较一下重写start函数的方法和重写main函数的方法，重写main函数实现起来更加简单，不需要自己控制Operation的状态，但是重写start函数更加灵活，可以根据自己的需求定制不同的状态。更加完善的实现可以参看[AFNetworking](https://github.com/AFNetworking/AFNetworking)的AFURLConnectionOperation实现，里面有很多值得学习的东西。\n\n参考资料：\n[NSOperation](http://nshipster.com/nsoperation/)\n","slug":"自定义NSOperation的那些事","published":1,"date":"2016-05-28T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oabj001nzrm0vkgrh1dm","content":"<p>最近在项目中负责一个下载模块，使用的是NSOperation+NSOperationQueue实现的，以前总以为自己对NSOperation已经很熟悉了，也写过很多Demo，但是到真正使用的时候，才发现里面还有很多细节的东西自己没有注意到，这篇博客算是对NSOperation的用法的一个总结。比较简单的NSBlockOperation以及NSInvocationOperation就不介绍，本文主要讲解一下自定义NSOperation的方法以及注意事项。</p>\n<p>很多技术Blog在介绍自定NSOperation时，思路都是大同小异，大致可以分为一下几步：</p>\n<ol>\n<li>创建一个集成自NSOperation的类</li>\n<li>重写NSOperation的main()方法，在main()方法中实现耗时操作</li>\n<li>然后使用时创建自定义的NNSOperation对象，把它添加到NSOperationQueue中，这样就可以自动执行了</li>\n</ol>\n<p>其实，这只是自定义NSOperation的一种方法，而且是比较简单的一种方法，不需要自己去控制NSOperation的完成，取消等。另外一种方式是重写NSOperation的start方法，这种方法就需要你自己去控制NSOperation的完成，取消，执行等，而且有许多需要注意的地方。下面着重介绍一些第二种方法。</p>\n<p>废话不多说，直接上代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CustomOperation.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">CustomOperation</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)start &#123;</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">3.0</span>];</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"这是一个耗时操作：%@\"</span>, @(++i));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[]) &#123;</div><div class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">NSOperationQueue</span> *queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</div><div class=\"line\">        queue.maxConcurrentOperationCount = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">        CustomOperation *op1 = [[CustomOperation alloc] init];</div><div class=\"line\">        CustomOperation *op2 = [[CustomOperation alloc] init];</div><div class=\"line\">        CustomOperation *op3 = [[CustomOperation alloc] init];</div><div class=\"line\"></div><div class=\"line\">        [queue addOperation:op1];</div><div class=\"line\">        [queue addOperation:op2];</div><div class=\"line\">        [queue addOperation:op3];</div><div class=\"line\"></div><div class=\"line\">        [[<span class=\"built_in\">NSRunLoop</span> mainRunLoop] run];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述代码创建了一个NSOperation的子类CustomOperation，然后重写了start方法，在start方法中模拟了一个耗时操作，然后在main方法中创建一个NSOperationQueue并添加三个CustomOperation，执行结果是只有op1被执行，op2和op3一直没有被执行。这是因为，一个NSOperationQueue在判断一个Operation是否执行完成的标志是Operation的<code>- (BOOL)isFinished</code>方法返回YES，所以这里需要有一个变量来记录当前Operation执行的状态，修改代码，如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CustomOperation.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSUInteger</span>, OperationState) &#123;</div><div class=\"line\">    OperationStateReady,</div><div class=\"line\">    OperationStateExecuting,</div><div class=\"line\">    OperationStateFinished,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CustomOperation</span> ()</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) OperationState state;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">CustomOperation</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)init &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</div><div class=\"line\">        _state = OperationStateReady;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isFinished &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.state == OperationStateFinished;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)start &#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.state = OperationStateExecuting;</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">3.0</span>];</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"这是一个耗时操作：%@\"</span>, @(++i));</div><div class=\"line\">    <span class=\"keyword\">self</span>.state = OperationStateFinished;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>这里先定义个一个表示Operation状态的枚举，共有三种状态：</p>\n<ol>\n<li>OperationStateReady：准备状态，创建Operation后默认就是准备状态</li>\n<li>OperationStateExecuting：执行状态，Operation在执行过程中的状态</li>\n<li>OperationStateFinished：完成状态，Operation执行完成后的状态</li>\n</ol>\n<p>然后在main方法中先将状态置为执行状态，然后在耗时操作执行完后，将状态置为完成状态。有了状态之后，重写NSOperation的<code>- (BOOL)isFinished</code>方法，当状态为OperationStateFinished时返回YES，否则返回NO。这样，NSOperationQueue就可以知道操作已经执行完成。运行代码，现在三个Operation就可以按顺序执行了。</p>\n<p>继续完善代码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">CustomOperation</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)init &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</div><div class=\"line\">        _state = OperationStateReady;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isFinished &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.state == OperationStateFinished;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isExecuting &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.state == OperationStateExecuting;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isReady &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.state == OperationStateReady &amp;&amp; [<span class=\"keyword\">super</span> isReady];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)cancel &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (![<span class=\"keyword\">self</span> isExecuting] &amp;&amp; ![<span class=\"keyword\">self</span> isFinished]) &#123;</div><div class=\"line\">        [<span class=\"keyword\">super</span> cancel];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)start &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (![<span class=\"keyword\">self</span> isReady]) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> isCancelled]) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.state = OperationStateExecuting;</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">3.0</span>];</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"这是一个耗时操作：%@\"</span>, @(++i));</div><div class=\"line\">    <span class=\"keyword\">self</span>.state = OperationStateFinished;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>这样，一个重写start方法的自定义NSOperation就完成了，这是CustomOperation支持Cancel操作，测试代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[]) &#123;</div><div class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">NSOperationQueue</span> *queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</div><div class=\"line\">        queue.maxConcurrentOperationCount = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">        CustomOperation *op1 = [[CustomOperation alloc] init];</div><div class=\"line\">        CustomOperation *op2 = [[CustomOperation alloc] init];</div><div class=\"line\">        CustomOperation *op3 = [[CustomOperation alloc] init];</div><div class=\"line\"></div><div class=\"line\">        [queue addOperation:op1];</div><div class=\"line\">        [queue addOperation:op2];</div><div class=\"line\">        [queue addOperation:op3];</div><div class=\"line\"></div><div class=\"line\">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            [op3 cancel];</div><div class=\"line\">        &#125;);</div><div class=\"line\"></div><div class=\"line\">        [[<span class=\"built_in\">NSRunLoop</span> mainRunLoop] run];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行代码，会发现只执行了op1和op2，达到了我们预期的效果。</p>\n<p>这就是一个完整的自定义NSOperation的方法，这里的关键点就是那几个状态。</p>\n<p>比较一下重写start函数的方法和重写main函数的方法，重写main函数实现起来更加简单，不需要自己控制Operation的状态，但是重写start函数更加灵活，可以根据自己的需求定制不同的状态。更加完善的实现可以参看<a href=\"https://github.com/AFNetworking/AFNetworking\" target=\"_blank\" rel=\"external\">AFNetworking</a>的AFURLConnectionOperation实现，里面有很多值得学习的东西。</p>\n<p>参考资料：<br><a href=\"http://nshipster.com/nsoperation/\" target=\"_blank\" rel=\"external\">NSOperation</a></p>\n","excerpt":"","more":"<p>最近在项目中负责一个下载模块，使用的是NSOperation+NSOperationQueue实现的，以前总以为自己对NSOperation已经很熟悉了，也写过很多Demo，但是到真正使用的时候，才发现里面还有很多细节的东西自己没有注意到，这篇博客算是对NSOperation的用法的一个总结。比较简单的NSBlockOperation以及NSInvocationOperation就不介绍，本文主要讲解一下自定义NSOperation的方法以及注意事项。</p>\n<p>很多技术Blog在介绍自定NSOperation时，思路都是大同小异，大致可以分为一下几步：</p>\n<ol>\n<li>创建一个集成自NSOperation的类</li>\n<li>重写NSOperation的main()方法，在main()方法中实现耗时操作</li>\n<li>然后使用时创建自定义的NNSOperation对象，把它添加到NSOperationQueue中，这样就可以自动执行了</li>\n</ol>\n<p>其实，这只是自定义NSOperation的一种方法，而且是比较简单的一种方法，不需要自己去控制NSOperation的完成，取消等。另外一种方式是重写NSOperation的start方法，这种方法就需要你自己去控制NSOperation的完成，取消，执行等，而且有许多需要注意的地方。下面着重介绍一些第二种方法。</p>\n<p>废话不多说，直接上代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CustomOperation.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">CustomOperation</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)start &#123;</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">3.0</span>];</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"这是一个耗时操作：%@\"</span>, @(++i));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[]) &#123;</div><div class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">NSOperationQueue</span> *queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</div><div class=\"line\">        queue.maxConcurrentOperationCount = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">        CustomOperation *op1 = [[CustomOperation alloc] init];</div><div class=\"line\">        CustomOperation *op2 = [[CustomOperation alloc] init];</div><div class=\"line\">        CustomOperation *op3 = [[CustomOperation alloc] init];</div><div class=\"line\"></div><div class=\"line\">        [queue addOperation:op1];</div><div class=\"line\">        [queue addOperation:op2];</div><div class=\"line\">        [queue addOperation:op3];</div><div class=\"line\"></div><div class=\"line\">        [[<span class=\"built_in\">NSRunLoop</span> mainRunLoop] run];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述代码创建了一个NSOperation的子类CustomOperation，然后重写了start方法，在start方法中模拟了一个耗时操作，然后在main方法中创建一个NSOperationQueue并添加三个CustomOperation，执行结果是只有op1被执行，op2和op3一直没有被执行。这是因为，一个NSOperationQueue在判断一个Operation是否执行完成的标志是Operation的<code>- (BOOL)isFinished</code>方法返回YES，所以这里需要有一个变量来记录当前Operation执行的状态，修改代码，如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CustomOperation.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSUInteger</span>, OperationState) &#123;</div><div class=\"line\">    OperationStateReady,</div><div class=\"line\">    OperationStateExecuting,</div><div class=\"line\">    OperationStateFinished,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CustomOperation</span> ()</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) OperationState state;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">CustomOperation</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)init &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</div><div class=\"line\">        _state = OperationStateReady;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isFinished &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.state == OperationStateFinished;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)start &#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.state = OperationStateExecuting;</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">3.0</span>];</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"这是一个耗时操作：%@\"</span>, @(++i));</div><div class=\"line\">    <span class=\"keyword\">self</span>.state = OperationStateFinished;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>这里先定义个一个表示Operation状态的枚举，共有三种状态：</p>\n<ol>\n<li>OperationStateReady：准备状态，创建Operation后默认就是准备状态</li>\n<li>OperationStateExecuting：执行状态，Operation在执行过程中的状态</li>\n<li>OperationStateFinished：完成状态，Operation执行完成后的状态</li>\n</ol>\n<p>然后在main方法中先将状态置为执行状态，然后在耗时操作执行完后，将状态置为完成状态。有了状态之后，重写NSOperation的<code>- (BOOL)isFinished</code>方法，当状态为OperationStateFinished时返回YES，否则返回NO。这样，NSOperationQueue就可以知道操作已经执行完成。运行代码，现在三个Operation就可以按顺序执行了。</p>\n<p>继续完善代码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">CustomOperation</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)init &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</div><div class=\"line\">        _state = OperationStateReady;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isFinished &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.state == OperationStateFinished;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isExecuting &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.state == OperationStateExecuting;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isReady &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.state == OperationStateReady &amp;&amp; [<span class=\"keyword\">super</span> isReady];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)cancel &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (![<span class=\"keyword\">self</span> isExecuting] &amp;&amp; ![<span class=\"keyword\">self</span> isFinished]) &#123;</div><div class=\"line\">        [<span class=\"keyword\">super</span> cancel];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)start &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (![<span class=\"keyword\">self</span> isReady]) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> isCancelled]) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.state = OperationStateExecuting;</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">3.0</span>];</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"这是一个耗时操作：%@\"</span>, @(++i));</div><div class=\"line\">    <span class=\"keyword\">self</span>.state = OperationStateFinished;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>这样，一个重写start方法的自定义NSOperation就完成了，这是CustomOperation支持Cancel操作，测试代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[]) &#123;</div><div class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">NSOperationQueue</span> *queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</div><div class=\"line\">        queue.maxConcurrentOperationCount = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">        CustomOperation *op1 = [[CustomOperation alloc] init];</div><div class=\"line\">        CustomOperation *op2 = [[CustomOperation alloc] init];</div><div class=\"line\">        CustomOperation *op3 = [[CustomOperation alloc] init];</div><div class=\"line\"></div><div class=\"line\">        [queue addOperation:op1];</div><div class=\"line\">        [queue addOperation:op2];</div><div class=\"line\">        [queue addOperation:op3];</div><div class=\"line\"></div><div class=\"line\">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            [op3 cancel];</div><div class=\"line\">        &#125;);</div><div class=\"line\"></div><div class=\"line\">        [[<span class=\"built_in\">NSRunLoop</span> mainRunLoop] run];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行代码，会发现只执行了op1和op2，达到了我们预期的效果。</p>\n<p>这就是一个完整的自定义NSOperation的方法，这里的关键点就是那几个状态。</p>\n<p>比较一下重写start函数的方法和重写main函数的方法，重写main函数实现起来更加简单，不需要自己控制Operation的状态，但是重写start函数更加灵活，可以根据自己的需求定制不同的状态。更加完善的实现可以参看<a href=\"https://github.com/AFNetworking/AFNetworking\">AFNetworking</a>的AFURLConnectionOperation实现，里面有很多值得学习的东西。</p>\n<p>参考资料：<br><a href=\"http://nshipster.com/nsoperation/\">NSOperation</a></p>\n"},{"layout":"post","title":"2016年6月开发问题记录","_content":"\n继续记录6月份开发中遇到的问题。\n\n## UIBarButtonItem点击区域的问题\n\n今天在定制导航上的返回按钮遇到了一个问题，顺便记录一下。\n\n一般常规的定制导航栏返回按钮的方法如下：\n\n```objectivec\n self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithImage:[UIImage imageNamed:@\"back\"] style:UIBarButtonItemStyleDone target:self action:@selector(clickBackBtn:)];\n```\n\n这样写有一个问题，运行代码后，返回按钮的可点击区域如下图所示：\n\n![1](http://7xn88v.com1.z0.glb.clouddn.com/d869dc4bbc06c476771fc0cfe1b19d49.png)\n\n这并不是我想要的，点击区域太大，完全没有点到返回按钮上都可以触发返回操作。于是换一种思路，用自定义View实现，代码如下：\n\n```objectivec\nUIButton *backBtn = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 30, 44)];\n[backBtn addTarget:self action:@selector(clickBackBtn:) forControlEvents:UIControlEventTouchUpInside];\n[backBtn setImage:[UIImage imageNamed:@\"back\"] forState:UIControlStateNormal];\nself.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithCustomView:backBtn];\n```\n\n编译运行，效果依然一样，点击区域还是太大，如下图：\n\n![2](http://7xn88v.com1.z0.glb.clouddn.com/639a2d998265085ba8f03b4fb3cc6068.png)\n\n这我就不明白了，于是一阵Google，找到了一个解决方案，代码如下：\n\n```objectivec\nUIButton *backBtn = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 30, 44)];\n[backBtn addTarget:self action:@selector(clickBackBtn:) forControlEvents:UIControlEventTouchUpInside];\n[backBtn setImage:[UIImage imageNamed:@\"back\"] forState:UIControlStateNormal];\nUIView *containerView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 30, 44)];\n[containerView addSubview:backBtn];\nself.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithCustomView:containerView];\n```\n\n这样点击区域就正常了，如下图：\n\n![3](http://7xn88v.com1.z0.glb.clouddn.com/0b15b63f3ddab728a7c593154f0083a2.png)\n\n其实就是在Button外面又包了一层View，这样点击区域就只有Button那么大，我怀疑，可能是加载BarButtonItem上的自定义View都会被自动的拉长，暂时还没找到其他解决方案。\n\nReference：[UIBarButtonItem tap area](http://stackoverflow.com/questions/16858433/uibarbuttonitem-tap-area)\n\n## 将自定义对象作为NSDictionary的Key\n\n将自定义对象作为NSDictionary的Key，需要重写自定义isEqual方法和hash方法。isEqual方法比较简单，如下代码：\n\n```objectivec\n- (BOOL)isEqual:(id)object {\n    Student *st = (Student *)object;\n    if ([st.name isEqualToString:self.name] && st.age == self.age) {\n        return YES;\n    }\n    else {\n        return NO;\n    }\n}\n\n```\n\n但是如果要把自定义的对象作为NSDictionary的Key，光重写isEqual方法是不够的，还需要重写hash方法，如果不重写hash方法就会导致字典不能正确的添加和删除。重写hash函数的方法很多，可以通过构建不同散列函数来实现，但是无论哪种方法，目的都是尽可能的确保相同的对象返回的hash值相同，一个简单的方法就是使用每一个属性的hash的异或的结果来作为这个对象的hash值。代码如下：\n\n```objectivec\n- (NSUInteger)hash {\n    return [self.name hash] ^ self.age;\n}\n```\n\n这样构建的hash值冲突的概率很小。另外，要作为字典的Key，还必须实现`NSCopying`协议。因为不需要做深拷贝，所以只需要简单的返回self即可，代码如下：\n\n```objectivec\n- (id)copyWithZone:(NSZone *)zone {\n    return self;\n}\n```\n\n这个构建的一个对象就可以作为NSDictionary的Key了。\n\nReference：[Equality](http://nshipster.com/equality/)\n\n## UITableViewCell的“no index path for table cell being reused”问题\n\n项目中有一个自定义的UITableViewCell，由于版本更新，要把这个Cell改为可以悬停的SectionHeader，为了图方便，我没有重新自定义一个View，而是直接在`viewForHeaderInSection:`方法里返回了cell，代码如下：\n\n```objectivec\nLMBookWriteCommentCell *cell = (LMBookWriteCommentCell *)[self tableView:self.tableView writeCommentCellWithIndexPath:nil];\nreturn cell;\n```\n\n这样写有个问题，就是在reloadData时，这SectionHeader就消失了，变成了空白的一片，并且出现了“no index path for table cell being reused”错误，程序没有崩溃，但是就是看不见Cell上的内容。于是一阵Google，终于找到了答案，只要把上面的代码的`return cell;`改为`return cell.contentView;`就可以了。\n\nReference：[What is the meaning of the “no index path for table cell being reused” message in iOS 6/7?](http://stackoverflow.com/questions/12772197/what-is-the-meaning-of-the-no-index-path-for-table-cell-being-reused-message-i?lq=1)\n\n## Autolayout动画的正确姿势\n\n做Autolayout动画的一般步骤是：\n\n1. 修改约束，如果使用Masonry，使用`mas_updateConstraints`方法修改约束，如果使用Xib，则直接把要修改的约束通过拉线链接到代码里进行修改即可。\n2. 在动画的block中，调用View的`layoutIfNeed()`方法。\n\n这里要注意的一点是第二步，如果直接调用`view.layoutIfNeed()`，可能会导致动画不能进行，正确的方法应该是调用`view.superview.layoutIfNeed()`，这样才能正确的进行动画。完整代码如下：\n\n```objectivec\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var myView: UIView!\n    @IBOutlet weak var topConstraint: NSLayoutConstraint!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n    }\n\n    override func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent?) {\n        topConstraint.constant += 100\n        UIView.animateWithDuration(2.0) {\n            self.myView.superview?.layoutIfNeeded()\n        };\n    }\n}\n```\n\n## 在iOS7上UILabel的省略点颜色不正确\n\n在iOS7上，有时UILabel的省略点的颜色与文字的颜色不同，如下图：\n\n![uilable color error](http://7xn88v.com1.z0.glb.clouddn.com/90fa287185b4062e4c37dd86ac05436b.png)\n\n网上查了一下，这应该是iOS7的一个Bug，解决方法就是不要使用textColor设置文字颜色，而使用attributeText，代码如下：\n\n```objectivec\nNSAttributedString *attStr = [[NSAttributedString alloc] initWithString:self.titleLabel.text attributes:@{NSForegroundColorAttributeName:style.fColor, NSFontAttributeName:style.font}];\nself.titleLabel.attributedText = attStr;\n```\n\n参考：[UILabel dotted line color bug in iOS 7.1](http://stackoverflow.com/questions/22718172/uilabel-dotted-line-color-bug-in-ios-7-1)\n\n## iOS7上，给UICollectionViewCell添加长按手势的坑\n\n项目中有一个需求，当长按任何一个UICollectionViewCell时，刷新UICollectionView，每一个Cell的右上角都出现一个选择按钮。效果如下：\n\n![iOS7 UICollectionView longPress](http://7xn88v.com1.z0.glb.clouddn.com/88e710b25fdcd0403ba7fe2610bd1547.png)\n\n这是一个比较常见的需求，我的做法是在每一个Cell上添加一个长按手势，然后，在手势触发时，刷新这个UICollectionView，然每一个Cell都显示选择按钮。这样做在iOS8，iOS9上都没有问题，当时在iOS7上却出现了问题。在iOS7上，当触发某一个Cell的长按手势之后，这个Cell就不再响应UICollectionView的`collectionView:didSelectItemAtIndexPath:`方法了。\n\n网上没有找到类似的情况，只能自己解决。最终找到了一种解决方案，代码如下：\n\n```objectivec\n// 必须重新放在主线程队列中，否则在iOS7上回出现Cell不触发didSelect的情况\ndispatch_async(dispatch_get_main_queue(), ^{\n    [self.collectionView reloadData];\n});\n```\n\n要将reloadData重新放在主线程队列中，这样就不会出现这种情况。具体原因不是非常明白，但是，这样确实可以完美的解决这个问题。\n","source":"_posts/2016-06-05-2016年6月开发问题记录.md","raw":"---\nlayout: post\ntitle: \"2016年6月开发问题记录\"\ncategories: \"iOS Tips\"\n---\n\n继续记录6月份开发中遇到的问题。\n\n## UIBarButtonItem点击区域的问题\n\n今天在定制导航上的返回按钮遇到了一个问题，顺便记录一下。\n\n一般常规的定制导航栏返回按钮的方法如下：\n\n```objectivec\n self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithImage:[UIImage imageNamed:@\"back\"] style:UIBarButtonItemStyleDone target:self action:@selector(clickBackBtn:)];\n```\n\n这样写有一个问题，运行代码后，返回按钮的可点击区域如下图所示：\n\n![1](http://7xn88v.com1.z0.glb.clouddn.com/d869dc4bbc06c476771fc0cfe1b19d49.png)\n\n这并不是我想要的，点击区域太大，完全没有点到返回按钮上都可以触发返回操作。于是换一种思路，用自定义View实现，代码如下：\n\n```objectivec\nUIButton *backBtn = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 30, 44)];\n[backBtn addTarget:self action:@selector(clickBackBtn:) forControlEvents:UIControlEventTouchUpInside];\n[backBtn setImage:[UIImage imageNamed:@\"back\"] forState:UIControlStateNormal];\nself.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithCustomView:backBtn];\n```\n\n编译运行，效果依然一样，点击区域还是太大，如下图：\n\n![2](http://7xn88v.com1.z0.glb.clouddn.com/639a2d998265085ba8f03b4fb3cc6068.png)\n\n这我就不明白了，于是一阵Google，找到了一个解决方案，代码如下：\n\n```objectivec\nUIButton *backBtn = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 30, 44)];\n[backBtn addTarget:self action:@selector(clickBackBtn:) forControlEvents:UIControlEventTouchUpInside];\n[backBtn setImage:[UIImage imageNamed:@\"back\"] forState:UIControlStateNormal];\nUIView *containerView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 30, 44)];\n[containerView addSubview:backBtn];\nself.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithCustomView:containerView];\n```\n\n这样点击区域就正常了，如下图：\n\n![3](http://7xn88v.com1.z0.glb.clouddn.com/0b15b63f3ddab728a7c593154f0083a2.png)\n\n其实就是在Button外面又包了一层View，这样点击区域就只有Button那么大，我怀疑，可能是加载BarButtonItem上的自定义View都会被自动的拉长，暂时还没找到其他解决方案。\n\nReference：[UIBarButtonItem tap area](http://stackoverflow.com/questions/16858433/uibarbuttonitem-tap-area)\n\n## 将自定义对象作为NSDictionary的Key\n\n将自定义对象作为NSDictionary的Key，需要重写自定义isEqual方法和hash方法。isEqual方法比较简单，如下代码：\n\n```objectivec\n- (BOOL)isEqual:(id)object {\n    Student *st = (Student *)object;\n    if ([st.name isEqualToString:self.name] && st.age == self.age) {\n        return YES;\n    }\n    else {\n        return NO;\n    }\n}\n\n```\n\n但是如果要把自定义的对象作为NSDictionary的Key，光重写isEqual方法是不够的，还需要重写hash方法，如果不重写hash方法就会导致字典不能正确的添加和删除。重写hash函数的方法很多，可以通过构建不同散列函数来实现，但是无论哪种方法，目的都是尽可能的确保相同的对象返回的hash值相同，一个简单的方法就是使用每一个属性的hash的异或的结果来作为这个对象的hash值。代码如下：\n\n```objectivec\n- (NSUInteger)hash {\n    return [self.name hash] ^ self.age;\n}\n```\n\n这样构建的hash值冲突的概率很小。另外，要作为字典的Key，还必须实现`NSCopying`协议。因为不需要做深拷贝，所以只需要简单的返回self即可，代码如下：\n\n```objectivec\n- (id)copyWithZone:(NSZone *)zone {\n    return self;\n}\n```\n\n这个构建的一个对象就可以作为NSDictionary的Key了。\n\nReference：[Equality](http://nshipster.com/equality/)\n\n## UITableViewCell的“no index path for table cell being reused”问题\n\n项目中有一个自定义的UITableViewCell，由于版本更新，要把这个Cell改为可以悬停的SectionHeader，为了图方便，我没有重新自定义一个View，而是直接在`viewForHeaderInSection:`方法里返回了cell，代码如下：\n\n```objectivec\nLMBookWriteCommentCell *cell = (LMBookWriteCommentCell *)[self tableView:self.tableView writeCommentCellWithIndexPath:nil];\nreturn cell;\n```\n\n这样写有个问题，就是在reloadData时，这SectionHeader就消失了，变成了空白的一片，并且出现了“no index path for table cell being reused”错误，程序没有崩溃，但是就是看不见Cell上的内容。于是一阵Google，终于找到了答案，只要把上面的代码的`return cell;`改为`return cell.contentView;`就可以了。\n\nReference：[What is the meaning of the “no index path for table cell being reused” message in iOS 6/7?](http://stackoverflow.com/questions/12772197/what-is-the-meaning-of-the-no-index-path-for-table-cell-being-reused-message-i?lq=1)\n\n## Autolayout动画的正确姿势\n\n做Autolayout动画的一般步骤是：\n\n1. 修改约束，如果使用Masonry，使用`mas_updateConstraints`方法修改约束，如果使用Xib，则直接把要修改的约束通过拉线链接到代码里进行修改即可。\n2. 在动画的block中，调用View的`layoutIfNeed()`方法。\n\n这里要注意的一点是第二步，如果直接调用`view.layoutIfNeed()`，可能会导致动画不能进行，正确的方法应该是调用`view.superview.layoutIfNeed()`，这样才能正确的进行动画。完整代码如下：\n\n```objectivec\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var myView: UIView!\n    @IBOutlet weak var topConstraint: NSLayoutConstraint!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n    }\n\n    override func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent?) {\n        topConstraint.constant += 100\n        UIView.animateWithDuration(2.0) {\n            self.myView.superview?.layoutIfNeeded()\n        };\n    }\n}\n```\n\n## 在iOS7上UILabel的省略点颜色不正确\n\n在iOS7上，有时UILabel的省略点的颜色与文字的颜色不同，如下图：\n\n![uilable color error](http://7xn88v.com1.z0.glb.clouddn.com/90fa287185b4062e4c37dd86ac05436b.png)\n\n网上查了一下，这应该是iOS7的一个Bug，解决方法就是不要使用textColor设置文字颜色，而使用attributeText，代码如下：\n\n```objectivec\nNSAttributedString *attStr = [[NSAttributedString alloc] initWithString:self.titleLabel.text attributes:@{NSForegroundColorAttributeName:style.fColor, NSFontAttributeName:style.font}];\nself.titleLabel.attributedText = attStr;\n```\n\n参考：[UILabel dotted line color bug in iOS 7.1](http://stackoverflow.com/questions/22718172/uilabel-dotted-line-color-bug-in-ios-7-1)\n\n## iOS7上，给UICollectionViewCell添加长按手势的坑\n\n项目中有一个需求，当长按任何一个UICollectionViewCell时，刷新UICollectionView，每一个Cell的右上角都出现一个选择按钮。效果如下：\n\n![iOS7 UICollectionView longPress](http://7xn88v.com1.z0.glb.clouddn.com/88e710b25fdcd0403ba7fe2610bd1547.png)\n\n这是一个比较常见的需求，我的做法是在每一个Cell上添加一个长按手势，然后，在手势触发时，刷新这个UICollectionView，然每一个Cell都显示选择按钮。这样做在iOS8，iOS9上都没有问题，当时在iOS7上却出现了问题。在iOS7上，当触发某一个Cell的长按手势之后，这个Cell就不再响应UICollectionView的`collectionView:didSelectItemAtIndexPath:`方法了。\n\n网上没有找到类似的情况，只能自己解决。最终找到了一种解决方案，代码如下：\n\n```objectivec\n// 必须重新放在主线程队列中，否则在iOS7上回出现Cell不触发didSelect的情况\ndispatch_async(dispatch_get_main_queue(), ^{\n    [self.collectionView reloadData];\n});\n```\n\n要将reloadData重新放在主线程队列中，这样就不会出现这种情况。具体原因不是非常明白，但是，这样确实可以完美的解决这个问题。\n","slug":"2016年6月开发问题记录","published":1,"date":"2016-06-04T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oabl001pzrm086ggpdy6","content":"<p>继续记录6月份开发中遇到的问题。</p>\n<h2 id=\"UIBarButtonItem点击区域的问题\"><a href=\"#UIBarButtonItem点击区域的问题\" class=\"headerlink\" title=\"UIBarButtonItem点击区域的问题\"></a>UIBarButtonItem点击区域的问题</h2><p>今天在定制导航上的返回按钮遇到了一个问题，顺便记录一下。</p>\n<p>一般常规的定制导航栏返回按钮的方法如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.navigationItem.leftBarButtonItem = [[<span class=\"built_in\">UIBarButtonItem</span> alloc] initWithImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"back\"</span>] style:<span class=\"built_in\">UIBarButtonItemStyleDone</span> target:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(clickBackBtn:)];</div></pre></td></tr></table></figure>\n<p>这样写有一个问题，运行代码后，返回按钮的可点击区域如下图所示：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/d869dc4bbc06c476771fc0cfe1b19d49.png\" alt=\"1\"></p>\n<p>这并不是我想要的，点击区域太大，完全没有点到返回按钮上都可以触发返回操作。于是换一种思路，用自定义View实现，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIButton</span> *backBtn = [[<span class=\"built_in\">UIButton</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">30</span>, <span class=\"number\">44</span>)];</div><div class=\"line\">[backBtn addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(clickBackBtn:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\">[backBtn setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"back\"</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</div><div class=\"line\"><span class=\"keyword\">self</span>.navigationItem.leftBarButtonItem = [[<span class=\"built_in\">UIBarButtonItem</span> alloc] initWithCustomView:backBtn];</div></pre></td></tr></table></figure>\n<p>编译运行，效果依然一样，点击区域还是太大，如下图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/639a2d998265085ba8f03b4fb3cc6068.png\" alt=\"2\"></p>\n<p>这我就不明白了，于是一阵Google，找到了一个解决方案，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIButton</span> *backBtn = [[<span class=\"built_in\">UIButton</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">30</span>, <span class=\"number\">44</span>)];</div><div class=\"line\">[backBtn addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(clickBackBtn:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\">[backBtn setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"back\"</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</div><div class=\"line\"><span class=\"built_in\">UIView</span> *containerView = [[<span class=\"built_in\">UIView</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">30</span>, <span class=\"number\">44</span>)];</div><div class=\"line\">[containerView addSubview:backBtn];</div><div class=\"line\"><span class=\"keyword\">self</span>.navigationItem.leftBarButtonItem = [[<span class=\"built_in\">UIBarButtonItem</span> alloc] initWithCustomView:containerView];</div></pre></td></tr></table></figure>\n<p>这样点击区域就正常了，如下图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/0b15b63f3ddab728a7c593154f0083a2.png\" alt=\"3\"></p>\n<p>其实就是在Button外面又包了一层View，这样点击区域就只有Button那么大，我怀疑，可能是加载BarButtonItem上的自定义View都会被自动的拉长，暂时还没找到其他解决方案。</p>\n<p>Reference：<a href=\"http://stackoverflow.com/questions/16858433/uibarbuttonitem-tap-area\" target=\"_blank\" rel=\"external\">UIBarButtonItem tap area</a></p>\n<h2 id=\"将自定义对象作为NSDictionary的Key\"><a href=\"#将自定义对象作为NSDictionary的Key\" class=\"headerlink\" title=\"将自定义对象作为NSDictionary的Key\"></a>将自定义对象作为NSDictionary的Key</h2><p>将自定义对象作为NSDictionary的Key，需要重写自定义isEqual方法和hash方法。isEqual方法比较简单，如下代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isEqual:(<span class=\"keyword\">id</span>)object &#123;</div><div class=\"line\">    Student *st = (Student *)object;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([st.name isEqualToString:<span class=\"keyword\">self</span>.name] &amp;&amp; st.age == <span class=\"keyword\">self</span>.age) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是如果要把自定义的对象作为NSDictionary的Key，光重写isEqual方法是不够的，还需要重写hash方法，如果不重写hash方法就会导致字典不能正确的添加和删除。重写hash函数的方法很多，可以通过构建不同散列函数来实现，但是无论哪种方法，目的都是尽可能的确保相同的对象返回的hash值相同，一个简单的方法就是使用每一个属性的hash的异或的结果来作为这个对象的hash值。代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSUInteger</span>)hash &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span>.name hash] ^ <span class=\"keyword\">self</span>.age;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样构建的hash值冲突的概率很小。另外，要作为字典的Key，还必须实现<code>NSCopying</code>协议。因为不需要做深拷贝，所以只需要简单的返回self即可，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">id</span>)copyWithZone:(<span class=\"built_in\">NSZone</span> *)zone &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个构建的一个对象就可以作为NSDictionary的Key了。</p>\n<p>Reference：<a href=\"http://nshipster.com/equality/\" target=\"_blank\" rel=\"external\">Equality</a></p>\n<h2 id=\"UITableViewCell的“no-index-path-for-table-cell-being-reused”问题\"><a href=\"#UITableViewCell的“no-index-path-for-table-cell-being-reused”问题\" class=\"headerlink\" title=\"UITableViewCell的“no index path for table cell being reused”问题\"></a>UITableViewCell的“no index path for table cell being reused”问题</h2><p>项目中有一个自定义的UITableViewCell，由于版本更新，要把这个Cell改为可以悬停的SectionHeader，为了图方便，我没有重新自定义一个View，而是直接在<code>viewForHeaderInSection:</code>方法里返回了cell，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">LMBookWriteCommentCell *cell = (LMBookWriteCommentCell *)[<span class=\"keyword\">self</span> tableView:<span class=\"keyword\">self</span>.tableView writeCommentCellWithIndexPath:<span class=\"literal\">nil</span>];</div><div class=\"line\"><span class=\"keyword\">return</span> cell;</div></pre></td></tr></table></figure>\n<p>这样写有个问题，就是在reloadData时，这SectionHeader就消失了，变成了空白的一片，并且出现了“no index path for table cell being reused”错误，程序没有崩溃，但是就是看不见Cell上的内容。于是一阵Google，终于找到了答案，只要把上面的代码的<code>return cell;</code>改为<code>return cell.contentView;</code>就可以了。</p>\n<p>Reference：<a href=\"http://stackoverflow.com/questions/12772197/what-is-the-meaning-of-the-no-index-path-for-table-cell-being-reused-message-i?lq=1\" target=\"_blank\" rel=\"external\">What is the meaning of the “no index path for table cell being reused” message in iOS 6/7?</a></p>\n<h2 id=\"Autolayout动画的正确姿势\"><a href=\"#Autolayout动画的正确姿势\" class=\"headerlink\" title=\"Autolayout动画的正确姿势\"></a>Autolayout动画的正确姿势</h2><p>做Autolayout动画的一般步骤是：</p>\n<ol>\n<li>修改约束，如果使用Masonry，使用<code>mas_updateConstraints</code>方法修改约束，如果使用Xib，则直接把要修改的约束通过拉线链接到代码里进行修改即可。</li>\n<li>在动画的block中，调用View的<code>layoutIfNeed()</code>方法。</li>\n</ol>\n<p>这里要注意的一点是第二步，如果直接调用<code>view.layoutIfNeed()</code>，可能会导致动画不能进行，正确的方法应该是调用<code>view.superview.layoutIfNeed()</code>，这样才能正确的进行动画。完整代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> ViewController: <span class=\"built_in\">UIViewController</span> &#123;</div><div class=\"line\"></div><div class=\"line\">    @IBOutlet <span class=\"keyword\">weak</span> var myView: <span class=\"built_in\">UIView</span>!</div><div class=\"line\">    @IBOutlet <span class=\"keyword\">weak</span> var topConstraint: <span class=\"built_in\">NSLayoutConstraint</span>!</div><div class=\"line\"></div><div class=\"line\">    override func viewDidLoad() &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    override func touchesBegan(touches: Set&lt;<span class=\"built_in\">UITouch</span>&gt;, withEvent event: <span class=\"built_in\">UIEvent</span>?) &#123;</div><div class=\"line\">        topConstraint.constant += <span class=\"number\">100</span></div><div class=\"line\">        <span class=\"built_in\">UIView</span>.animateWithDuration(<span class=\"number\">2.0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">self</span>.myView.superview?.layoutIfNeeded()</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"在iOS7上UILabel的省略点颜色不正确\"><a href=\"#在iOS7上UILabel的省略点颜色不正确\" class=\"headerlink\" title=\"在iOS7上UILabel的省略点颜色不正确\"></a>在iOS7上UILabel的省略点颜色不正确</h2><p>在iOS7上，有时UILabel的省略点的颜色与文字的颜色不同，如下图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/90fa287185b4062e4c37dd86ac05436b.png\" alt=\"uilable color error\"></p>\n<p>网上查了一下，这应该是iOS7的一个Bug，解决方法就是不要使用textColor设置文字颜色，而使用attributeText，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSAttributedString</span> *attStr = [[<span class=\"built_in\">NSAttributedString</span> alloc] initWithString:<span class=\"keyword\">self</span>.titleLabel.text attributes:@&#123;<span class=\"built_in\">NSForegroundColorAttributeName</span>:style.fColor, <span class=\"built_in\">NSFontAttributeName</span>:style.font&#125;];</div><div class=\"line\"><span class=\"keyword\">self</span>.titleLabel.attributedText = attStr;</div></pre></td></tr></table></figure>\n<p>参考：<a href=\"http://stackoverflow.com/questions/22718172/uilabel-dotted-line-color-bug-in-ios-7-1\" target=\"_blank\" rel=\"external\">UILabel dotted line color bug in iOS 7.1</a></p>\n<h2 id=\"iOS7上，给UICollectionViewCell添加长按手势的坑\"><a href=\"#iOS7上，给UICollectionViewCell添加长按手势的坑\" class=\"headerlink\" title=\"iOS7上，给UICollectionViewCell添加长按手势的坑\"></a>iOS7上，给UICollectionViewCell添加长按手势的坑</h2><p>项目中有一个需求，当长按任何一个UICollectionViewCell时，刷新UICollectionView，每一个Cell的右上角都出现一个选择按钮。效果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/88e710b25fdcd0403ba7fe2610bd1547.png\" alt=\"iOS7 UICollectionView longPress\"></p>\n<p>这是一个比较常见的需求，我的做法是在每一个Cell上添加一个长按手势，然后，在手势触发时，刷新这个UICollectionView，然每一个Cell都显示选择按钮。这样做在iOS8，iOS9上都没有问题，当时在iOS7上却出现了问题。在iOS7上，当触发某一个Cell的长按手势之后，这个Cell就不再响应UICollectionView的<code>collectionView:didSelectItemAtIndexPath:</code>方法了。</p>\n<p>网上没有找到类似的情况，只能自己解决。最终找到了一种解决方案，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 必须重新放在主线程队列中，否则在iOS7上回出现Cell不触发didSelect的情况</span></div><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.collectionView reloadData];</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>要将reloadData重新放在主线程队列中，这样就不会出现这种情况。具体原因不是非常明白，但是，这样确实可以完美的解决这个问题。</p>\n","excerpt":"","more":"<p>继续记录6月份开发中遇到的问题。</p>\n<h2 id=\"UIBarButtonItem点击区域的问题\"><a href=\"#UIBarButtonItem点击区域的问题\" class=\"headerlink\" title=\"UIBarButtonItem点击区域的问题\"></a>UIBarButtonItem点击区域的问题</h2><p>今天在定制导航上的返回按钮遇到了一个问题，顺便记录一下。</p>\n<p>一般常规的定制导航栏返回按钮的方法如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.navigationItem.leftBarButtonItem = [[<span class=\"built_in\">UIBarButtonItem</span> alloc] initWithImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"back\"</span>] style:<span class=\"built_in\">UIBarButtonItemStyleDone</span> target:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(clickBackBtn:)];</div></pre></td></tr></table></figure>\n<p>这样写有一个问题，运行代码后，返回按钮的可点击区域如下图所示：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/d869dc4bbc06c476771fc0cfe1b19d49.png\" alt=\"1\"></p>\n<p>这并不是我想要的，点击区域太大，完全没有点到返回按钮上都可以触发返回操作。于是换一种思路，用自定义View实现，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIButton</span> *backBtn = [[<span class=\"built_in\">UIButton</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">30</span>, <span class=\"number\">44</span>)];</div><div class=\"line\">[backBtn addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(clickBackBtn:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\">[backBtn setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"back\"</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</div><div class=\"line\"><span class=\"keyword\">self</span>.navigationItem.leftBarButtonItem = [[<span class=\"built_in\">UIBarButtonItem</span> alloc] initWithCustomView:backBtn];</div></pre></td></tr></table></figure>\n<p>编译运行，效果依然一样，点击区域还是太大，如下图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/639a2d998265085ba8f03b4fb3cc6068.png\" alt=\"2\"></p>\n<p>这我就不明白了，于是一阵Google，找到了一个解决方案，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIButton</span> *backBtn = [[<span class=\"built_in\">UIButton</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">30</span>, <span class=\"number\">44</span>)];</div><div class=\"line\">[backBtn addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(clickBackBtn:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\">[backBtn setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"back\"</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</div><div class=\"line\"><span class=\"built_in\">UIView</span> *containerView = [[<span class=\"built_in\">UIView</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">30</span>, <span class=\"number\">44</span>)];</div><div class=\"line\">[containerView addSubview:backBtn];</div><div class=\"line\"><span class=\"keyword\">self</span>.navigationItem.leftBarButtonItem = [[<span class=\"built_in\">UIBarButtonItem</span> alloc] initWithCustomView:containerView];</div></pre></td></tr></table></figure>\n<p>这样点击区域就正常了，如下图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/0b15b63f3ddab728a7c593154f0083a2.png\" alt=\"3\"></p>\n<p>其实就是在Button外面又包了一层View，这样点击区域就只有Button那么大，我怀疑，可能是加载BarButtonItem上的自定义View都会被自动的拉长，暂时还没找到其他解决方案。</p>\n<p>Reference：<a href=\"http://stackoverflow.com/questions/16858433/uibarbuttonitem-tap-area\">UIBarButtonItem tap area</a></p>\n<h2 id=\"将自定义对象作为NSDictionary的Key\"><a href=\"#将自定义对象作为NSDictionary的Key\" class=\"headerlink\" title=\"将自定义对象作为NSDictionary的Key\"></a>将自定义对象作为NSDictionary的Key</h2><p>将自定义对象作为NSDictionary的Key，需要重写自定义isEqual方法和hash方法。isEqual方法比较简单，如下代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isEqual:(<span class=\"keyword\">id</span>)object &#123;</div><div class=\"line\">    Student *st = (Student *)object;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([st.name isEqualToString:<span class=\"keyword\">self</span>.name] &amp;&amp; st.age == <span class=\"keyword\">self</span>.age) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是如果要把自定义的对象作为NSDictionary的Key，光重写isEqual方法是不够的，还需要重写hash方法，如果不重写hash方法就会导致字典不能正确的添加和删除。重写hash函数的方法很多，可以通过构建不同散列函数来实现，但是无论哪种方法，目的都是尽可能的确保相同的对象返回的hash值相同，一个简单的方法就是使用每一个属性的hash的异或的结果来作为这个对象的hash值。代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSUInteger</span>)hash &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span>.name hash] ^ <span class=\"keyword\">self</span>.age;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样构建的hash值冲突的概率很小。另外，要作为字典的Key，还必须实现<code>NSCopying</code>协议。因为不需要做深拷贝，所以只需要简单的返回self即可，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">id</span>)copyWithZone:(<span class=\"built_in\">NSZone</span> *)zone &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个构建的一个对象就可以作为NSDictionary的Key了。</p>\n<p>Reference：<a href=\"http://nshipster.com/equality/\">Equality</a></p>\n<h2 id=\"UITableViewCell的“no-index-path-for-table-cell-being-reused”问题\"><a href=\"#UITableViewCell的“no-index-path-for-table-cell-being-reused”问题\" class=\"headerlink\" title=\"UITableViewCell的“no index path for table cell being reused”问题\"></a>UITableViewCell的“no index path for table cell being reused”问题</h2><p>项目中有一个自定义的UITableViewCell，由于版本更新，要把这个Cell改为可以悬停的SectionHeader，为了图方便，我没有重新自定义一个View，而是直接在<code>viewForHeaderInSection:</code>方法里返回了cell，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">LMBookWriteCommentCell *cell = (LMBookWriteCommentCell *)[<span class=\"keyword\">self</span> tableView:<span class=\"keyword\">self</span>.tableView writeCommentCellWithIndexPath:<span class=\"literal\">nil</span>];</div><div class=\"line\"><span class=\"keyword\">return</span> cell;</div></pre></td></tr></table></figure>\n<p>这样写有个问题，就是在reloadData时，这SectionHeader就消失了，变成了空白的一片，并且出现了“no index path for table cell being reused”错误，程序没有崩溃，但是就是看不见Cell上的内容。于是一阵Google，终于找到了答案，只要把上面的代码的<code>return cell;</code>改为<code>return cell.contentView;</code>就可以了。</p>\n<p>Reference：<a href=\"http://stackoverflow.com/questions/12772197/what-is-the-meaning-of-the-no-index-path-for-table-cell-being-reused-message-i?lq=1\">What is the meaning of the “no index path for table cell being reused” message in iOS 6/7?</a></p>\n<h2 id=\"Autolayout动画的正确姿势\"><a href=\"#Autolayout动画的正确姿势\" class=\"headerlink\" title=\"Autolayout动画的正确姿势\"></a>Autolayout动画的正确姿势</h2><p>做Autolayout动画的一般步骤是：</p>\n<ol>\n<li>修改约束，如果使用Masonry，使用<code>mas_updateConstraints</code>方法修改约束，如果使用Xib，则直接把要修改的约束通过拉线链接到代码里进行修改即可。</li>\n<li>在动画的block中，调用View的<code>layoutIfNeed()</code>方法。</li>\n</ol>\n<p>这里要注意的一点是第二步，如果直接调用<code>view.layoutIfNeed()</code>，可能会导致动画不能进行，正确的方法应该是调用<code>view.superview.layoutIfNeed()</code>，这样才能正确的进行动画。完整代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> ViewController: <span class=\"built_in\">UIViewController</span> &#123;</div><div class=\"line\"></div><div class=\"line\">    @IBOutlet <span class=\"keyword\">weak</span> var myView: <span class=\"built_in\">UIView</span>!</div><div class=\"line\">    @IBOutlet <span class=\"keyword\">weak</span> var topConstraint: <span class=\"built_in\">NSLayoutConstraint</span>!</div><div class=\"line\"></div><div class=\"line\">    override func viewDidLoad() &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    override func touchesBegan(touches: Set&lt;<span class=\"built_in\">UITouch</span>&gt;, withEvent event: <span class=\"built_in\">UIEvent</span>?) &#123;</div><div class=\"line\">        topConstraint.constant += <span class=\"number\">100</span></div><div class=\"line\">        <span class=\"built_in\">UIView</span>.animateWithDuration(<span class=\"number\">2.0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">self</span>.myView.superview?.layoutIfNeeded()</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"在iOS7上UILabel的省略点颜色不正确\"><a href=\"#在iOS7上UILabel的省略点颜色不正确\" class=\"headerlink\" title=\"在iOS7上UILabel的省略点颜色不正确\"></a>在iOS7上UILabel的省略点颜色不正确</h2><p>在iOS7上，有时UILabel的省略点的颜色与文字的颜色不同，如下图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/90fa287185b4062e4c37dd86ac05436b.png\" alt=\"uilable color error\"></p>\n<p>网上查了一下，这应该是iOS7的一个Bug，解决方法就是不要使用textColor设置文字颜色，而使用attributeText，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSAttributedString</span> *attStr = [[<span class=\"built_in\">NSAttributedString</span> alloc] initWithString:<span class=\"keyword\">self</span>.titleLabel.text attributes:@&#123;<span class=\"built_in\">NSForegroundColorAttributeName</span>:style.fColor, <span class=\"built_in\">NSFontAttributeName</span>:style.font&#125;];</div><div class=\"line\"><span class=\"keyword\">self</span>.titleLabel.attributedText = attStr;</div></pre></td></tr></table></figure>\n<p>参考：<a href=\"http://stackoverflow.com/questions/22718172/uilabel-dotted-line-color-bug-in-ios-7-1\">UILabel dotted line color bug in iOS 7.1</a></p>\n<h2 id=\"iOS7上，给UICollectionViewCell添加长按手势的坑\"><a href=\"#iOS7上，给UICollectionViewCell添加长按手势的坑\" class=\"headerlink\" title=\"iOS7上，给UICollectionViewCell添加长按手势的坑\"></a>iOS7上，给UICollectionViewCell添加长按手势的坑</h2><p>项目中有一个需求，当长按任何一个UICollectionViewCell时，刷新UICollectionView，每一个Cell的右上角都出现一个选择按钮。效果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/88e710b25fdcd0403ba7fe2610bd1547.png\" alt=\"iOS7 UICollectionView longPress\"></p>\n<p>这是一个比较常见的需求，我的做法是在每一个Cell上添加一个长按手势，然后，在手势触发时，刷新这个UICollectionView，然每一个Cell都显示选择按钮。这样做在iOS8，iOS9上都没有问题，当时在iOS7上却出现了问题。在iOS7上，当触发某一个Cell的长按手势之后，这个Cell就不再响应UICollectionView的<code>collectionView:didSelectItemAtIndexPath:</code>方法了。</p>\n<p>网上没有找到类似的情况，只能自己解决。最终找到了一种解决方案，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 必须重新放在主线程队列中，否则在iOS7上回出现Cell不触发didSelect的情况</span></div><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.collectionView reloadData];</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>要将reloadData重新放在主线程队列中，这样就不会出现这种情况。具体原因不是非常明白，但是，这样确实可以完美的解决这个问题。</p>\n"},{"layout":"post","title":"打造自己的翻墙VPS:搬运工VPS购买使用流程全记录","_content":"\n端午节在家无聊，买了一个VPS，打算做翻墙用，下面是我购买和使用的一个流程全集了，主要以截图为主，文字为辅。\n\n我选的VPS是[搬运工](https://bandwagonhost.com/index.php)，因为网上教程比较多，而且支持支付宝支付（实际证明支付宝支付就是个坑）。\n\n## 第一步：购买搬运工VPS\n\n打开[搬运工](https://bandwagonhost.com/index.php)官网，点击Home\n\n![1](http://7xn88v.com1.z0.glb.clouddn.com/bed44e502ad30c6337a757df1096eb42.png)\n\n选择一个套餐，点击OrderNow，出现了一个错误界面，没关系，继续点击Please Check...\n\n![2](http://7xn88v.com1.z0.glb.clouddn.com/6521ec84ff41c1c28efcbaf55195b41b.png)\n\n往下拉，选择一个套餐，显示out of stock是已经售罄的，选择一个没有售罄的，点击Order Now（便宜的都卖完了😭😭）\n\n![3](http://7xn88v.com1.z0.glb.clouddn.com/4d0c8ffde0ee4fabd1619a2f76cd142d.png)\n\n我选的是4.99$每月的套餐，然后选择计费周期和机房地址，计费周期有每月，每季度，每半年，每年，机房地址如果开通后觉得速度慢可以换的，选择完成后，点击Add to Cart\n\n![4](http://7xn88v.com1.z0.glb.clouddn.com/df89863eb89691d23f8ede6df91474ac.png)\n\n填写优惠码（如果有的话），然后点击CheckOut提交订单\n\n![5](http://7xn88v.com1.z0.glb.clouddn.com/22185a6765ad03c3c490039547b1a6f9.png)\n\n填写支付信息，可以选择支付宝支付，然后点击Complete Order完成订单\n\n![6](http://7xn88v.com1.z0.glb.clouddn.com/c52d6ec41f2fe7306d95fe02c150ff3c.png)\n\n然后，点击PayNow\n\n![7](http://7xn88v.com1.z0.glb.clouddn.com/8c5c7146ebeae385a78a0d2ff4f41d50.png)\n\n点了好几遍，使用没反应，最后无奈，只能使用PayPal（坑！！）\n\n![8](http://7xn88v.com1.z0.glb.clouddn.com/5044a701d5863fb3df75cde054e40bf1.png)\n\n然后登陆PayPal，确认订单，支付就可了。支付完成后，返回搬运工，可以看到一个订单号，这就说明订单已经完成了。\n\n![9](http://7xn88v.com1.z0.glb.clouddn.com/b1919f5edb17005e107f2cda76ea6543.png)\n\n## 第二步：如何使用搬运工\n\n* 查看主机\n\n![10](http://7xn88v.com1.z0.glb.clouddn.com/0d844d6592095394205b3ec705c27c07.png)\n\n![11](http://7xn88v.com1.z0.glb.clouddn.com/519dd5c39986045804589fb1c2037bc1.png)\n\n![12](http://7xn88v.com1.z0.glb.clouddn.com/32ba5f9b92493a7fae77e566ffeb1899.png)\n\n* 管理我的VPS，点击KiwiVM..进入管理界面，这里可以查看服务器的状态，以及进行各种管理操作，具体操作方法可以参考最后我的两篇博客链接。\n\n![13](http://7xn88v.com1.z0.glb.clouddn.com/765e9238bfc53b4d7efcf7eddadc1713.png)\n\n## 第三步：一键安装shadowsocks（搬运工这个功能太赞啦）\n\n进入管理界面，然后点击Shadowsocks Server，然后点击Install Sh...\n\n![14](http://7xn88v.com1.z0.glb.clouddn.com/6c277b288f658f0f46b49692ad44cd07.png)\n\n安装完成后，点击返回，就可以看到你的SS的端口和密码\n\n![15](http://7xn88v.com1.z0.glb.clouddn.com/cf4d5ded8facbea9375c69e1736db8b7.png)\n\n然后跟着上图的“What‘s Next”后面的内容，安装并配置Shadowsocks，就可以使用了。\n\n以上就是这个购买和使用VPS的流程，希望对大家有所帮助。\n\nReference:\n[https://blog.phpgao.com/vps.html](https://blog.phpgao.com/vps.html)\n[http://www.jianshu.com/p/2f51144c35c9](http://www.jianshu.com/p/2f51144c35c9)\n","source":"_posts/2016-06-11-打造自己的翻墙VPS:搬运工VPS购买使用流程全记录.md","raw":"---\nlayout: post\ntitle: \"打造自己的翻墙VPS:搬运工VPS购买使用流程全记录\"\ncategories: \"其他\"\n---\n\n端午节在家无聊，买了一个VPS，打算做翻墙用，下面是我购买和使用的一个流程全集了，主要以截图为主，文字为辅。\n\n我选的VPS是[搬运工](https://bandwagonhost.com/index.php)，因为网上教程比较多，而且支持支付宝支付（实际证明支付宝支付就是个坑）。\n\n## 第一步：购买搬运工VPS\n\n打开[搬运工](https://bandwagonhost.com/index.php)官网，点击Home\n\n![1](http://7xn88v.com1.z0.glb.clouddn.com/bed44e502ad30c6337a757df1096eb42.png)\n\n选择一个套餐，点击OrderNow，出现了一个错误界面，没关系，继续点击Please Check...\n\n![2](http://7xn88v.com1.z0.glb.clouddn.com/6521ec84ff41c1c28efcbaf55195b41b.png)\n\n往下拉，选择一个套餐，显示out of stock是已经售罄的，选择一个没有售罄的，点击Order Now（便宜的都卖完了😭😭）\n\n![3](http://7xn88v.com1.z0.glb.clouddn.com/4d0c8ffde0ee4fabd1619a2f76cd142d.png)\n\n我选的是4.99$每月的套餐，然后选择计费周期和机房地址，计费周期有每月，每季度，每半年，每年，机房地址如果开通后觉得速度慢可以换的，选择完成后，点击Add to Cart\n\n![4](http://7xn88v.com1.z0.glb.clouddn.com/df89863eb89691d23f8ede6df91474ac.png)\n\n填写优惠码（如果有的话），然后点击CheckOut提交订单\n\n![5](http://7xn88v.com1.z0.glb.clouddn.com/22185a6765ad03c3c490039547b1a6f9.png)\n\n填写支付信息，可以选择支付宝支付，然后点击Complete Order完成订单\n\n![6](http://7xn88v.com1.z0.glb.clouddn.com/c52d6ec41f2fe7306d95fe02c150ff3c.png)\n\n然后，点击PayNow\n\n![7](http://7xn88v.com1.z0.glb.clouddn.com/8c5c7146ebeae385a78a0d2ff4f41d50.png)\n\n点了好几遍，使用没反应，最后无奈，只能使用PayPal（坑！！）\n\n![8](http://7xn88v.com1.z0.glb.clouddn.com/5044a701d5863fb3df75cde054e40bf1.png)\n\n然后登陆PayPal，确认订单，支付就可了。支付完成后，返回搬运工，可以看到一个订单号，这就说明订单已经完成了。\n\n![9](http://7xn88v.com1.z0.glb.clouddn.com/b1919f5edb17005e107f2cda76ea6543.png)\n\n## 第二步：如何使用搬运工\n\n* 查看主机\n\n![10](http://7xn88v.com1.z0.glb.clouddn.com/0d844d6592095394205b3ec705c27c07.png)\n\n![11](http://7xn88v.com1.z0.glb.clouddn.com/519dd5c39986045804589fb1c2037bc1.png)\n\n![12](http://7xn88v.com1.z0.glb.clouddn.com/32ba5f9b92493a7fae77e566ffeb1899.png)\n\n* 管理我的VPS，点击KiwiVM..进入管理界面，这里可以查看服务器的状态，以及进行各种管理操作，具体操作方法可以参考最后我的两篇博客链接。\n\n![13](http://7xn88v.com1.z0.glb.clouddn.com/765e9238bfc53b4d7efcf7eddadc1713.png)\n\n## 第三步：一键安装shadowsocks（搬运工这个功能太赞啦）\n\n进入管理界面，然后点击Shadowsocks Server，然后点击Install Sh...\n\n![14](http://7xn88v.com1.z0.glb.clouddn.com/6c277b288f658f0f46b49692ad44cd07.png)\n\n安装完成后，点击返回，就可以看到你的SS的端口和密码\n\n![15](http://7xn88v.com1.z0.glb.clouddn.com/cf4d5ded8facbea9375c69e1736db8b7.png)\n\n然后跟着上图的“What‘s Next”后面的内容，安装并配置Shadowsocks，就可以使用了。\n\n以上就是这个购买和使用VPS的流程，希望对大家有所帮助。\n\nReference:\n[https://blog.phpgao.com/vps.html](https://blog.phpgao.com/vps.html)\n[http://www.jianshu.com/p/2f51144c35c9](http://www.jianshu.com/p/2f51144c35c9)\n","slug":"打造自己的翻墙VPS:搬运工VPS购买使用流程全记录","published":1,"date":"2016-06-10T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oabn001rzrm00dmwmd7z","content":"<p>端午节在家无聊，买了一个VPS，打算做翻墙用，下面是我购买和使用的一个流程全集了，主要以截图为主，文字为辅。</p>\n<p>我选的VPS是<a href=\"https://bandwagonhost.com/index.php\" target=\"_blank\" rel=\"external\">搬运工</a>，因为网上教程比较多，而且支持支付宝支付（实际证明支付宝支付就是个坑）。</p>\n<h2 id=\"第一步：购买搬运工VPS\"><a href=\"#第一步：购买搬运工VPS\" class=\"headerlink\" title=\"第一步：购买搬运工VPS\"></a>第一步：购买搬运工VPS</h2><p>打开<a href=\"https://bandwagonhost.com/index.php\" target=\"_blank\" rel=\"external\">搬运工</a>官网，点击Home</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/bed44e502ad30c6337a757df1096eb42.png\" alt=\"1\"></p>\n<p>选择一个套餐，点击OrderNow，出现了一个错误界面，没关系，继续点击Please Check…</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/6521ec84ff41c1c28efcbaf55195b41b.png\" alt=\"2\"></p>\n<p>往下拉，选择一个套餐，显示out of stock是已经售罄的，选择一个没有售罄的，点击Order Now（便宜的都卖完了😭😭）</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/4d0c8ffde0ee4fabd1619a2f76cd142d.png\" alt=\"3\"></p>\n<p>我选的是4.99$每月的套餐，然后选择计费周期和机房地址，计费周期有每月，每季度，每半年，每年，机房地址如果开通后觉得速度慢可以换的，选择完成后，点击Add to Cart</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/df89863eb89691d23f8ede6df91474ac.png\" alt=\"4\"></p>\n<p>填写优惠码（如果有的话），然后点击CheckOut提交订单</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/22185a6765ad03c3c490039547b1a6f9.png\" alt=\"5\"></p>\n<p>填写支付信息，可以选择支付宝支付，然后点击Complete Order完成订单</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/c52d6ec41f2fe7306d95fe02c150ff3c.png\" alt=\"6\"></p>\n<p>然后，点击PayNow</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/8c5c7146ebeae385a78a0d2ff4f41d50.png\" alt=\"7\"></p>\n<p>点了好几遍，使用没反应，最后无奈，只能使用PayPal（坑！！）</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/5044a701d5863fb3df75cde054e40bf1.png\" alt=\"8\"></p>\n<p>然后登陆PayPal，确认订单，支付就可了。支付完成后，返回搬运工，可以看到一个订单号，这就说明订单已经完成了。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/b1919f5edb17005e107f2cda76ea6543.png\" alt=\"9\"></p>\n<h2 id=\"第二步：如何使用搬运工\"><a href=\"#第二步：如何使用搬运工\" class=\"headerlink\" title=\"第二步：如何使用搬运工\"></a>第二步：如何使用搬运工</h2><ul>\n<li>查看主机</li>\n</ul>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/0d844d6592095394205b3ec705c27c07.png\" alt=\"10\"></p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/519dd5c39986045804589fb1c2037bc1.png\" alt=\"11\"></p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/32ba5f9b92493a7fae77e566ffeb1899.png\" alt=\"12\"></p>\n<ul>\n<li>管理我的VPS，点击KiwiVM..进入管理界面，这里可以查看服务器的状态，以及进行各种管理操作，具体操作方法可以参考最后我的两篇博客链接。</li>\n</ul>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/765e9238bfc53b4d7efcf7eddadc1713.png\" alt=\"13\"></p>\n<h2 id=\"第三步：一键安装shadowsocks（搬运工这个功能太赞啦）\"><a href=\"#第三步：一键安装shadowsocks（搬运工这个功能太赞啦）\" class=\"headerlink\" title=\"第三步：一键安装shadowsocks（搬运工这个功能太赞啦）\"></a>第三步：一键安装shadowsocks（搬运工这个功能太赞啦）</h2><p>进入管理界面，然后点击Shadowsocks Server，然后点击Install Sh…</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/6c277b288f658f0f46b49692ad44cd07.png\" alt=\"14\"></p>\n<p>安装完成后，点击返回，就可以看到你的SS的端口和密码</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/cf4d5ded8facbea9375c69e1736db8b7.png\" alt=\"15\"></p>\n<p>然后跟着上图的“What‘s Next”后面的内容，安装并配置Shadowsocks，就可以使用了。</p>\n<p>以上就是这个购买和使用VPS的流程，希望对大家有所帮助。</p>\n<p>Reference:<br><a href=\"https://blog.phpgao.com/vps.html\" target=\"_blank\" rel=\"external\">https://blog.phpgao.com/vps.html</a><br><a href=\"http://www.jianshu.com/p/2f51144c35c9\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/2f51144c35c9</a></p>\n","excerpt":"","more":"<p>端午节在家无聊，买了一个VPS，打算做翻墙用，下面是我购买和使用的一个流程全集了，主要以截图为主，文字为辅。</p>\n<p>我选的VPS是<a href=\"https://bandwagonhost.com/index.php\">搬运工</a>，因为网上教程比较多，而且支持支付宝支付（实际证明支付宝支付就是个坑）。</p>\n<h2 id=\"第一步：购买搬运工VPS\"><a href=\"#第一步：购买搬运工VPS\" class=\"headerlink\" title=\"第一步：购买搬运工VPS\"></a>第一步：购买搬运工VPS</h2><p>打开<a href=\"https://bandwagonhost.com/index.php\">搬运工</a>官网，点击Home</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/bed44e502ad30c6337a757df1096eb42.png\" alt=\"1\"></p>\n<p>选择一个套餐，点击OrderNow，出现了一个错误界面，没关系，继续点击Please Check…</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/6521ec84ff41c1c28efcbaf55195b41b.png\" alt=\"2\"></p>\n<p>往下拉，选择一个套餐，显示out of stock是已经售罄的，选择一个没有售罄的，点击Order Now（便宜的都卖完了😭😭）</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/4d0c8ffde0ee4fabd1619a2f76cd142d.png\" alt=\"3\"></p>\n<p>我选的是4.99$每月的套餐，然后选择计费周期和机房地址，计费周期有每月，每季度，每半年，每年，机房地址如果开通后觉得速度慢可以换的，选择完成后，点击Add to Cart</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/df89863eb89691d23f8ede6df91474ac.png\" alt=\"4\"></p>\n<p>填写优惠码（如果有的话），然后点击CheckOut提交订单</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/22185a6765ad03c3c490039547b1a6f9.png\" alt=\"5\"></p>\n<p>填写支付信息，可以选择支付宝支付，然后点击Complete Order完成订单</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/c52d6ec41f2fe7306d95fe02c150ff3c.png\" alt=\"6\"></p>\n<p>然后，点击PayNow</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/8c5c7146ebeae385a78a0d2ff4f41d50.png\" alt=\"7\"></p>\n<p>点了好几遍，使用没反应，最后无奈，只能使用PayPal（坑！！）</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/5044a701d5863fb3df75cde054e40bf1.png\" alt=\"8\"></p>\n<p>然后登陆PayPal，确认订单，支付就可了。支付完成后，返回搬运工，可以看到一个订单号，这就说明订单已经完成了。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/b1919f5edb17005e107f2cda76ea6543.png\" alt=\"9\"></p>\n<h2 id=\"第二步：如何使用搬运工\"><a href=\"#第二步：如何使用搬运工\" class=\"headerlink\" title=\"第二步：如何使用搬运工\"></a>第二步：如何使用搬运工</h2><ul>\n<li>查看主机</li>\n</ul>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/0d844d6592095394205b3ec705c27c07.png\" alt=\"10\"></p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/519dd5c39986045804589fb1c2037bc1.png\" alt=\"11\"></p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/32ba5f9b92493a7fae77e566ffeb1899.png\" alt=\"12\"></p>\n<ul>\n<li>管理我的VPS，点击KiwiVM..进入管理界面，这里可以查看服务器的状态，以及进行各种管理操作，具体操作方法可以参考最后我的两篇博客链接。</li>\n</ul>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/765e9238bfc53b4d7efcf7eddadc1713.png\" alt=\"13\"></p>\n<h2 id=\"第三步：一键安装shadowsocks（搬运工这个功能太赞啦）\"><a href=\"#第三步：一键安装shadowsocks（搬运工这个功能太赞啦）\" class=\"headerlink\" title=\"第三步：一键安装shadowsocks（搬运工这个功能太赞啦）\"></a>第三步：一键安装shadowsocks（搬运工这个功能太赞啦）</h2><p>进入管理界面，然后点击Shadowsocks Server，然后点击Install Sh…</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/6c277b288f658f0f46b49692ad44cd07.png\" alt=\"14\"></p>\n<p>安装完成后，点击返回，就可以看到你的SS的端口和密码</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/cf4d5ded8facbea9375c69e1736db8b7.png\" alt=\"15\"></p>\n<p>然后跟着上图的“What‘s Next”后面的内容，安装并配置Shadowsocks，就可以使用了。</p>\n<p>以上就是这个购买和使用VPS的流程，希望对大家有所帮助。</p>\n<p>Reference:<br><a href=\"https://blog.phpgao.com/vps.html\">https://blog.phpgao.com/vps.html</a><br><a href=\"http://www.jianshu.com/p/2f51144c35c9\">http://www.jianshu.com/p/2f51144c35c9</a></p>\n"},{"layout":"post","title":"GMTC全球移动技术大会见闻","_content":"\n6月24日至6月25日，我有幸参加了“GMTC全球移动技术大会”，这篇博客就是我对参见会议的一个经历和感受。\n\n![1](http://7xn88v.com1.z0.glb.clouddn.com/457acda7bd3dc65f172468c45dad4a8f.png)\n\n### 第一天上午\n\n会议共分为两天，第一天上午是主会场，首先是主办方开场致辞，然后是京东，阿里和微信的三个技术负责人的演讲，主要讲了移动开发的现状以及未来的一些趋势，没有涉及到具体的技术。\n\n接下来是Facebook的一个前员工分享了”Facebook iOS App技术演化10年”，讲到了很多有意思的地方，这里令我印象比较深刻的是Facebook一共有1000+的iOS工程师，这个iOS App的代码行数超过1000万行，同时他也分享了Facebook App演化过程中走过的一些完了，例如H5，CoreData等。\n\n接下来也是一个硅谷的iOS开发者分享了“Mobile Growth 的方法和实践”，由于之前从来没有接触过Growth，所以听的也是一知半解，感觉与产品运营更相关。这就是第一天早上的整个会议。\n\n### 第一天下午\n\n从第一天的下午开始，就开始分了几个分会场进行具体的技术分享。第一天下午有三个分会场，分别是动态化，Swift和新技术专场。\n\n我先是听了”函数式编程中的Swift与Swift中的函数式编程”，分享者是SwiftyJSON的作者，由于之前在使用RAC时已经接触过函数式编程，所以这个并不陌生，整个演讲主要是分享了函数式编程的一些思想。\n\n接下来我有听了“RN项目实战优化之路”，由于之前从来没接触过ReactNative，所有听得也是云里雾里，听到一半就跑去听”JSPatch成长之路”。\n\nJSPatch目前是当前比较热门的一种iOS热修复技术，演讲者就是JSPatch的作者，他分享了整个JSPatch发展过程中遇到的问题以及解决方案，很佩服作者为了推广JSPatch而做的各项工作，包括代码转换工具、XCode插件、JSPatch平台等等，这些工作极大地促进了JSPatch的推广使用，有机会我一定要尝试一下JSPatch。\n\n听完了JSPatch，我又去听了“当泛型遇上协议”，是猿题库的iOS负责人做的分享，之前看过他写的关于Swift的博客，演讲中，作者通过具体的代码分享自己在Swift的协议与泛型上的实践经验，如果能把泛型使用好确实能极大地简化自己的代码。\n\n最后我又听了”聚划算iOS平台动态化方案LuaView”，分享者是阿里聚划算的技术专家，LuaView提供了一种使用Lua脚本动态更新App的方案，演讲者讲解了LuaView的基本原理、使用以及对LuaView未来发展的一些规划。\n\n这样，第一天的会议就结束了。\n\n### 第二天上午\n\n第二天上午也有三个分会场，分别是架构演进、VR/AR、移动解决方案。\n\n我先听了“360°全景视频播放器的实现原理”，演讲者是阿里的高级iOS工程师，分享了如何使用OpenGL实现全景视频播放，以前从来没有接触过这一块，所以听得也是迷迷糊糊。VR/AR目前是是一个很火的方向，但还处于发展的初期，不过有机会还是值得尝试尝试。\n\n接下来我又听了一段“手机天猫解耦之路”，我是中间进去的，会场挤满了人，分享者讲的东西也是干货满满。演讲嘉宾是天猫的无线技术专家，我听的那一块正好讲到了一种界面间解耦的思路，使用URL Server来实现界面间跳转。\n\n接下来又听了滴滴的iOS负责人分享的“滴滴的组件化实践与优化”，主要讲到了滴滴iOS端在发展中遇到的问题以及解决方案，重点讲了滴滴组件化的经历，也是干货满满。后面提到的灰度发布对我们目前的项目很有参考价值。\n\n后面又听了“iOS遗留系统上的架构重构”，是一名来自澳洲的iOS工程师分享的，主要分享了自己是如何在遗留的代码上，把数据存储从CoreData迁移到Realm并且没有影响正常迭代的经历，使用的是抽象分支+特性开关，也非常有参考价值。\n\n### 第二天下午\n\n第二天下午有两个分会场，分别是性能优化专场和应用架构专场。\n\n我先听了“美团 iOS 客户端的构建思考与实践”，分享者是美团的高级工程师，主要讲了美团APP iOS客户端的架构，以及集成和发布中遇到的问题和一些实践经验。分享了一些持续集成的经验，目前我们项目中还没有用到持续集成，所有这一块也不是很了解，不过很多东西还是值得借鉴和尝试的。\n\n后面我又听了来自微博的美女架构师分享的“微博复杂信息流的架构之道”，分享中提到的隔周发版也是一种很好的实践方式。\n\n### 总结\n\n总体来说这次GMTC大会还是收获很多的，学习到了业界一些最新最热的技术和思想，非常感谢公司能给我这次机会。\n\n最后，由于第一次去北京，当然少不了要到处逛逛。\n\n![2](http://7xn88v.com1.z0.glb.clouddn.com/9088bb3373fad1444a78921cb8c8172f.png)\n\n![3](http://7xn88v.com1.z0.glb.clouddn.com/5a0e1b3dac94502a08f70de2f14bee22.png)\n","source":"_posts/2016-06-29-GMTC全球移动技术大会见闻.md","raw":"---\nlayout: post\ntitle: \"GMTC全球移动技术大会见闻\"\ncategories: \"其他\"\n---\n\n6月24日至6月25日，我有幸参加了“GMTC全球移动技术大会”，这篇博客就是我对参见会议的一个经历和感受。\n\n![1](http://7xn88v.com1.z0.glb.clouddn.com/457acda7bd3dc65f172468c45dad4a8f.png)\n\n### 第一天上午\n\n会议共分为两天，第一天上午是主会场，首先是主办方开场致辞，然后是京东，阿里和微信的三个技术负责人的演讲，主要讲了移动开发的现状以及未来的一些趋势，没有涉及到具体的技术。\n\n接下来是Facebook的一个前员工分享了”Facebook iOS App技术演化10年”，讲到了很多有意思的地方，这里令我印象比较深刻的是Facebook一共有1000+的iOS工程师，这个iOS App的代码行数超过1000万行，同时他也分享了Facebook App演化过程中走过的一些完了，例如H5，CoreData等。\n\n接下来也是一个硅谷的iOS开发者分享了“Mobile Growth 的方法和实践”，由于之前从来没有接触过Growth，所以听的也是一知半解，感觉与产品运营更相关。这就是第一天早上的整个会议。\n\n### 第一天下午\n\n从第一天的下午开始，就开始分了几个分会场进行具体的技术分享。第一天下午有三个分会场，分别是动态化，Swift和新技术专场。\n\n我先是听了”函数式编程中的Swift与Swift中的函数式编程”，分享者是SwiftyJSON的作者，由于之前在使用RAC时已经接触过函数式编程，所以这个并不陌生，整个演讲主要是分享了函数式编程的一些思想。\n\n接下来我有听了“RN项目实战优化之路”，由于之前从来没接触过ReactNative，所有听得也是云里雾里，听到一半就跑去听”JSPatch成长之路”。\n\nJSPatch目前是当前比较热门的一种iOS热修复技术，演讲者就是JSPatch的作者，他分享了整个JSPatch发展过程中遇到的问题以及解决方案，很佩服作者为了推广JSPatch而做的各项工作，包括代码转换工具、XCode插件、JSPatch平台等等，这些工作极大地促进了JSPatch的推广使用，有机会我一定要尝试一下JSPatch。\n\n听完了JSPatch，我又去听了“当泛型遇上协议”，是猿题库的iOS负责人做的分享，之前看过他写的关于Swift的博客，演讲中，作者通过具体的代码分享自己在Swift的协议与泛型上的实践经验，如果能把泛型使用好确实能极大地简化自己的代码。\n\n最后我又听了”聚划算iOS平台动态化方案LuaView”，分享者是阿里聚划算的技术专家，LuaView提供了一种使用Lua脚本动态更新App的方案，演讲者讲解了LuaView的基本原理、使用以及对LuaView未来发展的一些规划。\n\n这样，第一天的会议就结束了。\n\n### 第二天上午\n\n第二天上午也有三个分会场，分别是架构演进、VR/AR、移动解决方案。\n\n我先听了“360°全景视频播放器的实现原理”，演讲者是阿里的高级iOS工程师，分享了如何使用OpenGL实现全景视频播放，以前从来没有接触过这一块，所以听得也是迷迷糊糊。VR/AR目前是是一个很火的方向，但还处于发展的初期，不过有机会还是值得尝试尝试。\n\n接下来我又听了一段“手机天猫解耦之路”，我是中间进去的，会场挤满了人，分享者讲的东西也是干货满满。演讲嘉宾是天猫的无线技术专家，我听的那一块正好讲到了一种界面间解耦的思路，使用URL Server来实现界面间跳转。\n\n接下来又听了滴滴的iOS负责人分享的“滴滴的组件化实践与优化”，主要讲到了滴滴iOS端在发展中遇到的问题以及解决方案，重点讲了滴滴组件化的经历，也是干货满满。后面提到的灰度发布对我们目前的项目很有参考价值。\n\n后面又听了“iOS遗留系统上的架构重构”，是一名来自澳洲的iOS工程师分享的，主要分享了自己是如何在遗留的代码上，把数据存储从CoreData迁移到Realm并且没有影响正常迭代的经历，使用的是抽象分支+特性开关，也非常有参考价值。\n\n### 第二天下午\n\n第二天下午有两个分会场，分别是性能优化专场和应用架构专场。\n\n我先听了“美团 iOS 客户端的构建思考与实践”，分享者是美团的高级工程师，主要讲了美团APP iOS客户端的架构，以及集成和发布中遇到的问题和一些实践经验。分享了一些持续集成的经验，目前我们项目中还没有用到持续集成，所有这一块也不是很了解，不过很多东西还是值得借鉴和尝试的。\n\n后面我又听了来自微博的美女架构师分享的“微博复杂信息流的架构之道”，分享中提到的隔周发版也是一种很好的实践方式。\n\n### 总结\n\n总体来说这次GMTC大会还是收获很多的，学习到了业界一些最新最热的技术和思想，非常感谢公司能给我这次机会。\n\n最后，由于第一次去北京，当然少不了要到处逛逛。\n\n![2](http://7xn88v.com1.z0.glb.clouddn.com/9088bb3373fad1444a78921cb8c8172f.png)\n\n![3](http://7xn88v.com1.z0.glb.clouddn.com/5a0e1b3dac94502a08f70de2f14bee22.png)\n","slug":"GMTC全球移动技术大会见闻","published":1,"date":"2016-06-28T16:00:00.000Z","updated":"2016-08-12T15:20:04.000Z","comments":1,"photos":[],"link":"","_id":"cis94oabr001tzrm0dhp8w9fn","content":"<p>6月24日至6月25日，我有幸参加了“GMTC全球移动技术大会”，这篇博客就是我对参见会议的一个经历和感受。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/457acda7bd3dc65f172468c45dad4a8f.png\" alt=\"1\"></p>\n<h3 id=\"第一天上午\"><a href=\"#第一天上午\" class=\"headerlink\" title=\"第一天上午\"></a>第一天上午</h3><p>会议共分为两天，第一天上午是主会场，首先是主办方开场致辞，然后是京东，阿里和微信的三个技术负责人的演讲，主要讲了移动开发的现状以及未来的一些趋势，没有涉及到具体的技术。</p>\n<p>接下来是Facebook的一个前员工分享了”Facebook iOS App技术演化10年”，讲到了很多有意思的地方，这里令我印象比较深刻的是Facebook一共有1000+的iOS工程师，这个iOS App的代码行数超过1000万行，同时他也分享了Facebook App演化过程中走过的一些完了，例如H5，CoreData等。</p>\n<p>接下来也是一个硅谷的iOS开发者分享了“Mobile Growth 的方法和实践”，由于之前从来没有接触过Growth，所以听的也是一知半解，感觉与产品运营更相关。这就是第一天早上的整个会议。</p>\n<h3 id=\"第一天下午\"><a href=\"#第一天下午\" class=\"headerlink\" title=\"第一天下午\"></a>第一天下午</h3><p>从第一天的下午开始，就开始分了几个分会场进行具体的技术分享。第一天下午有三个分会场，分别是动态化，Swift和新技术专场。</p>\n<p>我先是听了”函数式编程中的Swift与Swift中的函数式编程”，分享者是SwiftyJSON的作者，由于之前在使用RAC时已经接触过函数式编程，所以这个并不陌生，整个演讲主要是分享了函数式编程的一些思想。</p>\n<p>接下来我有听了“RN项目实战优化之路”，由于之前从来没接触过ReactNative，所有听得也是云里雾里，听到一半就跑去听”JSPatch成长之路”。</p>\n<p>JSPatch目前是当前比较热门的一种iOS热修复技术，演讲者就是JSPatch的作者，他分享了整个JSPatch发展过程中遇到的问题以及解决方案，很佩服作者为了推广JSPatch而做的各项工作，包括代码转换工具、XCode插件、JSPatch平台等等，这些工作极大地促进了JSPatch的推广使用，有机会我一定要尝试一下JSPatch。</p>\n<p>听完了JSPatch，我又去听了“当泛型遇上协议”，是猿题库的iOS负责人做的分享，之前看过他写的关于Swift的博客，演讲中，作者通过具体的代码分享自己在Swift的协议与泛型上的实践经验，如果能把泛型使用好确实能极大地简化自己的代码。</p>\n<p>最后我又听了”聚划算iOS平台动态化方案LuaView”，分享者是阿里聚划算的技术专家，LuaView提供了一种使用Lua脚本动态更新App的方案，演讲者讲解了LuaView的基本原理、使用以及对LuaView未来发展的一些规划。</p>\n<p>这样，第一天的会议就结束了。</p>\n<h3 id=\"第二天上午\"><a href=\"#第二天上午\" class=\"headerlink\" title=\"第二天上午\"></a>第二天上午</h3><p>第二天上午也有三个分会场，分别是架构演进、VR/AR、移动解决方案。</p>\n<p>我先听了“360°全景视频播放器的实现原理”，演讲者是阿里的高级iOS工程师，分享了如何使用OpenGL实现全景视频播放，以前从来没有接触过这一块，所以听得也是迷迷糊糊。VR/AR目前是是一个很火的方向，但还处于发展的初期，不过有机会还是值得尝试尝试。</p>\n<p>接下来我又听了一段“手机天猫解耦之路”，我是中间进去的，会场挤满了人，分享者讲的东西也是干货满满。演讲嘉宾是天猫的无线技术专家，我听的那一块正好讲到了一种界面间解耦的思路，使用URL Server来实现界面间跳转。</p>\n<p>接下来又听了滴滴的iOS负责人分享的“滴滴的组件化实践与优化”，主要讲到了滴滴iOS端在发展中遇到的问题以及解决方案，重点讲了滴滴组件化的经历，也是干货满满。后面提到的灰度发布对我们目前的项目很有参考价值。</p>\n<p>后面又听了“iOS遗留系统上的架构重构”，是一名来自澳洲的iOS工程师分享的，主要分享了自己是如何在遗留的代码上，把数据存储从CoreData迁移到Realm并且没有影响正常迭代的经历，使用的是抽象分支+特性开关，也非常有参考价值。</p>\n<h3 id=\"第二天下午\"><a href=\"#第二天下午\" class=\"headerlink\" title=\"第二天下午\"></a>第二天下午</h3><p>第二天下午有两个分会场，分别是性能优化专场和应用架构专场。</p>\n<p>我先听了“美团 iOS 客户端的构建思考与实践”，分享者是美团的高级工程师，主要讲了美团APP iOS客户端的架构，以及集成和发布中遇到的问题和一些实践经验。分享了一些持续集成的经验，目前我们项目中还没有用到持续集成，所有这一块也不是很了解，不过很多东西还是值得借鉴和尝试的。</p>\n<p>后面我又听了来自微博的美女架构师分享的“微博复杂信息流的架构之道”，分享中提到的隔周发版也是一种很好的实践方式。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>总体来说这次GMTC大会还是收获很多的，学习到了业界一些最新最热的技术和思想，非常感谢公司能给我这次机会。</p>\n<p>最后，由于第一次去北京，当然少不了要到处逛逛。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/9088bb3373fad1444a78921cb8c8172f.png\" alt=\"2\"></p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/5a0e1b3dac94502a08f70de2f14bee22.png\" alt=\"3\"></p>\n","excerpt":"","more":"<p>6月24日至6月25日，我有幸参加了“GMTC全球移动技术大会”，这篇博客就是我对参见会议的一个经历和感受。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/457acda7bd3dc65f172468c45dad4a8f.png\" alt=\"1\"></p>\n<h3 id=\"第一天上午\"><a href=\"#第一天上午\" class=\"headerlink\" title=\"第一天上午\"></a>第一天上午</h3><p>会议共分为两天，第一天上午是主会场，首先是主办方开场致辞，然后是京东，阿里和微信的三个技术负责人的演讲，主要讲了移动开发的现状以及未来的一些趋势，没有涉及到具体的技术。</p>\n<p>接下来是Facebook的一个前员工分享了”Facebook iOS App技术演化10年”，讲到了很多有意思的地方，这里令我印象比较深刻的是Facebook一共有1000+的iOS工程师，这个iOS App的代码行数超过1000万行，同时他也分享了Facebook App演化过程中走过的一些完了，例如H5，CoreData等。</p>\n<p>接下来也是一个硅谷的iOS开发者分享了“Mobile Growth 的方法和实践”，由于之前从来没有接触过Growth，所以听的也是一知半解，感觉与产品运营更相关。这就是第一天早上的整个会议。</p>\n<h3 id=\"第一天下午\"><a href=\"#第一天下午\" class=\"headerlink\" title=\"第一天下午\"></a>第一天下午</h3><p>从第一天的下午开始，就开始分了几个分会场进行具体的技术分享。第一天下午有三个分会场，分别是动态化，Swift和新技术专场。</p>\n<p>我先是听了”函数式编程中的Swift与Swift中的函数式编程”，分享者是SwiftyJSON的作者，由于之前在使用RAC时已经接触过函数式编程，所以这个并不陌生，整个演讲主要是分享了函数式编程的一些思想。</p>\n<p>接下来我有听了“RN项目实战优化之路”，由于之前从来没接触过ReactNative，所有听得也是云里雾里，听到一半就跑去听”JSPatch成长之路”。</p>\n<p>JSPatch目前是当前比较热门的一种iOS热修复技术，演讲者就是JSPatch的作者，他分享了整个JSPatch发展过程中遇到的问题以及解决方案，很佩服作者为了推广JSPatch而做的各项工作，包括代码转换工具、XCode插件、JSPatch平台等等，这些工作极大地促进了JSPatch的推广使用，有机会我一定要尝试一下JSPatch。</p>\n<p>听完了JSPatch，我又去听了“当泛型遇上协议”，是猿题库的iOS负责人做的分享，之前看过他写的关于Swift的博客，演讲中，作者通过具体的代码分享自己在Swift的协议与泛型上的实践经验，如果能把泛型使用好确实能极大地简化自己的代码。</p>\n<p>最后我又听了”聚划算iOS平台动态化方案LuaView”，分享者是阿里聚划算的技术专家，LuaView提供了一种使用Lua脚本动态更新App的方案，演讲者讲解了LuaView的基本原理、使用以及对LuaView未来发展的一些规划。</p>\n<p>这样，第一天的会议就结束了。</p>\n<h3 id=\"第二天上午\"><a href=\"#第二天上午\" class=\"headerlink\" title=\"第二天上午\"></a>第二天上午</h3><p>第二天上午也有三个分会场，分别是架构演进、VR/AR、移动解决方案。</p>\n<p>我先听了“360°全景视频播放器的实现原理”，演讲者是阿里的高级iOS工程师，分享了如何使用OpenGL实现全景视频播放，以前从来没有接触过这一块，所以听得也是迷迷糊糊。VR/AR目前是是一个很火的方向，但还处于发展的初期，不过有机会还是值得尝试尝试。</p>\n<p>接下来我又听了一段“手机天猫解耦之路”，我是中间进去的，会场挤满了人，分享者讲的东西也是干货满满。演讲嘉宾是天猫的无线技术专家，我听的那一块正好讲到了一种界面间解耦的思路，使用URL Server来实现界面间跳转。</p>\n<p>接下来又听了滴滴的iOS负责人分享的“滴滴的组件化实践与优化”，主要讲到了滴滴iOS端在发展中遇到的问题以及解决方案，重点讲了滴滴组件化的经历，也是干货满满。后面提到的灰度发布对我们目前的项目很有参考价值。</p>\n<p>后面又听了“iOS遗留系统上的架构重构”，是一名来自澳洲的iOS工程师分享的，主要分享了自己是如何在遗留的代码上，把数据存储从CoreData迁移到Realm并且没有影响正常迭代的经历，使用的是抽象分支+特性开关，也非常有参考价值。</p>\n<h3 id=\"第二天下午\"><a href=\"#第二天下午\" class=\"headerlink\" title=\"第二天下午\"></a>第二天下午</h3><p>第二天下午有两个分会场，分别是性能优化专场和应用架构专场。</p>\n<p>我先听了“美团 iOS 客户端的构建思考与实践”，分享者是美团的高级工程师，主要讲了美团APP iOS客户端的架构，以及集成和发布中遇到的问题和一些实践经验。分享了一些持续集成的经验，目前我们项目中还没有用到持续集成，所有这一块也不是很了解，不过很多东西还是值得借鉴和尝试的。</p>\n<p>后面我又听了来自微博的美女架构师分享的“微博复杂信息流的架构之道”，分享中提到的隔周发版也是一种很好的实践方式。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>总体来说这次GMTC大会还是收获很多的，学习到了业界一些最新最热的技术和思想，非常感谢公司能给我这次机会。</p>\n<p>最后，由于第一次去北京，当然少不了要到处逛逛。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/9088bb3373fad1444a78921cb8c8172f.png\" alt=\"2\"></p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/5a0e1b3dac94502a08f70de2f14bee22.png\" alt=\"3\"></p>\n"},{"title":"从jekyll迁移到hexo","date":"2016-07-01T13:24:50.000Z","_content":"\n最近公司项目不是很忙，所以想把自己的博客好好整整，下面就是我从原先的jekyll迁移的hexo的整个过程的记录以及中间遇到的一些问题。\n\n## 安装Hexo\n\n打开终端，执行命令：\n\n```shell\n$ npm install -g hexo-cli\n```\n\n然后随便找个文件夹，执行命令：\n\n```shell\n$ hexo init .\n```\n\n这个过程可能有些长，因为要安装很多依赖的包。\n\n执行完后，就会在这个文件中生成一些文件，如下图，这就是Hexo的主目录。然后执行命令\n\n```shell\n$ npm install\n```\n\n这个命令一定要执行，否则后面在启动本地服务器预览是会出现“Get 404”错误。\n\n其他还要执行的命令有：\n\n```shell\n$ npm install hexo-renderer-ejs --save\n$ npm install hexo-renderer-stylus --save\n$ npm install hexo-renderer-marked --save\n$ npm install hexo-server --save\n```\n\n这样就完成了安装，然后执行命令：\n\n```shell\nhexo server\n```\n\n然后打开浏览器，输入http://127.0.0.1:4000/  ，就可以看到预览界面\n\n![1](http://7xn88v.com1.z0.glb.clouddn.com/5f8ddbc140ff9ec8ecbd1bb8bb119b4a.png)\n\n## 配置主题\n\n我选的是NexT主题，这个主题比较美观，而且最重要的是文档齐全，在[这里](http://theme-next.iissnan.com/)可以找到关于这个主题的所有内容。\n\n安装主题的方法很简单，在hexo主目录执行命令：\n\n```shell\ngit clone https://github.com/iissnan/hexo-theme-next themes/next\n```\n\n然后修改配置文件_config.yml，添加一下内容：\n\n```\ntheme: next\n```\n\n然后开启预览，就可以看到主题已经换成了新的主题\n\n![2](http://7xn88v.com1.z0.glb.clouddn.com/81a90b7504bc5d934c642d1395dd63ed.png)\n\n更详细的配置可以参考这个主题的[文档](http://theme-next.iissnan.com/)。\n\n## 数据迁移\n\nHexo的数据迁移很简单，只要要以前jekyll主目录下的`_post`文件夹里的所有文件拷贝到hexo目录下的`source/_posts`,然后在配置文件_config.yml中添加如下内容：\n\n```\nnew_post_name: :year-:month-:day-:title.md\n```\n\n这样就完成了数据迁移。其他框架的博客迁移到hexo可以参看[官方文档](https://hexo.io/zh-cn/docs/migration.html)\n\n这里要注意的是，之前在jekyll中，代码块是这样的格式：\n\n```objectiveC\n{% highlight objectiveC linenos %}\nNSString * str = @\"I love coding!!\";\nNSLog(@\"%@\", str);\n{% endhighlight %}\n```\n\n但是在hexo不支持这样的格式，所以要全部替换成标准的Markdown代码块，这是比较蛋疼的地方。\n\n做完这些之后，再次打开预览，就可以看到原来的博客啦。\n\n![3](http://7xn88v.com1.z0.glb.clouddn.com/d8627ec1356b590c21c2c6fba2cffd47.png)\n\n## 部署\n\n先安装hexo-deployer-git，执行命令：\n\n```shell\n$ npm install hexo-deployer-git --save\n```\n\n然后在Github上创建一个仓库，然后开启Github Pages功能，可以参考[这篇文章](http://jingpin.jikexueyuan.com/article/33505.html)\n\n然后修改配置文件_config.yml,添加如下内容：\n\n```\ndeploy:\n  type: git\n  repository: git@github.com:liujinlongxa/liujinlongxa.github.io.git\n  branch: master\n```\n\n然后执行命令\n\n```shell\n$ hexo deploy\n```\n\n这样就把博客部署到了github上\n\n## 绑定独立域名\n\n到万网购买了一个独立域名（后来才知道DNSPod的解析速度更快一些，后悔了），然后在hexo主目录下的source文件夹中创建一个名为CNAME的文件，里面填写你的独立域名，如下：\n\n![4](http://7xn88v.com1.z0.glb.clouddn.com/307f1cb10cc4a3286cc1dd01b0d4f0ce.png)\n\n然后重新部署一下，这样这个CNAME就会上传到Github仓库的根目录下。如下：\n\n![5](http://7xn88v.com1.z0.glb.clouddn.com/69301b3770b43797bda6fbd110f08f87.png)\n\n这里一定要注意，要把CNAME放在source文件夹里，如果直接从Github创建CNAME，重新部署博客后，会删掉添加的CNAME。\n\n然后就是添加域名解析，打开万网域名管理后台，添加如下解析\n\n![6](http://7xn88v.com1.z0.glb.clouddn.com/f696d7662bef60f14f045484df43f22e.png)\n\n```\n192.30.252.153\n192.30.252.154\n```\n\n这两个IP是Github的IP，设置完后，过一会，就可以用独立域名访问了。\n\n这样一个Hexo博客就搭建完成了。\n\n## 写博客\n\nHexo自带命令可以生成生成一篇新的博客，如下：\n\n```shell\nhexo new post \"helloworld\"\n```\n\n然后就会生成一篇名为\"helloworld\"的博客。\n\n写完博客后，然后执行下面三条命令发布博客。\n\n```shell\nhexo clean\nhexo generate\nhexo deploy\n```\n\n这里可以写一个脚本，一次性执行这三条命令。\n\n## 遇到的问题\n\n*  执行hexo deploy后，CNAME和README.md文件消失\n\n解决方法，把这两个文件放在source目录下，这样在部署时就会把这两个文件也放到github的根目录下\n\n![7](http://7xn88v.com1.z0.glb.clouddn.com/b371a047e69935cd2c92c11169483d00.png)\n\n*  执行hexo deploy后，README.md被渲染成了README.html\n\n解决方法，在_config.yml中添加如下内容即可：\n\n```\nskip_render: README.md\n```\n\n以上就是我从Jekyll迁移到Hexo的整个过程。\n\n参考资料：\n* [Hexo文档](https://hexo.io/zh-cn/docs/)\n* [NexT使用手册](http://theme-next.iissnan.com/)\n* [hexo边搭边记](http://blog.sunnyxx.com/2014/02/27/hexo_startup/)\n","source":"_posts/2016-07-01-从jekyll迁移到hexo.md","raw":"---\ntitle: \"从jekyll迁移到hexo\"\ndate: 2016-07-01 21:24:50\ncategories: \"其他\"\ntags:\n    - Hexo\n---\n\n最近公司项目不是很忙，所以想把自己的博客好好整整，下面就是我从原先的jekyll迁移的hexo的整个过程的记录以及中间遇到的一些问题。\n\n## 安装Hexo\n\n打开终端，执行命令：\n\n```shell\n$ npm install -g hexo-cli\n```\n\n然后随便找个文件夹，执行命令：\n\n```shell\n$ hexo init .\n```\n\n这个过程可能有些长，因为要安装很多依赖的包。\n\n执行完后，就会在这个文件中生成一些文件，如下图，这就是Hexo的主目录。然后执行命令\n\n```shell\n$ npm install\n```\n\n这个命令一定要执行，否则后面在启动本地服务器预览是会出现“Get 404”错误。\n\n其他还要执行的命令有：\n\n```shell\n$ npm install hexo-renderer-ejs --save\n$ npm install hexo-renderer-stylus --save\n$ npm install hexo-renderer-marked --save\n$ npm install hexo-server --save\n```\n\n这样就完成了安装，然后执行命令：\n\n```shell\nhexo server\n```\n\n然后打开浏览器，输入http://127.0.0.1:4000/  ，就可以看到预览界面\n\n![1](http://7xn88v.com1.z0.glb.clouddn.com/5f8ddbc140ff9ec8ecbd1bb8bb119b4a.png)\n\n## 配置主题\n\n我选的是NexT主题，这个主题比较美观，而且最重要的是文档齐全，在[这里](http://theme-next.iissnan.com/)可以找到关于这个主题的所有内容。\n\n安装主题的方法很简单，在hexo主目录执行命令：\n\n```shell\ngit clone https://github.com/iissnan/hexo-theme-next themes/next\n```\n\n然后修改配置文件_config.yml，添加一下内容：\n\n```\ntheme: next\n```\n\n然后开启预览，就可以看到主题已经换成了新的主题\n\n![2](http://7xn88v.com1.z0.glb.clouddn.com/81a90b7504bc5d934c642d1395dd63ed.png)\n\n更详细的配置可以参考这个主题的[文档](http://theme-next.iissnan.com/)。\n\n## 数据迁移\n\nHexo的数据迁移很简单，只要要以前jekyll主目录下的`_post`文件夹里的所有文件拷贝到hexo目录下的`source/_posts`,然后在配置文件_config.yml中添加如下内容：\n\n```\nnew_post_name: :year-:month-:day-:title.md\n```\n\n这样就完成了数据迁移。其他框架的博客迁移到hexo可以参看[官方文档](https://hexo.io/zh-cn/docs/migration.html)\n\n这里要注意的是，之前在jekyll中，代码块是这样的格式：\n\n```objectiveC\n{% highlight objectiveC linenos %}\nNSString * str = @\"I love coding!!\";\nNSLog(@\"%@\", str);\n{% endhighlight %}\n```\n\n但是在hexo不支持这样的格式，所以要全部替换成标准的Markdown代码块，这是比较蛋疼的地方。\n\n做完这些之后，再次打开预览，就可以看到原来的博客啦。\n\n![3](http://7xn88v.com1.z0.glb.clouddn.com/d8627ec1356b590c21c2c6fba2cffd47.png)\n\n## 部署\n\n先安装hexo-deployer-git，执行命令：\n\n```shell\n$ npm install hexo-deployer-git --save\n```\n\n然后在Github上创建一个仓库，然后开启Github Pages功能，可以参考[这篇文章](http://jingpin.jikexueyuan.com/article/33505.html)\n\n然后修改配置文件_config.yml,添加如下内容：\n\n```\ndeploy:\n  type: git\n  repository: git@github.com:liujinlongxa/liujinlongxa.github.io.git\n  branch: master\n```\n\n然后执行命令\n\n```shell\n$ hexo deploy\n```\n\n这样就把博客部署到了github上\n\n## 绑定独立域名\n\n到万网购买了一个独立域名（后来才知道DNSPod的解析速度更快一些，后悔了），然后在hexo主目录下的source文件夹中创建一个名为CNAME的文件，里面填写你的独立域名，如下：\n\n![4](http://7xn88v.com1.z0.glb.clouddn.com/307f1cb10cc4a3286cc1dd01b0d4f0ce.png)\n\n然后重新部署一下，这样这个CNAME就会上传到Github仓库的根目录下。如下：\n\n![5](http://7xn88v.com1.z0.glb.clouddn.com/69301b3770b43797bda6fbd110f08f87.png)\n\n这里一定要注意，要把CNAME放在source文件夹里，如果直接从Github创建CNAME，重新部署博客后，会删掉添加的CNAME。\n\n然后就是添加域名解析，打开万网域名管理后台，添加如下解析\n\n![6](http://7xn88v.com1.z0.glb.clouddn.com/f696d7662bef60f14f045484df43f22e.png)\n\n```\n192.30.252.153\n192.30.252.154\n```\n\n这两个IP是Github的IP，设置完后，过一会，就可以用独立域名访问了。\n\n这样一个Hexo博客就搭建完成了。\n\n## 写博客\n\nHexo自带命令可以生成生成一篇新的博客，如下：\n\n```shell\nhexo new post \"helloworld\"\n```\n\n然后就会生成一篇名为\"helloworld\"的博客。\n\n写完博客后，然后执行下面三条命令发布博客。\n\n```shell\nhexo clean\nhexo generate\nhexo deploy\n```\n\n这里可以写一个脚本，一次性执行这三条命令。\n\n## 遇到的问题\n\n*  执行hexo deploy后，CNAME和README.md文件消失\n\n解决方法，把这两个文件放在source目录下，这样在部署时就会把这两个文件也放到github的根目录下\n\n![7](http://7xn88v.com1.z0.glb.clouddn.com/b371a047e69935cd2c92c11169483d00.png)\n\n*  执行hexo deploy后，README.md被渲染成了README.html\n\n解决方法，在_config.yml中添加如下内容即可：\n\n```\nskip_render: README.md\n```\n\n以上就是我从Jekyll迁移到Hexo的整个过程。\n\n参考资料：\n* [Hexo文档](https://hexo.io/zh-cn/docs/)\n* [NexT使用手册](http://theme-next.iissnan.com/)\n* [hexo边搭边记](http://blog.sunnyxx.com/2014/02/27/hexo_startup/)\n","slug":"从jekyll迁移到hexo","published":1,"updated":"2016-08-12T15:20:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis94oabu001vzrm03leo5bga","content":"<p>最近公司项目不是很忙，所以想把自己的博客好好整整，下面就是我从原先的jekyll迁移的hexo的整个过程的记录以及中间遇到的一些问题。</p>\n<h2 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h2><p>打开终端，执行命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install -g hexo-cli</div></pre></td></tr></table></figure>\n<p>然后随便找个文件夹，执行命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo init .</div></pre></td></tr></table></figure>\n<p>这个过程可能有些长，因为要安装很多依赖的包。</p>\n<p>执行完后，就会在这个文件中生成一些文件，如下图，这就是Hexo的主目录。然后执行命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install</div></pre></td></tr></table></figure>\n<p>这个命令一定要执行，否则后面在启动本地服务器预览是会出现“Get 404”错误。</p>\n<p>其他还要执行的命令有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install hexo-renderer-ejs --save</div><div class=\"line\">$ npm install hexo-renderer-stylus --save</div><div class=\"line\">$ npm install hexo-renderer-marked --save</div><div class=\"line\">$ npm install hexo-server --save</div></pre></td></tr></table></figure>\n<p>这样就完成了安装，然后执行命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo server</div></pre></td></tr></table></figure>\n<p>然后打开浏览器，输入<a href=\"http://127.0.0.1:4000/\" target=\"_blank\" rel=\"external\">http://127.0.0.1:4000/</a>  ，就可以看到预览界面</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/5f8ddbc140ff9ec8ecbd1bb8bb119b4a.png\" alt=\"1\"></p>\n<h2 id=\"配置主题\"><a href=\"#配置主题\" class=\"headerlink\" title=\"配置主题\"></a>配置主题</h2><p>我选的是NexT主题，这个主题比较美观，而且最重要的是文档齐全，在<a href=\"http://theme-next.iissnan.com/\" target=\"_blank\" rel=\"external\">这里</a>可以找到关于这个主题的所有内容。</p>\n<p>安装主题的方法很简单，在hexo主目录执行命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://github.com/iissnan/hexo-theme-next themes/next</div></pre></td></tr></table></figure>\n<p>然后修改配置文件_config.yml，添加一下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">theme: next</div></pre></td></tr></table></figure>\n<p>然后开启预览，就可以看到主题已经换成了新的主题</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/81a90b7504bc5d934c642d1395dd63ed.png\" alt=\"2\"></p>\n<p>更详细的配置可以参考这个主题的<a href=\"http://theme-next.iissnan.com/\" target=\"_blank\" rel=\"external\">文档</a>。</p>\n<h2 id=\"数据迁移\"><a href=\"#数据迁移\" class=\"headerlink\" title=\"数据迁移\"></a>数据迁移</h2><p>Hexo的数据迁移很简单，只要要以前jekyll主目录下的<code>_post</code>文件夹里的所有文件拷贝到hexo目录下的<code>source/_posts</code>,然后在配置文件_config.yml中添加如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">new_post_name: :year-:month-:day-:title.md</div></pre></td></tr></table></figure>\n<p>这样就完成了数据迁移。其他框架的博客迁移到hexo可以参看<a href=\"https://hexo.io/zh-cn/docs/migration.html\" target=\"_blank\" rel=\"external\">官方文档</a></p>\n<p>这里要注意的是，之前在jekyll中，代码块是这样的格式：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;% highlight objectiveC linenos %&#125;</div><div class=\"line\"><span class=\"built_in\">NSString</span> * str = <span class=\"string\">@\"I love coding!!\"</span>;</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, str);</div><div class=\"line\">&#123;% endhighlight %&#125;</div></pre></td></tr></table></figure>\n<p>但是在hexo不支持这样的格式，所以要全部替换成标准的Markdown代码块，这是比较蛋疼的地方。</p>\n<p>做完这些之后，再次打开预览，就可以看到原来的博客啦。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/d8627ec1356b590c21c2c6fba2cffd47.png\" alt=\"3\"></p>\n<h2 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h2><p>先安装hexo-deployer-git，执行命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>\n<p>然后在Github上创建一个仓库，然后开启Github Pages功能，可以参考<a href=\"http://jingpin.jikexueyuan.com/article/33505.html\" target=\"_blank\" rel=\"external\">这篇文章</a></p>\n<p>然后修改配置文件_config.yml,添加如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repository: git@github.com:liujinlongxa/liujinlongxa.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<p>然后执行命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>这样就把博客部署到了github上</p>\n<h2 id=\"绑定独立域名\"><a href=\"#绑定独立域名\" class=\"headerlink\" title=\"绑定独立域名\"></a>绑定独立域名</h2><p>到万网购买了一个独立域名（后来才知道DNSPod的解析速度更快一些，后悔了），然后在hexo主目录下的source文件夹中创建一个名为CNAME的文件，里面填写你的独立域名，如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/307f1cb10cc4a3286cc1dd01b0d4f0ce.png\" alt=\"4\"></p>\n<p>然后重新部署一下，这样这个CNAME就会上传到Github仓库的根目录下。如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/69301b3770b43797bda6fbd110f08f87.png\" alt=\"5\"></p>\n<p>这里一定要注意，要把CNAME放在source文件夹里，如果直接从Github创建CNAME，重新部署博客后，会删掉添加的CNAME。</p>\n<p>然后就是添加域名解析，打开万网域名管理后台，添加如下解析</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/f696d7662bef60f14f045484df43f22e.png\" alt=\"6\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">192.30.252.153</div><div class=\"line\">192.30.252.154</div></pre></td></tr></table></figure>\n<p>这两个IP是Github的IP，设置完后，过一会，就可以用独立域名访问了。</p>\n<p>这样一个Hexo博客就搭建完成了。</p>\n<h2 id=\"写博客\"><a href=\"#写博客\" class=\"headerlink\" title=\"写博客\"></a>写博客</h2><p>Hexo自带命令可以生成生成一篇新的博客，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new post &quot;helloworld&quot;</div></pre></td></tr></table></figure>\n<p>然后就会生成一篇名为”helloworld”的博客。</p>\n<p>写完博客后，然后执行下面三条命令发布博客。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo clean</div><div class=\"line\">hexo generate</div><div class=\"line\">hexo deploy</div></pre></td></tr></table></figure>\n<p>这里可以写一个脚本，一次性执行这三条命令。</p>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ul>\n<li>执行hexo deploy后，CNAME和README.md文件消失</li>\n</ul>\n<p>解决方法，把这两个文件放在source目录下，这样在部署时就会把这两个文件也放到github的根目录下</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/b371a047e69935cd2c92c11169483d00.png\" alt=\"7\"></p>\n<ul>\n<li>执行hexo deploy后，README.md被渲染成了README.html</li>\n</ul>\n<p>解决方法，在_config.yml中添加如下内容即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">skip_render: README.md</div></pre></td></tr></table></figure>\n<p>以上就是我从Jekyll迁移到Hexo的整个过程。</p>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"external\">Hexo文档</a></li>\n<li><a href=\"http://theme-next.iissnan.com/\" target=\"_blank\" rel=\"external\">NexT使用手册</a></li>\n<li><a href=\"http://blog.sunnyxx.com/2014/02/27/hexo_startup/\" target=\"_blank\" rel=\"external\">hexo边搭边记</a></li>\n</ul>\n","excerpt":"","more":"<p>最近公司项目不是很忙，所以想把自己的博客好好整整，下面就是我从原先的jekyll迁移的hexo的整个过程的记录以及中间遇到的一些问题。</p>\n<h2 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h2><p>打开终端，执行命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install -g hexo-cli</div></pre></td></tr></table></figure>\n<p>然后随便找个文件夹，执行命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo init .</div></pre></td></tr></table></figure>\n<p>这个过程可能有些长，因为要安装很多依赖的包。</p>\n<p>执行完后，就会在这个文件中生成一些文件，如下图，这就是Hexo的主目录。然后执行命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install</div></pre></td></tr></table></figure>\n<p>这个命令一定要执行，否则后面在启动本地服务器预览是会出现“Get 404”错误。</p>\n<p>其他还要执行的命令有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install hexo-renderer-ejs --save</div><div class=\"line\">$ npm install hexo-renderer-stylus --save</div><div class=\"line\">$ npm install hexo-renderer-marked --save</div><div class=\"line\">$ npm install hexo-server --save</div></pre></td></tr></table></figure>\n<p>这样就完成了安装，然后执行命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo server</div></pre></td></tr></table></figure>\n<p>然后打开浏览器，输入<a href=\"http://127.0.0.1:4000/\">http://127.0.0.1:4000/</a>  ，就可以看到预览界面</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/5f8ddbc140ff9ec8ecbd1bb8bb119b4a.png\" alt=\"1\"></p>\n<h2 id=\"配置主题\"><a href=\"#配置主题\" class=\"headerlink\" title=\"配置主题\"></a>配置主题</h2><p>我选的是NexT主题，这个主题比较美观，而且最重要的是文档齐全，在<a href=\"http://theme-next.iissnan.com/\">这里</a>可以找到关于这个主题的所有内容。</p>\n<p>安装主题的方法很简单，在hexo主目录执行命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://github.com/iissnan/hexo-theme-next themes/next</div></pre></td></tr></table></figure>\n<p>然后修改配置文件_config.yml，添加一下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">theme: next</div></pre></td></tr></table></figure>\n<p>然后开启预览，就可以看到主题已经换成了新的主题</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/81a90b7504bc5d934c642d1395dd63ed.png\" alt=\"2\"></p>\n<p>更详细的配置可以参考这个主题的<a href=\"http://theme-next.iissnan.com/\">文档</a>。</p>\n<h2 id=\"数据迁移\"><a href=\"#数据迁移\" class=\"headerlink\" title=\"数据迁移\"></a>数据迁移</h2><p>Hexo的数据迁移很简单，只要要以前jekyll主目录下的<code>_post</code>文件夹里的所有文件拷贝到hexo目录下的<code>source/_posts</code>,然后在配置文件_config.yml中添加如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">new_post_name: :year-:month-:day-:title.md</div></pre></td></tr></table></figure>\n<p>这样就完成了数据迁移。其他框架的博客迁移到hexo可以参看<a href=\"https://hexo.io/zh-cn/docs/migration.html\">官方文档</a></p>\n<p>这里要注意的是，之前在jekyll中，代码块是这样的格式：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;% highlight objectiveC linenos %&#125;</div><div class=\"line\"><span class=\"built_in\">NSString</span> * str = <span class=\"string\">@\"I love coding!!\"</span>;</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, str);</div><div class=\"line\">&#123;% endhighlight %&#125;</div></pre></td></tr></table></figure>\n<p>但是在hexo不支持这样的格式，所以要全部替换成标准的Markdown代码块，这是比较蛋疼的地方。</p>\n<p>做完这些之后，再次打开预览，就可以看到原来的博客啦。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/d8627ec1356b590c21c2c6fba2cffd47.png\" alt=\"3\"></p>\n<h2 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h2><p>先安装hexo-deployer-git，执行命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>\n<p>然后在Github上创建一个仓库，然后开启Github Pages功能，可以参考<a href=\"http://jingpin.jikexueyuan.com/article/33505.html\">这篇文章</a></p>\n<p>然后修改配置文件_config.yml,添加如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repository: git@github.com:liujinlongxa/liujinlongxa.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<p>然后执行命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>这样就把博客部署到了github上</p>\n<h2 id=\"绑定独立域名\"><a href=\"#绑定独立域名\" class=\"headerlink\" title=\"绑定独立域名\"></a>绑定独立域名</h2><p>到万网购买了一个独立域名（后来才知道DNSPod的解析速度更快一些，后悔了），然后在hexo主目录下的source文件夹中创建一个名为CNAME的文件，里面填写你的独立域名，如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/307f1cb10cc4a3286cc1dd01b0d4f0ce.png\" alt=\"4\"></p>\n<p>然后重新部署一下，这样这个CNAME就会上传到Github仓库的根目录下。如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/69301b3770b43797bda6fbd110f08f87.png\" alt=\"5\"></p>\n<p>这里一定要注意，要把CNAME放在source文件夹里，如果直接从Github创建CNAME，重新部署博客后，会删掉添加的CNAME。</p>\n<p>然后就是添加域名解析，打开万网域名管理后台，添加如下解析</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/f696d7662bef60f14f045484df43f22e.png\" alt=\"6\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">192.30.252.153</div><div class=\"line\">192.30.252.154</div></pre></td></tr></table></figure>\n<p>这两个IP是Github的IP，设置完后，过一会，就可以用独立域名访问了。</p>\n<p>这样一个Hexo博客就搭建完成了。</p>\n<h2 id=\"写博客\"><a href=\"#写博客\" class=\"headerlink\" title=\"写博客\"></a>写博客</h2><p>Hexo自带命令可以生成生成一篇新的博客，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new post &quot;helloworld&quot;</div></pre></td></tr></table></figure>\n<p>然后就会生成一篇名为”helloworld”的博客。</p>\n<p>写完博客后，然后执行下面三条命令发布博客。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo clean</div><div class=\"line\">hexo generate</div><div class=\"line\">hexo deploy</div></pre></td></tr></table></figure>\n<p>这里可以写一个脚本，一次性执行这三条命令。</p>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ul>\n<li>执行hexo deploy后，CNAME和README.md文件消失</li>\n</ul>\n<p>解决方法，把这两个文件放在source目录下，这样在部署时就会把这两个文件也放到github的根目录下</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/b371a047e69935cd2c92c11169483d00.png\" alt=\"7\"></p>\n<ul>\n<li>执行hexo deploy后，README.md被渲染成了README.html</li>\n</ul>\n<p>解决方法，在_config.yml中添加如下内容即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">skip_render: README.md</div></pre></td></tr></table></figure>\n<p>以上就是我从Jekyll迁移到Hexo的整个过程。</p>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://hexo.io/zh-cn/docs/\">Hexo文档</a></li>\n<li><a href=\"http://theme-next.iissnan.com/\">NexT使用手册</a></li>\n<li><a href=\"http://blog.sunnyxx.com/2014/02/27/hexo_startup/\">hexo边搭边记</a></li>\n</ul>\n"},{"title":"Could not load the xxx image referenced from a nib in the bundle with identifier xxxx问题","date":"2016-07-03T10:51:49.000Z","_content":"\n出现在非retina的屏幕上，不能正确加载xib上的图片，只能通过代码重新设置图片。还没有找到其他解决办法。\n","source":"_posts/2016-07-03-Could-not-load-the-xxx-image-referenced-from-a-nib-in-the-bundle-with-identifier-xxxx问题.md","raw":"---\ntitle: >-\n  Could not load the xxx image referenced from a nib in the bundle with\n  identifier xxxx问题\ncategories: iOS Tips\ntags:\n  - 其他\ndate: 2016-07-03 18:51:49\n---\n\n出现在非retina的屏幕上，不能正确加载xib上的图片，只能通过代码重新设置图片。还没有找到其他解决办法。\n","slug":"Could-not-load-the-xxx-image-referenced-from-a-nib-in-the-bundle-with-identifier-xxxx问题","published":1,"updated":"2016-08-12T15:20:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis94oabz001xzrm0dxetnjdo","content":"<p>出现在非retina的屏幕上，不能正确加载xib上的图片，只能通过代码重新设置图片。还没有找到其他解决办法。</p>\n","excerpt":"","more":"<p>出现在非retina的屏幕上，不能正确加载xib上的图片，只能通过代码重新设置图片。还没有找到其他解决办法。</p>\n"},{"title":"UILabel设置lineBreakMode属性无效","date":"2016-07-03T10:09:30.000Z","_content":"\nUILabel的lineBreakMode属性用于设置文字的截断方式，我在使用过程中，发现了一个问题，当我设置lineBreakMode为NSLineBreakByCharWrapping或NSLineBreakByWordWrapping时，有时会没有效果，它依然以NSLineBreakByClipping方式显示。\n\n经过一番Google，原来，要设置NSLineBreakByCharWrapping或NSLineBreakByWordWrapping，UILabel的numberOfLines必须是0，否则就会无效。\n","source":"_posts/2016-07-03-UILabel设置lineBreakMode属性无效.md","raw":"---\ntitle: \"UILabel设置lineBreakMode属性无效\"\ndate: 2016-07-03 18:09:30\ncategories: iOS Tips\ntags:\n  - UILabel\n---\n\nUILabel的lineBreakMode属性用于设置文字的截断方式，我在使用过程中，发现了一个问题，当我设置lineBreakMode为NSLineBreakByCharWrapping或NSLineBreakByWordWrapping时，有时会没有效果，它依然以NSLineBreakByClipping方式显示。\n\n经过一番Google，原来，要设置NSLineBreakByCharWrapping或NSLineBreakByWordWrapping，UILabel的numberOfLines必须是0，否则就会无效。\n","slug":"UILabel设置lineBreakMode属性无效","published":1,"updated":"2016-08-12T15:20:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis94oac10020zrm0apfyavyg","content":"<p>UILabel的lineBreakMode属性用于设置文字的截断方式，我在使用过程中，发现了一个问题，当我设置lineBreakMode为NSLineBreakByCharWrapping或NSLineBreakByWordWrapping时，有时会没有效果，它依然以NSLineBreakByClipping方式显示。</p>\n<p>经过一番Google，原来，要设置NSLineBreakByCharWrapping或NSLineBreakByWordWrapping，UILabel的numberOfLines必须是0，否则就会无效。</p>\n","excerpt":"","more":"<p>UILabel的lineBreakMode属性用于设置文字的截断方式，我在使用过程中，发现了一个问题，当我设置lineBreakMode为NSLineBreakByCharWrapping或NSLineBreakByWordWrapping时，有时会没有效果，它依然以NSLineBreakByClipping方式显示。</p>\n<p>经过一番Google，原来，要设置NSLineBreakByCharWrapping或NSLineBreakByWordWrapping，UILabel的numberOfLines必须是0，否则就会无效。</p>\n"},{"title":"用XCode8打开Xib后项目不能在XCode7上运行","date":"2016-07-03T10:56:06.000Z","_content":"\n可以设置xib以Xcode7.x的方法打开，参考如下\n\n[The document Main.storyboard requires Xcode 8.0 or later](http://stackoverflow.com/questions/37851459/the-document-main-storyboard-requires-xcode-8-0-or-later)\n","source":"_posts/2016-07-03-用XCode8打开Xib后项目不能在XCode7上运行.md","raw":"---\ntitle: 用XCode8打开Xib后项目不能在XCode7上运行\ncategories: iOS Tips\ntags:\n  - 其他\ndate: 2016-07-03 18:56:06\n---\n\n可以设置xib以Xcode7.x的方法打开，参考如下\n\n[The document Main.storyboard requires Xcode 8.0 or later](http://stackoverflow.com/questions/37851459/the-document-main-storyboard-requires-xcode-8-0-or-later)\n","slug":"用XCode8打开Xib后项目不能在XCode7上运行","published":1,"updated":"2016-08-12T15:20:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis94oac30022zrm0mapidjiw","content":"<p>可以设置xib以Xcode7.x的方法打开，参考如下</p>\n<p><a href=\"http://stackoverflow.com/questions/37851459/the-document-main-storyboard-requires-xcode-8-0-or-later\" target=\"_blank\" rel=\"external\">The document Main.storyboard requires Xcode 8.0 or later</a></p>\n","excerpt":"","more":"<p>可以设置xib以Xcode7.x的方法打开，参考如下</p>\n<p><a href=\"http://stackoverflow.com/questions/37851459/the-document-main-storyboard-requires-xcode-8-0-or-later\">The document Main.storyboard requires Xcode 8.0 or later</a></p>\n"},{"title":"设置富文本字间距，文字不能居中对齐","date":"2016-07-03T10:40:19.000Z","_content":"\n最近有一个需求，需要设置一个UILabel的字间距，我马上就想到了富文本，于是就写了下面的代码\n\n```objectivec\nNSString *str = self.label.text;\nNSDictionary *attribute = @{NSKernAttributeName:@(10),\n                            NSFontAttributeName:[UIFont systemFontOfSize:15]};\nNSAttributedString *attStr = [[NSAttributedString alloc] initWithString:str attributes:attribute];\nself.label.attributedText = attStr;\n```\n\n其中NSKernAttributeName属性就是设置文字的字间距。但是，现在就有一个问题，设置字间距后，原本居中显示的文字，不能居中显示了。\n\n这是我设置字间距之前的label\n\n![1](http://7xn88v.com1.z0.glb.clouddn.com/3cba47225e6b1a02cfad6885a67d83ed.png)\n\n这是我设置了字间距后的label\n\n![2](http://7xn88v.com1.z0.glb.clouddn.com/424954a63f3e38514b84ab7277269336.png)\n\n\"你\"字距左边距明显要比\"鸿\"字的右边距要大。\n\n经过一阵Google，在StackOverflow上找到了相同的问题，链接是[http://stackoverflow.com/questions/23741850/nsstring-drawinrectwithattributes-not-correctly-centered-when-using-nskernattr](http://stackoverflow.com/questions/23741850/nsstring-drawinrectwithattributes-not-correctly-centered-when-using-nskernattr)，根据问题回答里的做法，我把代码做了修改，如下：\n\n```objectivec\nNSString *str = self.label.text;\nNSMutableAttributedString *mutAttStr = [[NSMutableAttributedString alloc] initWithString:str];\n[mutAttStr addAttribute:NSKernAttributeName value:@(10) range:NSMakeRange(0, str.length - 1)];\n[mutAttStr addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:15] range:NSMakeRange(0, str.length)];\nself.label.attributedText = [mutAttStr copy];\n```\n\n修改后效果如下：\n\n![3](http://7xn88v.com1.z0.glb.clouddn.com/35b1f58bf08aa3dc7b827edb1da01e80.png)\n","source":"_posts/2016-07-03-设置富文本字间距，文字不能居中对齐.md","raw":"---\ntitle: 设置富文本字间距，文字不能居中对齐\ncategories: iOS Tips\ntags:\n  - UILabel\n  - NSAttributedString\ndate: 2016-07-03 18:40:19\n---\n\n最近有一个需求，需要设置一个UILabel的字间距，我马上就想到了富文本，于是就写了下面的代码\n\n```objectivec\nNSString *str = self.label.text;\nNSDictionary *attribute = @{NSKernAttributeName:@(10),\n                            NSFontAttributeName:[UIFont systemFontOfSize:15]};\nNSAttributedString *attStr = [[NSAttributedString alloc] initWithString:str attributes:attribute];\nself.label.attributedText = attStr;\n```\n\n其中NSKernAttributeName属性就是设置文字的字间距。但是，现在就有一个问题，设置字间距后，原本居中显示的文字，不能居中显示了。\n\n这是我设置字间距之前的label\n\n![1](http://7xn88v.com1.z0.glb.clouddn.com/3cba47225e6b1a02cfad6885a67d83ed.png)\n\n这是我设置了字间距后的label\n\n![2](http://7xn88v.com1.z0.glb.clouddn.com/424954a63f3e38514b84ab7277269336.png)\n\n\"你\"字距左边距明显要比\"鸿\"字的右边距要大。\n\n经过一阵Google，在StackOverflow上找到了相同的问题，链接是[http://stackoverflow.com/questions/23741850/nsstring-drawinrectwithattributes-not-correctly-centered-when-using-nskernattr](http://stackoverflow.com/questions/23741850/nsstring-drawinrectwithattributes-not-correctly-centered-when-using-nskernattr)，根据问题回答里的做法，我把代码做了修改，如下：\n\n```objectivec\nNSString *str = self.label.text;\nNSMutableAttributedString *mutAttStr = [[NSMutableAttributedString alloc] initWithString:str];\n[mutAttStr addAttribute:NSKernAttributeName value:@(10) range:NSMakeRange(0, str.length - 1)];\n[mutAttStr addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:15] range:NSMakeRange(0, str.length)];\nself.label.attributedText = [mutAttStr copy];\n```\n\n修改后效果如下：\n\n![3](http://7xn88v.com1.z0.glb.clouddn.com/35b1f58bf08aa3dc7b827edb1da01e80.png)\n","slug":"设置富文本字间距，文字不能居中对齐","published":1,"updated":"2016-08-12T15:20:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis94oac50025zrm0bbtzw6ga","content":"<p>最近有一个需求，需要设置一个UILabel的字间距，我马上就想到了富文本，于是就写了下面的代码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *str = <span class=\"keyword\">self</span>.label.text;</div><div class=\"line\"><span class=\"built_in\">NSDictionary</span> *attribute = @&#123;<span class=\"built_in\">NSKernAttributeName</span>:@(<span class=\"number\">10</span>),</div><div class=\"line\">                            <span class=\"built_in\">NSFontAttributeName</span>:[<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">15</span>]&#125;;</div><div class=\"line\"><span class=\"built_in\">NSAttributedString</span> *attStr = [[<span class=\"built_in\">NSAttributedString</span> alloc] initWithString:str attributes:attribute];</div><div class=\"line\"><span class=\"keyword\">self</span>.label.attributedText = attStr;</div></pre></td></tr></table></figure>\n<p>其中NSKernAttributeName属性就是设置文字的字间距。但是，现在就有一个问题，设置字间距后，原本居中显示的文字，不能居中显示了。</p>\n<p>这是我设置字间距之前的label</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/3cba47225e6b1a02cfad6885a67d83ed.png\" alt=\"1\"></p>\n<p>这是我设置了字间距后的label</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/424954a63f3e38514b84ab7277269336.png\" alt=\"2\"></p>\n<p>“你”字距左边距明显要比”鸿”字的右边距要大。</p>\n<p>经过一阵Google，在StackOverflow上找到了相同的问题，链接是<a href=\"http://stackoverflow.com/questions/23741850/nsstring-drawinrectwithattributes-not-correctly-centered-when-using-nskernattr\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/23741850/nsstring-drawinrectwithattributes-not-correctly-centered-when-using-nskernattr</a>，根据问题回答里的做法，我把代码做了修改，如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *str = <span class=\"keyword\">self</span>.label.text;</div><div class=\"line\"><span class=\"built_in\">NSMutableAttributedString</span> *mutAttStr = [[<span class=\"built_in\">NSMutableAttributedString</span> alloc] initWithString:str];</div><div class=\"line\">[mutAttStr addAttribute:<span class=\"built_in\">NSKernAttributeName</span> value:@(<span class=\"number\">10</span>) range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, str.length - <span class=\"number\">1</span>)];</div><div class=\"line\">[mutAttStr addAttribute:<span class=\"built_in\">NSFontAttributeName</span> value:[<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">15</span>] range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, str.length)];</div><div class=\"line\"><span class=\"keyword\">self</span>.label.attributedText = [mutAttStr <span class=\"keyword\">copy</span>];</div></pre></td></tr></table></figure>\n<p>修改后效果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/35b1f58bf08aa3dc7b827edb1da01e80.png\" alt=\"3\"></p>\n","excerpt":"","more":"<p>最近有一个需求，需要设置一个UILabel的字间距，我马上就想到了富文本，于是就写了下面的代码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *str = <span class=\"keyword\">self</span>.label.text;</div><div class=\"line\"><span class=\"built_in\">NSDictionary</span> *attribute = @&#123;<span class=\"built_in\">NSKernAttributeName</span>:@(<span class=\"number\">10</span>),</div><div class=\"line\">                            <span class=\"built_in\">NSFontAttributeName</span>:[<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">15</span>]&#125;;</div><div class=\"line\"><span class=\"built_in\">NSAttributedString</span> *attStr = [[<span class=\"built_in\">NSAttributedString</span> alloc] initWithString:str attributes:attribute];</div><div class=\"line\"><span class=\"keyword\">self</span>.label.attributedText = attStr;</div></pre></td></tr></table></figure>\n<p>其中NSKernAttributeName属性就是设置文字的字间距。但是，现在就有一个问题，设置字间距后，原本居中显示的文字，不能居中显示了。</p>\n<p>这是我设置字间距之前的label</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/3cba47225e6b1a02cfad6885a67d83ed.png\" alt=\"1\"></p>\n<p>这是我设置了字间距后的label</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/424954a63f3e38514b84ab7277269336.png\" alt=\"2\"></p>\n<p>“你”字距左边距明显要比”鸿”字的右边距要大。</p>\n<p>经过一阵Google，在StackOverflow上找到了相同的问题，链接是<a href=\"http://stackoverflow.com/questions/23741850/nsstring-drawinrectwithattributes-not-correctly-centered-when-using-nskernattr\">http://stackoverflow.com/questions/23741850/nsstring-drawinrectwithattributes-not-correctly-centered-when-using-nskernattr</a>，根据问题回答里的做法，我把代码做了修改，如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *str = <span class=\"keyword\">self</span>.label.text;</div><div class=\"line\"><span class=\"built_in\">NSMutableAttributedString</span> *mutAttStr = [[<span class=\"built_in\">NSMutableAttributedString</span> alloc] initWithString:str];</div><div class=\"line\">[mutAttStr addAttribute:<span class=\"built_in\">NSKernAttributeName</span> value:@(<span class=\"number\">10</span>) range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, str.length - <span class=\"number\">1</span>)];</div><div class=\"line\">[mutAttStr addAttribute:<span class=\"built_in\">NSFontAttributeName</span> value:[<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">15</span>] range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, str.length)];</div><div class=\"line\"><span class=\"keyword\">self</span>.label.attributedText = [mutAttStr <span class=\"keyword\">copy</span>];</div></pre></td></tr></table></figure>\n<p>修改后效果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/35b1f58bf08aa3dc7b827edb1da01e80.png\" alt=\"3\"></p>\n"},{"title":"深入理解CoreAnimation的fillMode和isRemovedOnCompletion","date":"2016-07-10T06:34:06.000Z","_content":"\n一般在使用CoreAnimation写动画是，在定义CAAnimation时，都要加入如下两句来防止动画完成后视图的位置又还原成了原来的位置。\n\n```swift\nanimation.fillMode = kCAFillModeBoth\nanimation.isRemovedOnCompletion = false\n```\n\n很少有文章能详细说明这两个属性的作用，今天我们就来深究一下这两个属性。\n\n## fillMode\n\nfillMode是一个枚举值，用于表示动画在开始和结束时的状态，这样说可能不太好理解，直接看例子比较直观。\n\n### kCAFillModeRemoved\n\n这个是fillMode的默认值，表示在到达beginTime时才显示动画的第一帧，动画结束时，删除CALayer做的变化\n\n实例代码：\n\n```swift\noverride func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent?) {\n    let move = CABasicAnimation(keyPath: \"position.y\")\n    move.fromValue = 100\n    move.toValue = 500\n    move.duration = 1.0\n    move.beginTime = CACurrentMediaTime() + 2.0\n    move.fillMode = kCAFillModeRemoved\n    self.myView.layer.add(move, forKey: nil)\n}\n```\n\n代码中，我们将一个View的y坐标从100移动到500，历时1s，注意开始时间我设定为了`CACurrentMediaTime() + 2.0`，即添加动画2s后才开始执行动画，这样才能看到效果。运行结果如下：\n\n![kCAFillModeRemoved](http://7xn88v.com1.z0.glb.clouddn.com/kCAFillModeRemoved.gif)\n\n可以看到，在鼠标点击触发后，2s之后myView才移动到了动画的初始位置100开始执行动画，并且在动画结束后视图又立刻恢复到原来的位置。\n\n### kCAFillModeBackwards\n\n这个值表示无论是否到达beginTime，动画开始后，立刻显示动画的第一帧，修改代码如下：\n\n```swift\noverride func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent?) {\n    let move = CABasicAnimation(keyPath: \"position.y\")\n    move.fromValue = 100\n    move.toValue = 500\n    move.duration = 1.0\n    move.beginTime = CACurrentMediaTime() + 2.0\n    move.fillMode = kCAFillModeBackwards\n    self.myView.layer.add(move, forKey: nil)\n}\n```\n\n运行效果如下：\n\n![kCAFillModeBackwards](http://7xn88v.com1.z0.glb.clouddn.com/kCAFillModeBackwards.gif)\n\n可以看到，鼠标点击后，myView立刻移动到了动画的初始位置100，然后2s后开始执行动画。\n\n### kCAFillModeForwards\n\n这个值表示在到达beginTime时显示动画的第一帧，在动画结束时，保持动画最后一帧的状态，直到动画被删除，修改代码如下：\n\n```swift\noverride func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {\n    let move = CABasicAnimation(keyPath: \"position.y\")\n    move.fromValue = 100\n    move.toValue = 500\n    move.duration = 1.0\n    move.beginTime = CACurrentMediaTime() + 2.0\n    move.fillMode = kCAFillModeForwards;\n    move.isRemovedOnCompletion = false\n    move.delegate = self;\n    self.myView.layer.add(move, forKey: nil)\n}\n\noverride func animationDidStop(_ anim: CAAnimation, finished flag: Bool) {\n    DispatchQueue.main.after(when: .now() + 3) {\n        self.myView.layer.removeAllAnimations()\n    }\n}\n```\n\n代码中添加了`move.isRemovedOnCompletion = false`，即动画执行完后不立刻删除动画，默认情况下，动画执行完后会立刻删除动画。`isRemovedOnCompletion`属性设置为false后，就不会立刻删除。然后我们还添加了`animationDidStop`方法，这个是`CABasicAnimation`的代理方法，在动画执行结束时会被调用。我们在这个方法里延时3s删除动画。运行效果如下：\n\n![kCAFillModeForwards](http://7xn88v.com1.z0.glb.clouddn.com/kCAFillModeForwards.gif)\n\n可以看到，鼠标点击后，myView等了2s才移动到动画初始位置，动画结束后，等待了3s，myView才恢复到原来的位置。也就是动画结束后会保持最后一帧的状态，直到动画被删除掉。\n\n### kCAFillModeBoth\n\n这个值相当于kCAFillModeBackwards与kCAFillModeForwards的共同合集，即无论是否到达beginTime，动画开始后，立刻显示动画的第一帧，并且在动画结束时保持最后一帧的状态，直到动画被删除。修改代码如下：\n\n```swift\noverride func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {\n    let move = CABasicAnimation(keyPath: \"position.y\")\n    move.fromValue = 100\n    move.toValue = 500\n    move.duration = 1.0\n    move.beginTime = CACurrentMediaTime() + 2.0\n    move.fillMode = kCAFillModeBoth;\n    move.isRemovedOnCompletion = false\n    move.delegate = self;\n    self.myView.layer.add(move, forKey: nil)\n}\n\noverride func animationDidStop(_ anim: CAAnimation, finished flag: Bool) {\n    DispatchQueue.main.after(when: .now() + 3) {\n        self.myView.layer.removeAllAnimations()\n    }\n}\n```\n\n运行效果如下：\n\n![kCAFillModeBoth](http://7xn88v.com1.z0.glb.clouddn.com/kCAFillModeBoth.gif)\n\n可以看到，鼠标点击后，myView立刻移动到了动画的初始位置，然后动画结束后，等待了3s，myView才恢复到原来的位置。\n\n## 更进一步的思考\n\n以上就是我对fillMode的一个探究，下面再回到文章开头的那段代码\n\n```swift\nanimation.fillMode = kCAFillModeBoth\nanimation.isRemovedOnCompletion = false\n```\n\n这时，就很明白了，设置fillMode为`kCAFillModeBoth`，可以使视图在动画结束时，仍然停留在动画结束的位置，直到动画被删除。设置`isRemovedOnCompletion`为false，可以使动画在结束后不被删除，这样视图就会永远停留在动画结束的位置。\n\n乍一看没什么问题，但仔细想想还是觉得有点奇怪，动画已经结束了为什么不删除，还占着内存。如果动画少还好，如果动画非常多，每个动画执行完了都不删除的话，那内存岂不是会爆掉，这是不能接受的。有没有办法能够既让视图停留在动画结束的位置，又能在动画结束后删除动画呢？\n\n当然有，直接上代码：\n\n```swift\noverride func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {\n    let move = CABasicAnimation(keyPath: \"position.y\")\n    move.fromValue = 100\n    move.toValue = 500\n    move.duration = 1.0\n    move.beginTime = CACurrentMediaTime() + 2.0\n    move.fillMode = kCAFillModeBoth;\n    move.delegate = self;\n    self.myView.layer.add(move, forKey: nil)\n\n    self.myView.layer.position.y = 500\n}\n```\n\n解决方法就是在视图添加动画后，手动修改视图的位置为动画结束后的最终位置，这样动画结束后，动画就会被删除并且视图会停留在动画结束时的位置。\n\n注意：这里应该使用layer的position，不能直接修改UIView的frame，否则动画效果会不正确。\n\n## 参考资料\n\n[iOS Animations by Tutorials](https://www.raywenderlich.com/store/ios-animations-by-tutorials)\n","source":"_posts/2016-07-10-深入理解CoreAnimation的fillMode和isRemovedOnCompletion.md","raw":"---\ntitle: 深入理解CoreAnimation的fillMode和isRemovedOnCompletion\ncategories: iOS开发\ntags:\n  - CoreAnimation\ndate: 2016-07-10 14:34:06\n---\n\n一般在使用CoreAnimation写动画是，在定义CAAnimation时，都要加入如下两句来防止动画完成后视图的位置又还原成了原来的位置。\n\n```swift\nanimation.fillMode = kCAFillModeBoth\nanimation.isRemovedOnCompletion = false\n```\n\n很少有文章能详细说明这两个属性的作用，今天我们就来深究一下这两个属性。\n\n## fillMode\n\nfillMode是一个枚举值，用于表示动画在开始和结束时的状态，这样说可能不太好理解，直接看例子比较直观。\n\n### kCAFillModeRemoved\n\n这个是fillMode的默认值，表示在到达beginTime时才显示动画的第一帧，动画结束时，删除CALayer做的变化\n\n实例代码：\n\n```swift\noverride func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent?) {\n    let move = CABasicAnimation(keyPath: \"position.y\")\n    move.fromValue = 100\n    move.toValue = 500\n    move.duration = 1.0\n    move.beginTime = CACurrentMediaTime() + 2.0\n    move.fillMode = kCAFillModeRemoved\n    self.myView.layer.add(move, forKey: nil)\n}\n```\n\n代码中，我们将一个View的y坐标从100移动到500，历时1s，注意开始时间我设定为了`CACurrentMediaTime() + 2.0`，即添加动画2s后才开始执行动画，这样才能看到效果。运行结果如下：\n\n![kCAFillModeRemoved](http://7xn88v.com1.z0.glb.clouddn.com/kCAFillModeRemoved.gif)\n\n可以看到，在鼠标点击触发后，2s之后myView才移动到了动画的初始位置100开始执行动画，并且在动画结束后视图又立刻恢复到原来的位置。\n\n### kCAFillModeBackwards\n\n这个值表示无论是否到达beginTime，动画开始后，立刻显示动画的第一帧，修改代码如下：\n\n```swift\noverride func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent?) {\n    let move = CABasicAnimation(keyPath: \"position.y\")\n    move.fromValue = 100\n    move.toValue = 500\n    move.duration = 1.0\n    move.beginTime = CACurrentMediaTime() + 2.0\n    move.fillMode = kCAFillModeBackwards\n    self.myView.layer.add(move, forKey: nil)\n}\n```\n\n运行效果如下：\n\n![kCAFillModeBackwards](http://7xn88v.com1.z0.glb.clouddn.com/kCAFillModeBackwards.gif)\n\n可以看到，鼠标点击后，myView立刻移动到了动画的初始位置100，然后2s后开始执行动画。\n\n### kCAFillModeForwards\n\n这个值表示在到达beginTime时显示动画的第一帧，在动画结束时，保持动画最后一帧的状态，直到动画被删除，修改代码如下：\n\n```swift\noverride func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {\n    let move = CABasicAnimation(keyPath: \"position.y\")\n    move.fromValue = 100\n    move.toValue = 500\n    move.duration = 1.0\n    move.beginTime = CACurrentMediaTime() + 2.0\n    move.fillMode = kCAFillModeForwards;\n    move.isRemovedOnCompletion = false\n    move.delegate = self;\n    self.myView.layer.add(move, forKey: nil)\n}\n\noverride func animationDidStop(_ anim: CAAnimation, finished flag: Bool) {\n    DispatchQueue.main.after(when: .now() + 3) {\n        self.myView.layer.removeAllAnimations()\n    }\n}\n```\n\n代码中添加了`move.isRemovedOnCompletion = false`，即动画执行完后不立刻删除动画，默认情况下，动画执行完后会立刻删除动画。`isRemovedOnCompletion`属性设置为false后，就不会立刻删除。然后我们还添加了`animationDidStop`方法，这个是`CABasicAnimation`的代理方法，在动画执行结束时会被调用。我们在这个方法里延时3s删除动画。运行效果如下：\n\n![kCAFillModeForwards](http://7xn88v.com1.z0.glb.clouddn.com/kCAFillModeForwards.gif)\n\n可以看到，鼠标点击后，myView等了2s才移动到动画初始位置，动画结束后，等待了3s，myView才恢复到原来的位置。也就是动画结束后会保持最后一帧的状态，直到动画被删除掉。\n\n### kCAFillModeBoth\n\n这个值相当于kCAFillModeBackwards与kCAFillModeForwards的共同合集，即无论是否到达beginTime，动画开始后，立刻显示动画的第一帧，并且在动画结束时保持最后一帧的状态，直到动画被删除。修改代码如下：\n\n```swift\noverride func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {\n    let move = CABasicAnimation(keyPath: \"position.y\")\n    move.fromValue = 100\n    move.toValue = 500\n    move.duration = 1.0\n    move.beginTime = CACurrentMediaTime() + 2.0\n    move.fillMode = kCAFillModeBoth;\n    move.isRemovedOnCompletion = false\n    move.delegate = self;\n    self.myView.layer.add(move, forKey: nil)\n}\n\noverride func animationDidStop(_ anim: CAAnimation, finished flag: Bool) {\n    DispatchQueue.main.after(when: .now() + 3) {\n        self.myView.layer.removeAllAnimations()\n    }\n}\n```\n\n运行效果如下：\n\n![kCAFillModeBoth](http://7xn88v.com1.z0.glb.clouddn.com/kCAFillModeBoth.gif)\n\n可以看到，鼠标点击后，myView立刻移动到了动画的初始位置，然后动画结束后，等待了3s，myView才恢复到原来的位置。\n\n## 更进一步的思考\n\n以上就是我对fillMode的一个探究，下面再回到文章开头的那段代码\n\n```swift\nanimation.fillMode = kCAFillModeBoth\nanimation.isRemovedOnCompletion = false\n```\n\n这时，就很明白了，设置fillMode为`kCAFillModeBoth`，可以使视图在动画结束时，仍然停留在动画结束的位置，直到动画被删除。设置`isRemovedOnCompletion`为false，可以使动画在结束后不被删除，这样视图就会永远停留在动画结束的位置。\n\n乍一看没什么问题，但仔细想想还是觉得有点奇怪，动画已经结束了为什么不删除，还占着内存。如果动画少还好，如果动画非常多，每个动画执行完了都不删除的话，那内存岂不是会爆掉，这是不能接受的。有没有办法能够既让视图停留在动画结束的位置，又能在动画结束后删除动画呢？\n\n当然有，直接上代码：\n\n```swift\noverride func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {\n    let move = CABasicAnimation(keyPath: \"position.y\")\n    move.fromValue = 100\n    move.toValue = 500\n    move.duration = 1.0\n    move.beginTime = CACurrentMediaTime() + 2.0\n    move.fillMode = kCAFillModeBoth;\n    move.delegate = self;\n    self.myView.layer.add(move, forKey: nil)\n\n    self.myView.layer.position.y = 500\n}\n```\n\n解决方法就是在视图添加动画后，手动修改视图的位置为动画结束后的最终位置，这样动画结束后，动画就会被删除并且视图会停留在动画结束时的位置。\n\n注意：这里应该使用layer的position，不能直接修改UIView的frame，否则动画效果会不正确。\n\n## 参考资料\n\n[iOS Animations by Tutorials](https://www.raywenderlich.com/store/ios-animations-by-tutorials)\n","slug":"深入理解CoreAnimation的fillMode和isRemovedOnCompletion","published":1,"updated":"2016-08-12T15:20:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis94oac70028zrm0wyc59x16","content":"<p>一般在使用CoreAnimation写动画是，在定义CAAnimation时，都要加入如下两句来防止动画完成后视图的位置又还原成了原来的位置。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">animation.fillMode = kCAFillModeBoth</div><div class=\"line\">animation.isRemovedOnCompletion = <span class=\"literal\">false</span></div></pre></td></tr></table></figure>\n<p>很少有文章能详细说明这两个属性的作用，今天我们就来深究一下这两个属性。</p>\n<h2 id=\"fillMode\"><a href=\"#fillMode\" class=\"headerlink\" title=\"fillMode\"></a>fillMode</h2><p>fillMode是一个枚举值，用于表示动画在开始和结束时的状态，这样说可能不太好理解，直接看例子比较直观。</p>\n<h3 id=\"kCAFillModeRemoved\"><a href=\"#kCAFillModeRemoved\" class=\"headerlink\" title=\"kCAFillModeRemoved\"></a>kCAFillModeRemoved</h3><p>这个是fillMode的默认值，表示在到达beginTime时才显示动画的第一帧，动画结束时，删除CALayer做的变化</p>\n<p>实例代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">touchesBegan</span><span class=\"params\">(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> move = <span class=\"type\">CABasicAnimation</span>(keyPath: <span class=\"string\">\"position.y\"</span>)</div><div class=\"line\">    move.fromValue = <span class=\"number\">100</span></div><div class=\"line\">    move.toValue = <span class=\"number\">500</span></div><div class=\"line\">    move.duration = <span class=\"number\">1.0</span></div><div class=\"line\">    move.beginTime = <span class=\"type\">CACurrentMediaTime</span>() + <span class=\"number\">2.0</span></div><div class=\"line\">    move.fillMode = kCAFillModeRemoved</div><div class=\"line\">    <span class=\"keyword\">self</span>.myView.layer.add(move, forKey: <span class=\"literal\">nil</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码中，我们将一个View的y坐标从100移动到500，历时1s，注意开始时间我设定为了<code>CACurrentMediaTime() + 2.0</code>，即添加动画2s后才开始执行动画，这样才能看到效果。运行结果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/kCAFillModeRemoved.gif\" alt=\"kCAFillModeRemoved\"></p>\n<p>可以看到，在鼠标点击触发后，2s之后myView才移动到了动画的初始位置100开始执行动画，并且在动画结束后视图又立刻恢复到原来的位置。</p>\n<h3 id=\"kCAFillModeBackwards\"><a href=\"#kCAFillModeBackwards\" class=\"headerlink\" title=\"kCAFillModeBackwards\"></a>kCAFillModeBackwards</h3><p>这个值表示无论是否到达beginTime，动画开始后，立刻显示动画的第一帧，修改代码如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">touchesBegan</span><span class=\"params\">(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> move = <span class=\"type\">CABasicAnimation</span>(keyPath: <span class=\"string\">\"position.y\"</span>)</div><div class=\"line\">    move.fromValue = <span class=\"number\">100</span></div><div class=\"line\">    move.toValue = <span class=\"number\">500</span></div><div class=\"line\">    move.duration = <span class=\"number\">1.0</span></div><div class=\"line\">    move.beginTime = <span class=\"type\">CACurrentMediaTime</span>() + <span class=\"number\">2.0</span></div><div class=\"line\">    move.fillMode = kCAFillModeBackwards</div><div class=\"line\">    <span class=\"keyword\">self</span>.myView.layer.add(move, forKey: <span class=\"literal\">nil</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行效果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/kCAFillModeBackwards.gif\" alt=\"kCAFillModeBackwards\"></p>\n<p>可以看到，鼠标点击后，myView立刻移动到了动画的初始位置100，然后2s后开始执行动画。</p>\n<h3 id=\"kCAFillModeForwards\"><a href=\"#kCAFillModeForwards\" class=\"headerlink\" title=\"kCAFillModeForwards\"></a>kCAFillModeForwards</h3><p>这个值表示在到达beginTime时显示动画的第一帧，在动画结束时，保持动画最后一帧的状态，直到动画被删除，修改代码如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">touchesBegan</span><span class=\"params\">(<span class=\"number\">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> move = <span class=\"type\">CABasicAnimation</span>(keyPath: <span class=\"string\">\"position.y\"</span>)</div><div class=\"line\">    move.fromValue = <span class=\"number\">100</span></div><div class=\"line\">    move.toValue = <span class=\"number\">500</span></div><div class=\"line\">    move.duration = <span class=\"number\">1.0</span></div><div class=\"line\">    move.beginTime = <span class=\"type\">CACurrentMediaTime</span>() + <span class=\"number\">2.0</span></div><div class=\"line\">    move.fillMode = kCAFillModeForwards;</div><div class=\"line\">    move.isRemovedOnCompletion = <span class=\"literal\">false</span></div><div class=\"line\">    move.delegate = <span class=\"keyword\">self</span>;</div><div class=\"line\">    <span class=\"keyword\">self</span>.myView.layer.add(move, forKey: <span class=\"literal\">nil</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationDidStop</span><span class=\"params\">(<span class=\"number\">_</span> anim: CAAnimation, finished flag: Bool)</span></span> &#123;</div><div class=\"line\">    <span class=\"type\">DispatchQueue</span>.main.after(when: .now() + <span class=\"number\">3</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.myView.layer.removeAllAnimations()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码中添加了<code>move.isRemovedOnCompletion = false</code>，即动画执行完后不立刻删除动画，默认情况下，动画执行完后会立刻删除动画。<code>isRemovedOnCompletion</code>属性设置为false后，就不会立刻删除。然后我们还添加了<code>animationDidStop</code>方法，这个是<code>CABasicAnimation</code>的代理方法，在动画执行结束时会被调用。我们在这个方法里延时3s删除动画。运行效果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/kCAFillModeForwards.gif\" alt=\"kCAFillModeForwards\"></p>\n<p>可以看到，鼠标点击后，myView等了2s才移动到动画初始位置，动画结束后，等待了3s，myView才恢复到原来的位置。也就是动画结束后会保持最后一帧的状态，直到动画被删除掉。</p>\n<h3 id=\"kCAFillModeBoth\"><a href=\"#kCAFillModeBoth\" class=\"headerlink\" title=\"kCAFillModeBoth\"></a>kCAFillModeBoth</h3><p>这个值相当于kCAFillModeBackwards与kCAFillModeForwards的共同合集，即无论是否到达beginTime，动画开始后，立刻显示动画的第一帧，并且在动画结束时保持最后一帧的状态，直到动画被删除。修改代码如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">touchesBegan</span><span class=\"params\">(<span class=\"number\">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> move = <span class=\"type\">CABasicAnimation</span>(keyPath: <span class=\"string\">\"position.y\"</span>)</div><div class=\"line\">    move.fromValue = <span class=\"number\">100</span></div><div class=\"line\">    move.toValue = <span class=\"number\">500</span></div><div class=\"line\">    move.duration = <span class=\"number\">1.0</span></div><div class=\"line\">    move.beginTime = <span class=\"type\">CACurrentMediaTime</span>() + <span class=\"number\">2.0</span></div><div class=\"line\">    move.fillMode = kCAFillModeBoth;</div><div class=\"line\">    move.isRemovedOnCompletion = <span class=\"literal\">false</span></div><div class=\"line\">    move.delegate = <span class=\"keyword\">self</span>;</div><div class=\"line\">    <span class=\"keyword\">self</span>.myView.layer.add(move, forKey: <span class=\"literal\">nil</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationDidStop</span><span class=\"params\">(<span class=\"number\">_</span> anim: CAAnimation, finished flag: Bool)</span></span> &#123;</div><div class=\"line\">    <span class=\"type\">DispatchQueue</span>.main.after(when: .now() + <span class=\"number\">3</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.myView.layer.removeAllAnimations()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行效果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/kCAFillModeBoth.gif\" alt=\"kCAFillModeBoth\"></p>\n<p>可以看到，鼠标点击后，myView立刻移动到了动画的初始位置，然后动画结束后，等待了3s，myView才恢复到原来的位置。</p>\n<h2 id=\"更进一步的思考\"><a href=\"#更进一步的思考\" class=\"headerlink\" title=\"更进一步的思考\"></a>更进一步的思考</h2><p>以上就是我对fillMode的一个探究，下面再回到文章开头的那段代码</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">animation.fillMode = kCAFillModeBoth</div><div class=\"line\">animation.isRemovedOnCompletion = <span class=\"literal\">false</span></div></pre></td></tr></table></figure>\n<p>这时，就很明白了，设置fillMode为<code>kCAFillModeBoth</code>，可以使视图在动画结束时，仍然停留在动画结束的位置，直到动画被删除。设置<code>isRemovedOnCompletion</code>为false，可以使动画在结束后不被删除，这样视图就会永远停留在动画结束的位置。</p>\n<p>乍一看没什么问题，但仔细想想还是觉得有点奇怪，动画已经结束了为什么不删除，还占着内存。如果动画少还好，如果动画非常多，每个动画执行完了都不删除的话，那内存岂不是会爆掉，这是不能接受的。有没有办法能够既让视图停留在动画结束的位置，又能在动画结束后删除动画呢？</p>\n<p>当然有，直接上代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">touchesBegan</span><span class=\"params\">(<span class=\"number\">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> move = <span class=\"type\">CABasicAnimation</span>(keyPath: <span class=\"string\">\"position.y\"</span>)</div><div class=\"line\">    move.fromValue = <span class=\"number\">100</span></div><div class=\"line\">    move.toValue = <span class=\"number\">500</span></div><div class=\"line\">    move.duration = <span class=\"number\">1.0</span></div><div class=\"line\">    move.beginTime = <span class=\"type\">CACurrentMediaTime</span>() + <span class=\"number\">2.0</span></div><div class=\"line\">    move.fillMode = kCAFillModeBoth;</div><div class=\"line\">    move.delegate = <span class=\"keyword\">self</span>;</div><div class=\"line\">    <span class=\"keyword\">self</span>.myView.layer.add(move, forKey: <span class=\"literal\">nil</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.myView.layer.position.y = <span class=\"number\">500</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解决方法就是在视图添加动画后，手动修改视图的位置为动画结束后的最终位置，这样动画结束后，动画就会被删除并且视图会停留在动画结束时的位置。</p>\n<p>注意：这里应该使用layer的position，不能直接修改UIView的frame，否则动画效果会不正确。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://www.raywenderlich.com/store/ios-animations-by-tutorials\" target=\"_blank\" rel=\"external\">iOS Animations by Tutorials</a></p>\n","excerpt":"","more":"<p>一般在使用CoreAnimation写动画是，在定义CAAnimation时，都要加入如下两句来防止动画完成后视图的位置又还原成了原来的位置。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">animation.fillMode = kCAFillModeBoth</div><div class=\"line\">animation.isRemovedOnCompletion = <span class=\"literal\">false</span></div></pre></td></tr></table></figure>\n<p>很少有文章能详细说明这两个属性的作用，今天我们就来深究一下这两个属性。</p>\n<h2 id=\"fillMode\"><a href=\"#fillMode\" class=\"headerlink\" title=\"fillMode\"></a>fillMode</h2><p>fillMode是一个枚举值，用于表示动画在开始和结束时的状态，这样说可能不太好理解，直接看例子比较直观。</p>\n<h3 id=\"kCAFillModeRemoved\"><a href=\"#kCAFillModeRemoved\" class=\"headerlink\" title=\"kCAFillModeRemoved\"></a>kCAFillModeRemoved</h3><p>这个是fillMode的默认值，表示在到达beginTime时才显示动画的第一帧，动画结束时，删除CALayer做的变化</p>\n<p>实例代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">touchesBegan</span><span class=\"params\">(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> move = <span class=\"type\">CABasicAnimation</span>(keyPath: <span class=\"string\">\"position.y\"</span>)</div><div class=\"line\">    move.fromValue = <span class=\"number\">100</span></div><div class=\"line\">    move.toValue = <span class=\"number\">500</span></div><div class=\"line\">    move.duration = <span class=\"number\">1.0</span></div><div class=\"line\">    move.beginTime = <span class=\"type\">CACurrentMediaTime</span>() + <span class=\"number\">2.0</span></div><div class=\"line\">    move.fillMode = kCAFillModeRemoved</div><div class=\"line\">    <span class=\"keyword\">self</span>.myView.layer.add(move, forKey: <span class=\"literal\">nil</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码中，我们将一个View的y坐标从100移动到500，历时1s，注意开始时间我设定为了<code>CACurrentMediaTime() + 2.0</code>，即添加动画2s后才开始执行动画，这样才能看到效果。运行结果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/kCAFillModeRemoved.gif\" alt=\"kCAFillModeRemoved\"></p>\n<p>可以看到，在鼠标点击触发后，2s之后myView才移动到了动画的初始位置100开始执行动画，并且在动画结束后视图又立刻恢复到原来的位置。</p>\n<h3 id=\"kCAFillModeBackwards\"><a href=\"#kCAFillModeBackwards\" class=\"headerlink\" title=\"kCAFillModeBackwards\"></a>kCAFillModeBackwards</h3><p>这个值表示无论是否到达beginTime，动画开始后，立刻显示动画的第一帧，修改代码如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">touchesBegan</span><span class=\"params\">(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> move = <span class=\"type\">CABasicAnimation</span>(keyPath: <span class=\"string\">\"position.y\"</span>)</div><div class=\"line\">    move.fromValue = <span class=\"number\">100</span></div><div class=\"line\">    move.toValue = <span class=\"number\">500</span></div><div class=\"line\">    move.duration = <span class=\"number\">1.0</span></div><div class=\"line\">    move.beginTime = <span class=\"type\">CACurrentMediaTime</span>() + <span class=\"number\">2.0</span></div><div class=\"line\">    move.fillMode = kCAFillModeBackwards</div><div class=\"line\">    <span class=\"keyword\">self</span>.myView.layer.add(move, forKey: <span class=\"literal\">nil</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行效果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/kCAFillModeBackwards.gif\" alt=\"kCAFillModeBackwards\"></p>\n<p>可以看到，鼠标点击后，myView立刻移动到了动画的初始位置100，然后2s后开始执行动画。</p>\n<h3 id=\"kCAFillModeForwards\"><a href=\"#kCAFillModeForwards\" class=\"headerlink\" title=\"kCAFillModeForwards\"></a>kCAFillModeForwards</h3><p>这个值表示在到达beginTime时显示动画的第一帧，在动画结束时，保持动画最后一帧的状态，直到动画被删除，修改代码如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">touchesBegan</span><span class=\"params\">(<span class=\"number\">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> move = <span class=\"type\">CABasicAnimation</span>(keyPath: <span class=\"string\">\"position.y\"</span>)</div><div class=\"line\">    move.fromValue = <span class=\"number\">100</span></div><div class=\"line\">    move.toValue = <span class=\"number\">500</span></div><div class=\"line\">    move.duration = <span class=\"number\">1.0</span></div><div class=\"line\">    move.beginTime = <span class=\"type\">CACurrentMediaTime</span>() + <span class=\"number\">2.0</span></div><div class=\"line\">    move.fillMode = kCAFillModeForwards;</div><div class=\"line\">    move.isRemovedOnCompletion = <span class=\"literal\">false</span></div><div class=\"line\">    move.delegate = <span class=\"keyword\">self</span>;</div><div class=\"line\">    <span class=\"keyword\">self</span>.myView.layer.add(move, forKey: <span class=\"literal\">nil</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationDidStop</span><span class=\"params\">(<span class=\"number\">_</span> anim: CAAnimation, finished flag: Bool)</span></span> &#123;</div><div class=\"line\">    <span class=\"type\">DispatchQueue</span>.main.after(when: .now() + <span class=\"number\">3</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.myView.layer.removeAllAnimations()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码中添加了<code>move.isRemovedOnCompletion = false</code>，即动画执行完后不立刻删除动画，默认情况下，动画执行完后会立刻删除动画。<code>isRemovedOnCompletion</code>属性设置为false后，就不会立刻删除。然后我们还添加了<code>animationDidStop</code>方法，这个是<code>CABasicAnimation</code>的代理方法，在动画执行结束时会被调用。我们在这个方法里延时3s删除动画。运行效果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/kCAFillModeForwards.gif\" alt=\"kCAFillModeForwards\"></p>\n<p>可以看到，鼠标点击后，myView等了2s才移动到动画初始位置，动画结束后，等待了3s，myView才恢复到原来的位置。也就是动画结束后会保持最后一帧的状态，直到动画被删除掉。</p>\n<h3 id=\"kCAFillModeBoth\"><a href=\"#kCAFillModeBoth\" class=\"headerlink\" title=\"kCAFillModeBoth\"></a>kCAFillModeBoth</h3><p>这个值相当于kCAFillModeBackwards与kCAFillModeForwards的共同合集，即无论是否到达beginTime，动画开始后，立刻显示动画的第一帧，并且在动画结束时保持最后一帧的状态，直到动画被删除。修改代码如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">touchesBegan</span><span class=\"params\">(<span class=\"number\">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> move = <span class=\"type\">CABasicAnimation</span>(keyPath: <span class=\"string\">\"position.y\"</span>)</div><div class=\"line\">    move.fromValue = <span class=\"number\">100</span></div><div class=\"line\">    move.toValue = <span class=\"number\">500</span></div><div class=\"line\">    move.duration = <span class=\"number\">1.0</span></div><div class=\"line\">    move.beginTime = <span class=\"type\">CACurrentMediaTime</span>() + <span class=\"number\">2.0</span></div><div class=\"line\">    move.fillMode = kCAFillModeBoth;</div><div class=\"line\">    move.isRemovedOnCompletion = <span class=\"literal\">false</span></div><div class=\"line\">    move.delegate = <span class=\"keyword\">self</span>;</div><div class=\"line\">    <span class=\"keyword\">self</span>.myView.layer.add(move, forKey: <span class=\"literal\">nil</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationDidStop</span><span class=\"params\">(<span class=\"number\">_</span> anim: CAAnimation, finished flag: Bool)</span></span> &#123;</div><div class=\"line\">    <span class=\"type\">DispatchQueue</span>.main.after(when: .now() + <span class=\"number\">3</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.myView.layer.removeAllAnimations()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行效果如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/kCAFillModeBoth.gif\" alt=\"kCAFillModeBoth\"></p>\n<p>可以看到，鼠标点击后，myView立刻移动到了动画的初始位置，然后动画结束后，等待了3s，myView才恢复到原来的位置。</p>\n<h2 id=\"更进一步的思考\"><a href=\"#更进一步的思考\" class=\"headerlink\" title=\"更进一步的思考\"></a>更进一步的思考</h2><p>以上就是我对fillMode的一个探究，下面再回到文章开头的那段代码</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">animation.fillMode = kCAFillModeBoth</div><div class=\"line\">animation.isRemovedOnCompletion = <span class=\"literal\">false</span></div></pre></td></tr></table></figure>\n<p>这时，就很明白了，设置fillMode为<code>kCAFillModeBoth</code>，可以使视图在动画结束时，仍然停留在动画结束的位置，直到动画被删除。设置<code>isRemovedOnCompletion</code>为false，可以使动画在结束后不被删除，这样视图就会永远停留在动画结束的位置。</p>\n<p>乍一看没什么问题，但仔细想想还是觉得有点奇怪，动画已经结束了为什么不删除，还占着内存。如果动画少还好，如果动画非常多，每个动画执行完了都不删除的话，那内存岂不是会爆掉，这是不能接受的。有没有办法能够既让视图停留在动画结束的位置，又能在动画结束后删除动画呢？</p>\n<p>当然有，直接上代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">touchesBegan</span><span class=\"params\">(<span class=\"number\">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> move = <span class=\"type\">CABasicAnimation</span>(keyPath: <span class=\"string\">\"position.y\"</span>)</div><div class=\"line\">    move.fromValue = <span class=\"number\">100</span></div><div class=\"line\">    move.toValue = <span class=\"number\">500</span></div><div class=\"line\">    move.duration = <span class=\"number\">1.0</span></div><div class=\"line\">    move.beginTime = <span class=\"type\">CACurrentMediaTime</span>() + <span class=\"number\">2.0</span></div><div class=\"line\">    move.fillMode = kCAFillModeBoth;</div><div class=\"line\">    move.delegate = <span class=\"keyword\">self</span>;</div><div class=\"line\">    <span class=\"keyword\">self</span>.myView.layer.add(move, forKey: <span class=\"literal\">nil</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.myView.layer.position.y = <span class=\"number\">500</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解决方法就是在视图添加动画后，手动修改视图的位置为动画结束后的最终位置，这样动画结束后，动画就会被删除并且视图会停留在动画结束时的位置。</p>\n<p>注意：这里应该使用layer的position，不能直接修改UIView的frame，否则动画效果会不正确。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://www.raywenderlich.com/store/ios-animations-by-tutorials\">iOS Animations by Tutorials</a></p>\n"},{"title":"UIButton设置标题无效","date":"2016-07-26T15:19:02.000Z","_content":"\nUIButton在使用`setAttributedTitle:forState:`设置了富文本标题后，是使用`setTitle:forState:`设置标题是没有效果的，解决方案是先把富文本去掉，然后再使用`setTitle:forState:`设置标题，或者直接使用`setAttributedTitle:forState:`重新设置不带属性的富文本。代码如下：\n\n```objectivec\n[self.payButton setAttributedTitle:nil forState:UIControlStateNormal];\n[self.payButton setTitle:@\"余额不足，去充值\" forState:UIControlStateNormal];\n```\n","source":"_posts/2016-07-26-UIButton设置标题无效.md","raw":"---\ntitle: UIButton设置标题无效\ncategories: iOS Tips\ntags:\n  - UIButton\ndate: 2016-07-26 23:19:02\n---\n\nUIButton在使用`setAttributedTitle:forState:`设置了富文本标题后，是使用`setTitle:forState:`设置标题是没有效果的，解决方案是先把富文本去掉，然后再使用`setTitle:forState:`设置标题，或者直接使用`setAttributedTitle:forState:`重新设置不带属性的富文本。代码如下：\n\n```objectivec\n[self.payButton setAttributedTitle:nil forState:UIControlStateNormal];\n[self.payButton setTitle:@\"余额不足，去充值\" forState:UIControlStateNormal];\n```\n","slug":"UIButton设置标题无效","published":1,"updated":"2016-08-12T15:20:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis94oaca002azrm0xcvvxg9h","content":"<p>UIButton在使用<code>setAttributedTitle:forState:</code>设置了富文本标题后，是使用<code>setTitle:forState:</code>设置标题是没有效果的，解决方案是先把富文本去掉，然后再使用<code>setTitle:forState:</code>设置标题，或者直接使用<code>setAttributedTitle:forState:</code>重新设置不带属性的富文本。代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span>.payButton setAttributedTitle:<span class=\"literal\">nil</span> forState:<span class=\"built_in\">UIControlStateNormal</span>];</div><div class=\"line\">[<span class=\"keyword\">self</span>.payButton setTitle:<span class=\"string\">@\"余额不足，去充值\"</span> forState:<span class=\"built_in\">UIControlStateNormal</span>];</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>UIButton在使用<code>setAttributedTitle:forState:</code>设置了富文本标题后，是使用<code>setTitle:forState:</code>设置标题是没有效果的，解决方案是先把富文本去掉，然后再使用<code>setTitle:forState:</code>设置标题，或者直接使用<code>setAttributedTitle:forState:</code>重新设置不带属性的富文本。代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span>.payButton setAttributedTitle:<span class=\"literal\">nil</span> forState:<span class=\"built_in\">UIControlStateNormal</span>];</div><div class=\"line\">[<span class=\"keyword\">self</span>.payButton setTitle:<span class=\"string\">@\"余额不足，去充值\"</span> forState:<span class=\"built_in\">UIControlStateNormal</span>];</div></pre></td></tr></table></figure>\n"},{"title":"使用HTTPS方法clone下来的Git仓库push时报错","date":"2016-07-30T03:22:55.000Z","_content":"\n昨天在使用Git时遇到了一个问题，今天记录一下。\n\n一般我在克隆Github的项目时都是使用ssh的方式进行的，这样只要你的ssh-key配置正确，就没有问题。昨天心血来潮试了一下https克隆了一个项目，修改完后，准备push的时候需要了问题，问题如下：\n\n\n>remote: Permission to liujinlongxa/Spoon-Knife.git denied to xxxx.\nfatal: unable to access 'https://github.com/liujinlongxa/Spoon-Knife.git/': The requested URL returned error: 403\n\n解决方案是修改git的配置文件，\n\n`vim .git/config`\n\n将\n\n\n>[remote \"origin\"]\n        url = https://github.com/liujinlongxa/Spoon-Knife.git\n\n\n改为\n\n\n>[remote \"origin\"]\n        url = https://liujinlongxa@github.com/liujinlongxa/Spoon-Knife.git\n\n即前面加上用户名，这样就可以正常的push，或者直接运行命令\n\n```shell\ngit config --local remote.origin.url https://liujinlongxa@github.com/liujinlongxa/Spoon-Knife.git\n```\n\n也可以达到相同的效果。\n","source":"_posts/2016-07-30-使用HTTPS方法clone下来的Git仓库push时报错.md","raw":"---\ntitle: 使用HTTPS方法clone下来的Git仓库push时报错\ncategories: Git\ntags:\n  - Git\ndate: 2016-07-30 11:22:55\n---\n\n昨天在使用Git时遇到了一个问题，今天记录一下。\n\n一般我在克隆Github的项目时都是使用ssh的方式进行的，这样只要你的ssh-key配置正确，就没有问题。昨天心血来潮试了一下https克隆了一个项目，修改完后，准备push的时候需要了问题，问题如下：\n\n\n>remote: Permission to liujinlongxa/Spoon-Knife.git denied to xxxx.\nfatal: unable to access 'https://github.com/liujinlongxa/Spoon-Knife.git/': The requested URL returned error: 403\n\n解决方案是修改git的配置文件，\n\n`vim .git/config`\n\n将\n\n\n>[remote \"origin\"]\n        url = https://github.com/liujinlongxa/Spoon-Knife.git\n\n\n改为\n\n\n>[remote \"origin\"]\n        url = https://liujinlongxa@github.com/liujinlongxa/Spoon-Knife.git\n\n即前面加上用户名，这样就可以正常的push，或者直接运行命令\n\n```shell\ngit config --local remote.origin.url https://liujinlongxa@github.com/liujinlongxa/Spoon-Knife.git\n```\n\n也可以达到相同的效果。\n","slug":"使用HTTPS方法clone下来的Git仓库push时报错","published":1,"updated":"2016-08-14T07:42:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis94oacd002ezrm0fpd0but5","content":"<p>昨天在使用Git时遇到了一个问题，今天记录一下。</p>\n<p>一般我在克隆Github的项目时都是使用ssh的方式进行的，这样只要你的ssh-key配置正确，就没有问题。昨天心血来潮试了一下https克隆了一个项目，修改完后，准备push的时候需要了问题，问题如下：</p>\n<blockquote>\n<p>remote: Permission to liujinlongxa/Spoon-Knife.git denied to xxxx.<br>fatal: unable to access ‘<a href=\"https://github.com/liujinlongxa/Spoon-Knife.git/\" target=\"_blank\" rel=\"external\">https://github.com/liujinlongxa/Spoon-Knife.git/</a>‘: The requested URL returned error: 403</p>\n</blockquote>\n<p>解决方案是修改git的配置文件，</p>\n<p><code>vim .git/config</code></p>\n<p>将</p>\n<blockquote>\n<p>[remote “origin”]<br>        url = <a href=\"https://github.com/liujinlongxa/Spoon-Knife.git\" target=\"_blank\" rel=\"external\">https://github.com/liujinlongxa/Spoon-Knife.git</a></p>\n</blockquote>\n<p>改为</p>\n<blockquote>\n<p>[remote “origin”]<br>        url = <a href=\"https://liujinlongxa@github.com/liujinlongxa/Spoon-Knife.git\" target=\"_blank\" rel=\"external\">https://liujinlongxa@github.com/liujinlongxa/Spoon-Knife.git</a></p>\n</blockquote>\n<p>即前面加上用户名，这样就可以正常的push，或者直接运行命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config --local remote.origin.url https://liujinlongxa@github.com/liujinlongxa/Spoon-Knife.git</div></pre></td></tr></table></figure>\n<p>也可以达到相同的效果。</p>\n","excerpt":"","more":"<p>昨天在使用Git时遇到了一个问题，今天记录一下。</p>\n<p>一般我在克隆Github的项目时都是使用ssh的方式进行的，这样只要你的ssh-key配置正确，就没有问题。昨天心血来潮试了一下https克隆了一个项目，修改完后，准备push的时候需要了问题，问题如下：</p>\n<blockquote>\n<p>remote: Permission to liujinlongxa/Spoon-Knife.git denied to xxxx.<br>fatal: unable to access ‘<a href=\"https://github.com/liujinlongxa/Spoon-Knife.git/\">https://github.com/liujinlongxa/Spoon-Knife.git/</a>‘: The requested URL returned error: 403</p>\n</blockquote>\n<p>解决方案是修改git的配置文件，</p>\n<p><code>vim .git/config</code></p>\n<p>将</p>\n<blockquote>\n<p>[remote “origin”]<br>        url = <a href=\"https://github.com/liujinlongxa/Spoon-Knife.git\">https://github.com/liujinlongxa/Spoon-Knife.git</a></p>\n</blockquote>\n<p>改为</p>\n<blockquote>\n<p>[remote “origin”]<br>        url = <a href=\"https://liujinlongxa@github.com/liujinlongxa/Spoon-Knife.git\">https://liujinlongxa@github.com/liujinlongxa/Spoon-Knife.git</a></p>\n</blockquote>\n<p>即前面加上用户名，这样就可以正常的push，或者直接运行命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config --local remote.origin.url https://liujinlongxa@github.com/liujinlongxa/Spoon-Knife.git</div></pre></td></tr></table></figure>\n<p>也可以达到相同的效果。</p>\n"},{"title":"在VPS上搭建Git服务器","date":"2016-08-07T07:27:52.000Z","_content":"\n昨天尝试了在自己的VPS上搭建一个git服务器，中间踩了很多坑，下面是我整个搭建的过程。\n\n## 具体流程\n\n### 第一步：安装Git\n\n打开VPS(这里我用的是[搬运工](https://bandwagonhost.com/index.php)，怎么购买VPS可以参考我的[这篇博客](http://liujinlongxa.com/2016/06/11/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BF%BB%E5%A2%99VPS:%E6%90%AC%E8%BF%90%E5%B7%A5VPS%E8%B4%AD%E4%B9%B0%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%E5%85%A8%E8%AE%B0%E5%BD%95/))的控制后台，进入Shell，然后输入命令：\n\n```shell\nyum install -y git\n```\n\n执行完后如图：\n\n![2](http://7xn88v.com1.z0.glb.clouddn.com/b9dd798ab599b9b53adebee98ebe5bbd.png)\n\n查看Git版本，如果能显示Git版本，则说明安装成功。\n\n![3](http://7xn88v.com1.z0.glb.clouddn.com/d7cdff1b7006e2c9b5f1e521319d903c.png)\n\n### 第二步：添加用户\n\n输入命令\n\n```shell\nadduser git\nsu git\n```\n\n添加一个名为git的用户，并且将当前用户切换到git\n\n![4](http://7xn88v.com1.z0.glb.clouddn.com/c5350088190cd59d220b4942b9d87eae.png)\n\n### 第三步：创建仓库\n\n创建一个文件夹用来存放git仓库，然后输入命令\n\n```shell\ngit init --bare mycode.git\n```\n\n这样就可以创建一个裸仓库，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，如下图：\n\n![5](http://7xn88v.com1.z0.glb.clouddn.com/c58f27e2d859d984c844371a43a37ab8.png)\n\n把服务器的git仓库的用户组改为git\n\n![6](http://7xn88v.com1.z0.glb.clouddn.com/26a614c08121e4b0f8783551208e2d19.png)\n\n这样仓库就创建完了\n\n### 第四步：创建证书\n\n在服务器/homg/git目录下创建文件夹.ssh，然后在.ssh文件夹里创建authorized_keys\n\n** 注意：一定要切换到git用户下再创建，否则使用root用户创建，会因为文件夹权限的问题而造成RSA校验失败，我就是在这里卡了半天 **\n\n然后在客户端创建公钥，即~/.ssh/id_rsa.pub文件里的内容，然后把公钥填入服务器的authorized_keys文件中\n\n![7](http://7xn88v.com1.z0.glb.clouddn.com/9eca6530c312dc064c8901735ef9942e.png)\n\n![8](http://7xn88v.com1.z0.glb.clouddn.com/7c38fa2c806440f162b83208038a8dc9.png)\n\n### 第五步：打开服务器RSA验证\n\n进入服务器/etc/ssh目录，使用vim打开sshd_config（建议先做一个备份），修改如下内容\n\n```shell\nRSAAuthentication yes     \nPubkeyAuthentication yes     \nAuthorizedKeysFile  .ssh/authorized_keys\n```\n\n大部分Linux系统的RSA认证默认就是开启的，如果已经开启，则可以忽略(在这里也卡了好久😭)\n\n![9](http://7xn88v.com1.z0.glb.clouddn.com/9d534724207d6319fcf654142e91ba24.png)\n\n然后保存退出，重新启动sshd\n\n![10](http://7xn88v.com1.z0.glb.clouddn.com/74d02be9217b7ea806af5970560ac956.png)\n\n### 第六步：修改指定服务器的ssh端口\n\n一般ssh访问默认的端口是22，但是搬运工VPS修改了ssh访问的端口，而Git访问还是用还是22端口，因此要修改Git使用ssh访问的端口(在这里也卡了好久😭)，要查看ssh端口可以在服务器的sshd_config文件中查看，如下：\n\n![11](http://7xn88v.com1.z0.glb.clouddn.com/b2f7743ffae9917e88f0ace60e11637b.png)\n\n 如果不想修改服务器端口配置，可以修改客户端访问端口。在客户端的/~/.ssh/config文件中添加如下两行，第一行是服务器的地址，第二行是服务器的端口\n\n![12](http://7xn88v.com1.z0.glb.clouddn.com/17e45daf40d28f1174387104a3daef40.png)\n\n这样就修改了访问指定服务器时的ssh端口。\n\n### 第七步：创建本地仓库\n\n经过以上六步，一个Git服务器就建立好了，现在你就可以把仓库clone下来，然后开始使用了。\n\n![13](http://7xn88v.com1.z0.glb.clouddn.com/285c535aa2610ae916b1f964617a8d68.png)\n\n## 遇到的坑\n\n在整个搭建过程中，我也踩了很多坑，下面对这些坑做一个总结。\n\n### 服务器与客户端ssh端口不一致\n\n在完成创建证书之后，按理说，应该已经可以clone仓库了，但是我尝试克隆会报如下错误：\n\n![14](http://7xn88v.com1.z0.glb.clouddn.com/e5bc21bbdb55bcdf473e6addf69cf495.png)\n\n网上找了很多方法，最后发现是因为客户端和服务器的ssh端口不一致导致，修改了客户端的ssh访问端口才解决了这个问题。\n\n相关参考：[修改了SSH默认端口之后，如何配置git？](http://zengrong.net/post/1544.htm)\n\n### ssh验证失败\n\n修改了ssh端口后，可以访问仓库了，但是每次访问都要输入密码，按理说我已经创建了证书，并且也把公钥放到了服务器，为什么还是不行呢？\n\n找了半天，发现服务器的RSA身份校验压根就没有开启，ssh在校验时是先使用RSA进行校验，如果校验失败再使用密码进行校验。修改sshd_config文件，打开身份校验，参照上面的第五步。\n\n打开身份校验之后，发现还是要输入密码。最初我的做法是关闭服务器的ssh密码校验，修改服务器/etc/ssh/sshd_config文件如下内容：\n\n```shell\nPasswordAuthentication no\n```\n\n![15](http://7xn88v.com1.z0.glb.clouddn.com/fadd0406c6a9e9c02402e170082c82c7.png)\n\n然后重启sshd。\n\n这样修改了之后，由于禁止了密码验证的方式，而RSA验证又失败，所以压根验证失败，访问都访问不了了。\n\n![16](http://7xn88v.com1.z0.glb.clouddn.com/2b0a4555687ea4fe8326f690ee35533e.png)\n\n然后我尝试看Log，输入命令：\n\n```shell\nssh git@xxx.xxx.xxx.xxx -vvv\n```\n\n从Log上看，客户端已经把key传给了服务器，但是服务器在验证时失败了，所以八成可能是服务器的问题。\n\n![20](http://7xn88v.com1.z0.glb.clouddn.com/8ec00cb79352b30a2f95a1b48410cdfe.png)\n\n然后我又根据[这篇博客](http://www.androiddev.net/ssh-public-key-authentication-error/)修改了目录的权限，但是还是不行。\n\n根据[这篇博客](http://flysnowxf.iteye.com/blog/1567570)关闭了SELinux也还是不行。\n\n然后我又根据[这篇博客](http://blog.csdn.net/lansesl2008/article/details/16113193)打开了ssh的log，修改sshd_config如下内容：\n\n![17](http://7xn88v.com1.z0.glb.clouddn.com/3dc7b3340f6b693b047ecbee93400564.png)\n\n然后又重新登录和退出几次ssh，在/var/log/secure里看到了如下内容：\n\n![18](http://7xn88v.com1.z0.glb.clouddn.com/4f320784c4d9d731d53b3792856ec4dd.png)\n\n并没有什么有用的信息，不知道是不是我的Log配置的有问题。\n\n找了很多资料，有很多文章都提到了文件夹权限的问题，于是我又回到服务器git目录下看了一下文件夹的权限：\n\n![19](http://7xn88v.com1.z0.glb.clouddn.com/c9be98241282c46c0111cb25e1be9aa4.png)\n\n原来我在创建.ssh目录是用的是root账户，所有造成ssh在进行身份认证时没有权限方位.ssh目录，导致认证失败。输入命令\n\n```shell\nchown git .ssh\n```\n\n将.ssh文件夹的所属用户改为git，.ssh里的authorized_keys文件也做相同的处理，这样改了之后终于可以验证成功了，并且不用输入密码了。\n\n## 总结\n\n整个搭建过程用了将近一天的时间，虽然过程有些曲折，但是最终还是成功了，而且这个过程中我也学到了不少的东西，更加深入的了解了ssh服务。\n\n希望这篇文章能对大家在搭建git服务器时有所帮助。\n\n## 参考资料\n\n[在CentOS下搭建自己的Git服务器](http://blog.csdn.net/wave_1102/article/details/47779401)\n[ssh无密码登录认证失败](http://blog.csdn.net/jacky0922/article/details/17999271)\n[sshd_config配置详解](http://blog.csdn.net/lansesl2008/article/details/16113193)\n[一个SSH 公钥登录失败的问题及解决经验](http://www.androiddev.net/ssh-public-key-authentication-error/)\n[Permission denied (publickey, gssapi-keyex,gssapi-with-mic,password)](http://www.linuxquestions.org/questions/linux-newbie-8/permission-denied-publickey-gssapi-keyex-gssapi-with-mic-password-4175413607/)\n[ssh使用公钥授权不通过的问题解决](http://flysnowxf.iteye.com/blog/1567570)\n[修改了SSH默认端口之后，如何配置git？](http://zengrong.net/post/1544.htm)\n","source":"_posts/2016-08-07-在VPS上搭建Git服务器.md","raw":"---\ntitle: 在VPS上搭建Git服务器\ncategories: Git\ntags:\n  - Git\ndate: 2016-08-07 15:27:52\n---\n\n昨天尝试了在自己的VPS上搭建一个git服务器，中间踩了很多坑，下面是我整个搭建的过程。\n\n## 具体流程\n\n### 第一步：安装Git\n\n打开VPS(这里我用的是[搬运工](https://bandwagonhost.com/index.php)，怎么购买VPS可以参考我的[这篇博客](http://liujinlongxa.com/2016/06/11/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BF%BB%E5%A2%99VPS:%E6%90%AC%E8%BF%90%E5%B7%A5VPS%E8%B4%AD%E4%B9%B0%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%E5%85%A8%E8%AE%B0%E5%BD%95/))的控制后台，进入Shell，然后输入命令：\n\n```shell\nyum install -y git\n```\n\n执行完后如图：\n\n![2](http://7xn88v.com1.z0.glb.clouddn.com/b9dd798ab599b9b53adebee98ebe5bbd.png)\n\n查看Git版本，如果能显示Git版本，则说明安装成功。\n\n![3](http://7xn88v.com1.z0.glb.clouddn.com/d7cdff1b7006e2c9b5f1e521319d903c.png)\n\n### 第二步：添加用户\n\n输入命令\n\n```shell\nadduser git\nsu git\n```\n\n添加一个名为git的用户，并且将当前用户切换到git\n\n![4](http://7xn88v.com1.z0.glb.clouddn.com/c5350088190cd59d220b4942b9d87eae.png)\n\n### 第三步：创建仓库\n\n创建一个文件夹用来存放git仓库，然后输入命令\n\n```shell\ngit init --bare mycode.git\n```\n\n这样就可以创建一个裸仓库，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，如下图：\n\n![5](http://7xn88v.com1.z0.glb.clouddn.com/c58f27e2d859d984c844371a43a37ab8.png)\n\n把服务器的git仓库的用户组改为git\n\n![6](http://7xn88v.com1.z0.glb.clouddn.com/26a614c08121e4b0f8783551208e2d19.png)\n\n这样仓库就创建完了\n\n### 第四步：创建证书\n\n在服务器/homg/git目录下创建文件夹.ssh，然后在.ssh文件夹里创建authorized_keys\n\n** 注意：一定要切换到git用户下再创建，否则使用root用户创建，会因为文件夹权限的问题而造成RSA校验失败，我就是在这里卡了半天 **\n\n然后在客户端创建公钥，即~/.ssh/id_rsa.pub文件里的内容，然后把公钥填入服务器的authorized_keys文件中\n\n![7](http://7xn88v.com1.z0.glb.clouddn.com/9eca6530c312dc064c8901735ef9942e.png)\n\n![8](http://7xn88v.com1.z0.glb.clouddn.com/7c38fa2c806440f162b83208038a8dc9.png)\n\n### 第五步：打开服务器RSA验证\n\n进入服务器/etc/ssh目录，使用vim打开sshd_config（建议先做一个备份），修改如下内容\n\n```shell\nRSAAuthentication yes     \nPubkeyAuthentication yes     \nAuthorizedKeysFile  .ssh/authorized_keys\n```\n\n大部分Linux系统的RSA认证默认就是开启的，如果已经开启，则可以忽略(在这里也卡了好久😭)\n\n![9](http://7xn88v.com1.z0.glb.clouddn.com/9d534724207d6319fcf654142e91ba24.png)\n\n然后保存退出，重新启动sshd\n\n![10](http://7xn88v.com1.z0.glb.clouddn.com/74d02be9217b7ea806af5970560ac956.png)\n\n### 第六步：修改指定服务器的ssh端口\n\n一般ssh访问默认的端口是22，但是搬运工VPS修改了ssh访问的端口，而Git访问还是用还是22端口，因此要修改Git使用ssh访问的端口(在这里也卡了好久😭)，要查看ssh端口可以在服务器的sshd_config文件中查看，如下：\n\n![11](http://7xn88v.com1.z0.glb.clouddn.com/b2f7743ffae9917e88f0ace60e11637b.png)\n\n 如果不想修改服务器端口配置，可以修改客户端访问端口。在客户端的/~/.ssh/config文件中添加如下两行，第一行是服务器的地址，第二行是服务器的端口\n\n![12](http://7xn88v.com1.z0.glb.clouddn.com/17e45daf40d28f1174387104a3daef40.png)\n\n这样就修改了访问指定服务器时的ssh端口。\n\n### 第七步：创建本地仓库\n\n经过以上六步，一个Git服务器就建立好了，现在你就可以把仓库clone下来，然后开始使用了。\n\n![13](http://7xn88v.com1.z0.glb.clouddn.com/285c535aa2610ae916b1f964617a8d68.png)\n\n## 遇到的坑\n\n在整个搭建过程中，我也踩了很多坑，下面对这些坑做一个总结。\n\n### 服务器与客户端ssh端口不一致\n\n在完成创建证书之后，按理说，应该已经可以clone仓库了，但是我尝试克隆会报如下错误：\n\n![14](http://7xn88v.com1.z0.glb.clouddn.com/e5bc21bbdb55bcdf473e6addf69cf495.png)\n\n网上找了很多方法，最后发现是因为客户端和服务器的ssh端口不一致导致，修改了客户端的ssh访问端口才解决了这个问题。\n\n相关参考：[修改了SSH默认端口之后，如何配置git？](http://zengrong.net/post/1544.htm)\n\n### ssh验证失败\n\n修改了ssh端口后，可以访问仓库了，但是每次访问都要输入密码，按理说我已经创建了证书，并且也把公钥放到了服务器，为什么还是不行呢？\n\n找了半天，发现服务器的RSA身份校验压根就没有开启，ssh在校验时是先使用RSA进行校验，如果校验失败再使用密码进行校验。修改sshd_config文件，打开身份校验，参照上面的第五步。\n\n打开身份校验之后，发现还是要输入密码。最初我的做法是关闭服务器的ssh密码校验，修改服务器/etc/ssh/sshd_config文件如下内容：\n\n```shell\nPasswordAuthentication no\n```\n\n![15](http://7xn88v.com1.z0.glb.clouddn.com/fadd0406c6a9e9c02402e170082c82c7.png)\n\n然后重启sshd。\n\n这样修改了之后，由于禁止了密码验证的方式，而RSA验证又失败，所以压根验证失败，访问都访问不了了。\n\n![16](http://7xn88v.com1.z0.glb.clouddn.com/2b0a4555687ea4fe8326f690ee35533e.png)\n\n然后我尝试看Log，输入命令：\n\n```shell\nssh git@xxx.xxx.xxx.xxx -vvv\n```\n\n从Log上看，客户端已经把key传给了服务器，但是服务器在验证时失败了，所以八成可能是服务器的问题。\n\n![20](http://7xn88v.com1.z0.glb.clouddn.com/8ec00cb79352b30a2f95a1b48410cdfe.png)\n\n然后我又根据[这篇博客](http://www.androiddev.net/ssh-public-key-authentication-error/)修改了目录的权限，但是还是不行。\n\n根据[这篇博客](http://flysnowxf.iteye.com/blog/1567570)关闭了SELinux也还是不行。\n\n然后我又根据[这篇博客](http://blog.csdn.net/lansesl2008/article/details/16113193)打开了ssh的log，修改sshd_config如下内容：\n\n![17](http://7xn88v.com1.z0.glb.clouddn.com/3dc7b3340f6b693b047ecbee93400564.png)\n\n然后又重新登录和退出几次ssh，在/var/log/secure里看到了如下内容：\n\n![18](http://7xn88v.com1.z0.glb.clouddn.com/4f320784c4d9d731d53b3792856ec4dd.png)\n\n并没有什么有用的信息，不知道是不是我的Log配置的有问题。\n\n找了很多资料，有很多文章都提到了文件夹权限的问题，于是我又回到服务器git目录下看了一下文件夹的权限：\n\n![19](http://7xn88v.com1.z0.glb.clouddn.com/c9be98241282c46c0111cb25e1be9aa4.png)\n\n原来我在创建.ssh目录是用的是root账户，所有造成ssh在进行身份认证时没有权限方位.ssh目录，导致认证失败。输入命令\n\n```shell\nchown git .ssh\n```\n\n将.ssh文件夹的所属用户改为git，.ssh里的authorized_keys文件也做相同的处理，这样改了之后终于可以验证成功了，并且不用输入密码了。\n\n## 总结\n\n整个搭建过程用了将近一天的时间，虽然过程有些曲折，但是最终还是成功了，而且这个过程中我也学到了不少的东西，更加深入的了解了ssh服务。\n\n希望这篇文章能对大家在搭建git服务器时有所帮助。\n\n## 参考资料\n\n[在CentOS下搭建自己的Git服务器](http://blog.csdn.net/wave_1102/article/details/47779401)\n[ssh无密码登录认证失败](http://blog.csdn.net/jacky0922/article/details/17999271)\n[sshd_config配置详解](http://blog.csdn.net/lansesl2008/article/details/16113193)\n[一个SSH 公钥登录失败的问题及解决经验](http://www.androiddev.net/ssh-public-key-authentication-error/)\n[Permission denied (publickey, gssapi-keyex,gssapi-with-mic,password)](http://www.linuxquestions.org/questions/linux-newbie-8/permission-denied-publickey-gssapi-keyex-gssapi-with-mic-password-4175413607/)\n[ssh使用公钥授权不通过的问题解决](http://flysnowxf.iteye.com/blog/1567570)\n[修改了SSH默认端口之后，如何配置git？](http://zengrong.net/post/1544.htm)\n","slug":"在VPS上搭建Git服务器","published":1,"updated":"2016-08-12T15:20:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis94oacg002gzrm012ojca3m","content":"<p>昨天尝试了在自己的VPS上搭建一个git服务器，中间踩了很多坑，下面是我整个搭建的过程。</p>\n<h2 id=\"具体流程\"><a href=\"#具体流程\" class=\"headerlink\" title=\"具体流程\"></a>具体流程</h2><h3 id=\"第一步：安装Git\"><a href=\"#第一步：安装Git\" class=\"headerlink\" title=\"第一步：安装Git\"></a>第一步：安装Git</h3><p>打开VPS(这里我用的是<a href=\"https://bandwagonhost.com/index.php\" target=\"_blank\" rel=\"external\">搬运工</a>，怎么购买VPS可以参考我的<a href=\"http://liujinlongxa.com/2016/06/11/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BF%BB%E5%A2%99VPS:%E6%90%AC%E8%BF%90%E5%B7%A5VPS%E8%B4%AD%E4%B9%B0%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%E5%85%A8%E8%AE%B0%E5%BD%95/\" target=\"_blank\" rel=\"external\">这篇博客</a>)的控制后台，进入Shell，然后输入命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install -y git</div></pre></td></tr></table></figure>\n<p>执行完后如图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/b9dd798ab599b9b53adebee98ebe5bbd.png\" alt=\"2\"></p>\n<p>查看Git版本，如果能显示Git版本，则说明安装成功。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/d7cdff1b7006e2c9b5f1e521319d903c.png\" alt=\"3\"></p>\n<h3 id=\"第二步：添加用户\"><a href=\"#第二步：添加用户\" class=\"headerlink\" title=\"第二步：添加用户\"></a>第二步：添加用户</h3><p>输入命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">adduser git</div><div class=\"line\">su git</div></pre></td></tr></table></figure>\n<p>添加一个名为git的用户，并且将当前用户切换到git</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/c5350088190cd59d220b4942b9d87eae.png\" alt=\"4\"></p>\n<h3 id=\"第三步：创建仓库\"><a href=\"#第三步：创建仓库\" class=\"headerlink\" title=\"第三步：创建仓库\"></a>第三步：创建仓库</h3><p>创建一个文件夹用来存放git仓库，然后输入命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git init --bare mycode.git</div></pre></td></tr></table></figure>\n<p>这样就可以创建一个裸仓库，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，如下图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/c58f27e2d859d984c844371a43a37ab8.png\" alt=\"5\"></p>\n<p>把服务器的git仓库的用户组改为git</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/26a614c08121e4b0f8783551208e2d19.png\" alt=\"6\"></p>\n<p>这样仓库就创建完了</p>\n<h3 id=\"第四步：创建证书\"><a href=\"#第四步：创建证书\" class=\"headerlink\" title=\"第四步：创建证书\"></a>第四步：创建证书</h3><p>在服务器/homg/git目录下创建文件夹.ssh，然后在.ssh文件夹里创建authorized_keys</p>\n<p><strong> 注意：一定要切换到git用户下再创建，否则使用root用户创建，会因为文件夹权限的问题而造成RSA校验失败，我就是在这里卡了半天 </strong></p>\n<p>然后在客户端创建公钥，即~/.ssh/id_rsa.pub文件里的内容，然后把公钥填入服务器的authorized_keys文件中</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/9eca6530c312dc064c8901735ef9942e.png\" alt=\"7\"></p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/7c38fa2c806440f162b83208038a8dc9.png\" alt=\"8\"></p>\n<h3 id=\"第五步：打开服务器RSA验证\"><a href=\"#第五步：打开服务器RSA验证\" class=\"headerlink\" title=\"第五步：打开服务器RSA验证\"></a>第五步：打开服务器RSA验证</h3><p>进入服务器/etc/ssh目录，使用vim打开sshd_config（建议先做一个备份），修改如下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">RSAAuthentication yes     </div><div class=\"line\">PubkeyAuthentication yes     </div><div class=\"line\">AuthorizedKeysFile  .ssh/authorized_keys</div></pre></td></tr></table></figure>\n<p>大部分Linux系统的RSA认证默认就是开启的，如果已经开启，则可以忽略(在这里也卡了好久😭)</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/9d534724207d6319fcf654142e91ba24.png\" alt=\"9\"></p>\n<p>然后保存退出，重新启动sshd</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/74d02be9217b7ea806af5970560ac956.png\" alt=\"10\"></p>\n<h3 id=\"第六步：修改指定服务器的ssh端口\"><a href=\"#第六步：修改指定服务器的ssh端口\" class=\"headerlink\" title=\"第六步：修改指定服务器的ssh端口\"></a>第六步：修改指定服务器的ssh端口</h3><p>一般ssh访问默认的端口是22，但是搬运工VPS修改了ssh访问的端口，而Git访问还是用还是22端口，因此要修改Git使用ssh访问的端口(在这里也卡了好久😭)，要查看ssh端口可以在服务器的sshd_config文件中查看，如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/b2f7743ffae9917e88f0ace60e11637b.png\" alt=\"11\"></p>\n<p> 如果不想修改服务器端口配置，可以修改客户端访问端口。在客户端的/~/.ssh/config文件中添加如下两行，第一行是服务器的地址，第二行是服务器的端口</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/17e45daf40d28f1174387104a3daef40.png\" alt=\"12\"></p>\n<p>这样就修改了访问指定服务器时的ssh端口。</p>\n<h3 id=\"第七步：创建本地仓库\"><a href=\"#第七步：创建本地仓库\" class=\"headerlink\" title=\"第七步：创建本地仓库\"></a>第七步：创建本地仓库</h3><p>经过以上六步，一个Git服务器就建立好了，现在你就可以把仓库clone下来，然后开始使用了。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/285c535aa2610ae916b1f964617a8d68.png\" alt=\"13\"></p>\n<h2 id=\"遇到的坑\"><a href=\"#遇到的坑\" class=\"headerlink\" title=\"遇到的坑\"></a>遇到的坑</h2><p>在整个搭建过程中，我也踩了很多坑，下面对这些坑做一个总结。</p>\n<h3 id=\"服务器与客户端ssh端口不一致\"><a href=\"#服务器与客户端ssh端口不一致\" class=\"headerlink\" title=\"服务器与客户端ssh端口不一致\"></a>服务器与客户端ssh端口不一致</h3><p>在完成创建证书之后，按理说，应该已经可以clone仓库了，但是我尝试克隆会报如下错误：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/e5bc21bbdb55bcdf473e6addf69cf495.png\" alt=\"14\"></p>\n<p>网上找了很多方法，最后发现是因为客户端和服务器的ssh端口不一致导致，修改了客户端的ssh访问端口才解决了这个问题。</p>\n<p>相关参考：<a href=\"http://zengrong.net/post/1544.htm\" target=\"_blank\" rel=\"external\">修改了SSH默认端口之后，如何配置git？</a></p>\n<h3 id=\"ssh验证失败\"><a href=\"#ssh验证失败\" class=\"headerlink\" title=\"ssh验证失败\"></a>ssh验证失败</h3><p>修改了ssh端口后，可以访问仓库了，但是每次访问都要输入密码，按理说我已经创建了证书，并且也把公钥放到了服务器，为什么还是不行呢？</p>\n<p>找了半天，发现服务器的RSA身份校验压根就没有开启，ssh在校验时是先使用RSA进行校验，如果校验失败再使用密码进行校验。修改sshd_config文件，打开身份校验，参照上面的第五步。</p>\n<p>打开身份校验之后，发现还是要输入密码。最初我的做法是关闭服务器的ssh密码校验，修改服务器/etc/ssh/sshd_config文件如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">PasswordAuthentication no</div></pre></td></tr></table></figure>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/fadd0406c6a9e9c02402e170082c82c7.png\" alt=\"15\"></p>\n<p>然后重启sshd。</p>\n<p>这样修改了之后，由于禁止了密码验证的方式，而RSA验证又失败，所以压根验证失败，访问都访问不了了。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/2b0a4555687ea4fe8326f690ee35533e.png\" alt=\"16\"></p>\n<p>然后我尝试看Log，输入命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh git@xxx.xxx.xxx.xxx -vvv</div></pre></td></tr></table></figure>\n<p>从Log上看，客户端已经把key传给了服务器，但是服务器在验证时失败了，所以八成可能是服务器的问题。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/8ec00cb79352b30a2f95a1b48410cdfe.png\" alt=\"20\"></p>\n<p>然后我又根据<a href=\"http://www.androiddev.net/ssh-public-key-authentication-error/\" target=\"_blank\" rel=\"external\">这篇博客</a>修改了目录的权限，但是还是不行。</p>\n<p>根据<a href=\"http://flysnowxf.iteye.com/blog/1567570\" target=\"_blank\" rel=\"external\">这篇博客</a>关闭了SELinux也还是不行。</p>\n<p>然后我又根据<a href=\"http://blog.csdn.net/lansesl2008/article/details/16113193\" target=\"_blank\" rel=\"external\">这篇博客</a>打开了ssh的log，修改sshd_config如下内容：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/3dc7b3340f6b693b047ecbee93400564.png\" alt=\"17\"></p>\n<p>然后又重新登录和退出几次ssh，在/var/log/secure里看到了如下内容：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/4f320784c4d9d731d53b3792856ec4dd.png\" alt=\"18\"></p>\n<p>并没有什么有用的信息，不知道是不是我的Log配置的有问题。</p>\n<p>找了很多资料，有很多文章都提到了文件夹权限的问题，于是我又回到服务器git目录下看了一下文件夹的权限：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/c9be98241282c46c0111cb25e1be9aa4.png\" alt=\"19\"></p>\n<p>原来我在创建.ssh目录是用的是root账户，所有造成ssh在进行身份认证时没有权限方位.ssh目录，导致认证失败。输入命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chown git .ssh</div></pre></td></tr></table></figure>\n<p>将.ssh文件夹的所属用户改为git，.ssh里的authorized_keys文件也做相同的处理，这样改了之后终于可以验证成功了，并且不用输入密码了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>整个搭建过程用了将近一天的时间，虽然过程有些曲折，但是最终还是成功了，而且这个过程中我也学到了不少的东西，更加深入的了解了ssh服务。</p>\n<p>希望这篇文章能对大家在搭建git服务器时有所帮助。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://blog.csdn.net/wave_1102/article/details/47779401\" target=\"_blank\" rel=\"external\">在CentOS下搭建自己的Git服务器</a><br><a href=\"http://blog.csdn.net/jacky0922/article/details/17999271\" target=\"_blank\" rel=\"external\">ssh无密码登录认证失败</a><br><a href=\"http://blog.csdn.net/lansesl2008/article/details/16113193\" target=\"_blank\" rel=\"external\">sshd_config配置详解</a><br><a href=\"http://www.androiddev.net/ssh-public-key-authentication-error/\" target=\"_blank\" rel=\"external\">一个SSH 公钥登录失败的问题及解决经验</a><br><a href=\"http://www.linuxquestions.org/questions/linux-newbie-8/permission-denied-publickey-gssapi-keyex-gssapi-with-mic-password-4175413607/\" target=\"_blank\" rel=\"external\">Permission denied (publickey, gssapi-keyex,gssapi-with-mic,password)</a><br><a href=\"http://flysnowxf.iteye.com/blog/1567570\" target=\"_blank\" rel=\"external\">ssh使用公钥授权不通过的问题解决</a><br><a href=\"http://zengrong.net/post/1544.htm\" target=\"_blank\" rel=\"external\">修改了SSH默认端口之后，如何配置git？</a></p>\n","excerpt":"","more":"<p>昨天尝试了在自己的VPS上搭建一个git服务器，中间踩了很多坑，下面是我整个搭建的过程。</p>\n<h2 id=\"具体流程\"><a href=\"#具体流程\" class=\"headerlink\" title=\"具体流程\"></a>具体流程</h2><h3 id=\"第一步：安装Git\"><a href=\"#第一步：安装Git\" class=\"headerlink\" title=\"第一步：安装Git\"></a>第一步：安装Git</h3><p>打开VPS(这里我用的是<a href=\"https://bandwagonhost.com/index.php\">搬运工</a>，怎么购买VPS可以参考我的<a href=\"http://liujinlongxa.com/2016/06/11/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BF%BB%E5%A2%99VPS:%E6%90%AC%E8%BF%90%E5%B7%A5VPS%E8%B4%AD%E4%B9%B0%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%E5%85%A8%E8%AE%B0%E5%BD%95/\">这篇博客</a>)的控制后台，进入Shell，然后输入命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install -y git</div></pre></td></tr></table></figure>\n<p>执行完后如图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/b9dd798ab599b9b53adebee98ebe5bbd.png\" alt=\"2\"></p>\n<p>查看Git版本，如果能显示Git版本，则说明安装成功。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/d7cdff1b7006e2c9b5f1e521319d903c.png\" alt=\"3\"></p>\n<h3 id=\"第二步：添加用户\"><a href=\"#第二步：添加用户\" class=\"headerlink\" title=\"第二步：添加用户\"></a>第二步：添加用户</h3><p>输入命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">adduser git</div><div class=\"line\">su git</div></pre></td></tr></table></figure>\n<p>添加一个名为git的用户，并且将当前用户切换到git</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/c5350088190cd59d220b4942b9d87eae.png\" alt=\"4\"></p>\n<h3 id=\"第三步：创建仓库\"><a href=\"#第三步：创建仓库\" class=\"headerlink\" title=\"第三步：创建仓库\"></a>第三步：创建仓库</h3><p>创建一个文件夹用来存放git仓库，然后输入命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git init --bare mycode.git</div></pre></td></tr></table></figure>\n<p>这样就可以创建一个裸仓库，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，如下图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/c58f27e2d859d984c844371a43a37ab8.png\" alt=\"5\"></p>\n<p>把服务器的git仓库的用户组改为git</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/26a614c08121e4b0f8783551208e2d19.png\" alt=\"6\"></p>\n<p>这样仓库就创建完了</p>\n<h3 id=\"第四步：创建证书\"><a href=\"#第四步：创建证书\" class=\"headerlink\" title=\"第四步：创建证书\"></a>第四步：创建证书</h3><p>在服务器/homg/git目录下创建文件夹.ssh，然后在.ssh文件夹里创建authorized_keys</p>\n<p><strong> 注意：一定要切换到git用户下再创建，否则使用root用户创建，会因为文件夹权限的问题而造成RSA校验失败，我就是在这里卡了半天 </strong></p>\n<p>然后在客户端创建公钥，即~/.ssh/id_rsa.pub文件里的内容，然后把公钥填入服务器的authorized_keys文件中</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/9eca6530c312dc064c8901735ef9942e.png\" alt=\"7\"></p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/7c38fa2c806440f162b83208038a8dc9.png\" alt=\"8\"></p>\n<h3 id=\"第五步：打开服务器RSA验证\"><a href=\"#第五步：打开服务器RSA验证\" class=\"headerlink\" title=\"第五步：打开服务器RSA验证\"></a>第五步：打开服务器RSA验证</h3><p>进入服务器/etc/ssh目录，使用vim打开sshd_config（建议先做一个备份），修改如下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">RSAAuthentication yes     </div><div class=\"line\">PubkeyAuthentication yes     </div><div class=\"line\">AuthorizedKeysFile  .ssh/authorized_keys</div></pre></td></tr></table></figure>\n<p>大部分Linux系统的RSA认证默认就是开启的，如果已经开启，则可以忽略(在这里也卡了好久😭)</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/9d534724207d6319fcf654142e91ba24.png\" alt=\"9\"></p>\n<p>然后保存退出，重新启动sshd</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/74d02be9217b7ea806af5970560ac956.png\" alt=\"10\"></p>\n<h3 id=\"第六步：修改指定服务器的ssh端口\"><a href=\"#第六步：修改指定服务器的ssh端口\" class=\"headerlink\" title=\"第六步：修改指定服务器的ssh端口\"></a>第六步：修改指定服务器的ssh端口</h3><p>一般ssh访问默认的端口是22，但是搬运工VPS修改了ssh访问的端口，而Git访问还是用还是22端口，因此要修改Git使用ssh访问的端口(在这里也卡了好久😭)，要查看ssh端口可以在服务器的sshd_config文件中查看，如下：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/b2f7743ffae9917e88f0ace60e11637b.png\" alt=\"11\"></p>\n<p> 如果不想修改服务器端口配置，可以修改客户端访问端口。在客户端的/~/.ssh/config文件中添加如下两行，第一行是服务器的地址，第二行是服务器的端口</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/17e45daf40d28f1174387104a3daef40.png\" alt=\"12\"></p>\n<p>这样就修改了访问指定服务器时的ssh端口。</p>\n<h3 id=\"第七步：创建本地仓库\"><a href=\"#第七步：创建本地仓库\" class=\"headerlink\" title=\"第七步：创建本地仓库\"></a>第七步：创建本地仓库</h3><p>经过以上六步，一个Git服务器就建立好了，现在你就可以把仓库clone下来，然后开始使用了。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/285c535aa2610ae916b1f964617a8d68.png\" alt=\"13\"></p>\n<h2 id=\"遇到的坑\"><a href=\"#遇到的坑\" class=\"headerlink\" title=\"遇到的坑\"></a>遇到的坑</h2><p>在整个搭建过程中，我也踩了很多坑，下面对这些坑做一个总结。</p>\n<h3 id=\"服务器与客户端ssh端口不一致\"><a href=\"#服务器与客户端ssh端口不一致\" class=\"headerlink\" title=\"服务器与客户端ssh端口不一致\"></a>服务器与客户端ssh端口不一致</h3><p>在完成创建证书之后，按理说，应该已经可以clone仓库了，但是我尝试克隆会报如下错误：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/e5bc21bbdb55bcdf473e6addf69cf495.png\" alt=\"14\"></p>\n<p>网上找了很多方法，最后发现是因为客户端和服务器的ssh端口不一致导致，修改了客户端的ssh访问端口才解决了这个问题。</p>\n<p>相关参考：<a href=\"http://zengrong.net/post/1544.htm\">修改了SSH默认端口之后，如何配置git？</a></p>\n<h3 id=\"ssh验证失败\"><a href=\"#ssh验证失败\" class=\"headerlink\" title=\"ssh验证失败\"></a>ssh验证失败</h3><p>修改了ssh端口后，可以访问仓库了，但是每次访问都要输入密码，按理说我已经创建了证书，并且也把公钥放到了服务器，为什么还是不行呢？</p>\n<p>找了半天，发现服务器的RSA身份校验压根就没有开启，ssh在校验时是先使用RSA进行校验，如果校验失败再使用密码进行校验。修改sshd_config文件，打开身份校验，参照上面的第五步。</p>\n<p>打开身份校验之后，发现还是要输入密码。最初我的做法是关闭服务器的ssh密码校验，修改服务器/etc/ssh/sshd_config文件如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">PasswordAuthentication no</div></pre></td></tr></table></figure>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/fadd0406c6a9e9c02402e170082c82c7.png\" alt=\"15\"></p>\n<p>然后重启sshd。</p>\n<p>这样修改了之后，由于禁止了密码验证的方式，而RSA验证又失败，所以压根验证失败，访问都访问不了了。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/2b0a4555687ea4fe8326f690ee35533e.png\" alt=\"16\"></p>\n<p>然后我尝试看Log，输入命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh git@xxx.xxx.xxx.xxx -vvv</div></pre></td></tr></table></figure>\n<p>从Log上看，客户端已经把key传给了服务器，但是服务器在验证时失败了，所以八成可能是服务器的问题。</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/8ec00cb79352b30a2f95a1b48410cdfe.png\" alt=\"20\"></p>\n<p>然后我又根据<a href=\"http://www.androiddev.net/ssh-public-key-authentication-error/\">这篇博客</a>修改了目录的权限，但是还是不行。</p>\n<p>根据<a href=\"http://flysnowxf.iteye.com/blog/1567570\">这篇博客</a>关闭了SELinux也还是不行。</p>\n<p>然后我又根据<a href=\"http://blog.csdn.net/lansesl2008/article/details/16113193\">这篇博客</a>打开了ssh的log，修改sshd_config如下内容：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/3dc7b3340f6b693b047ecbee93400564.png\" alt=\"17\"></p>\n<p>然后又重新登录和退出几次ssh，在/var/log/secure里看到了如下内容：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/4f320784c4d9d731d53b3792856ec4dd.png\" alt=\"18\"></p>\n<p>并没有什么有用的信息，不知道是不是我的Log配置的有问题。</p>\n<p>找了很多资料，有很多文章都提到了文件夹权限的问题，于是我又回到服务器git目录下看了一下文件夹的权限：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/c9be98241282c46c0111cb25e1be9aa4.png\" alt=\"19\"></p>\n<p>原来我在创建.ssh目录是用的是root账户，所有造成ssh在进行身份认证时没有权限方位.ssh目录，导致认证失败。输入命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chown git .ssh</div></pre></td></tr></table></figure>\n<p>将.ssh文件夹的所属用户改为git，.ssh里的authorized_keys文件也做相同的处理，这样改了之后终于可以验证成功了，并且不用输入密码了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>整个搭建过程用了将近一天的时间，虽然过程有些曲折，但是最终还是成功了，而且这个过程中我也学到了不少的东西，更加深入的了解了ssh服务。</p>\n<p>希望这篇文章能对大家在搭建git服务器时有所帮助。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://blog.csdn.net/wave_1102/article/details/47779401\">在CentOS下搭建自己的Git服务器</a><br><a href=\"http://blog.csdn.net/jacky0922/article/details/17999271\">ssh无密码登录认证失败</a><br><a href=\"http://blog.csdn.net/lansesl2008/article/details/16113193\">sshd_config配置详解</a><br><a href=\"http://www.androiddev.net/ssh-public-key-authentication-error/\">一个SSH 公钥登录失败的问题及解决经验</a><br><a href=\"http://www.linuxquestions.org/questions/linux-newbie-8/permission-denied-publickey-gssapi-keyex-gssapi-with-mic-password-4175413607/\">Permission denied (publickey, gssapi-keyex,gssapi-with-mic,password)</a><br><a href=\"http://flysnowxf.iteye.com/blog/1567570\">ssh使用公钥授权不通过的问题解决</a><br><a href=\"http://zengrong.net/post/1544.htm\">修改了SSH默认端口之后，如何配置git？</a></p>\n"},{"title":"使用ownCloud作为OmniFocus的云同步服务器","date":"2016-08-24T14:47:22.000Z","_content":"\n平时一直使用OmniFocus作为自己的时间管理工具，但是由于我使用的是破解版的（正版太贵，买不起啊），同步就变成了一件很麻烦的事。OmniFocus提供了两种同步方式，如下图：\n\n![1](http://7xn88v.com1.z0.glb.clouddn.com/901f5c4cb502f3fc557e3c3cfa79ad2f.png)\n\n一种是使用Omni官方的服务器同步，这种方式需要注册Omni官方账号，应该只有正版能用吧，我没有尝试；另一种方式是使用WebDAV进行同步，这里着重介绍第二种方式。\n\n本文主要分为以下几个部分：\n\n1. WebDAV简介\n2. ownCloud简介以及搭建方法\n3. 使用ownCloud作为OmniFocus的同步服务器\n4. ownCloud的一些其他应用\n\n## WebDAV简介\n\n[WebDAV](http://baike.baidu.com/link?url=pXeqnwgtPiYSKdYGX9YjBH_XeAJsH-aRkQqEYPsbkQwf9hlbnF9RSuAHvCMLboSuENx55T8J9Pd27E6ybo7Aba)是一种基于 HTTP 1.1协议的通讯协议，可以实现文件的同步。通俗来讲，我们可以利用WebDAV来实现类似百度云一样的网盘功能。\n\n[这里](http://blog.sina.com.cn/s/blog_4834fe810101fw17.html)有几个支持WebDAV协议的网盘，但是都是国外的，国内据我了解目前只有[坚果云](http://www.jianguoyun.com/s/campaign/cpclanding/main?sch=bdcpc_nutstore_off&bdtj=1)一家支持WebDAV。至于国内的各大网盘为什么都不支持WebDAV，可以看[这里](http://www.zhihu.com/question/21511143)。\n\n最初我也本来打算使用国外的网盘来实现WebDAV，但是担心速度不理想，而且国外网盘的免费空间都很小，所以就放弃了。至于坚果云，我也没有去尝试。\n\n进一步Google，于是就找到了ownCloud。\n\n## ownCloud简介以及搭建方法\n\n[ownCloud](https://owncloud.org/)是一个来自KDE社区开发的免费软件，提供私人的Web服务。当前主要功能包括文件管理（内建文件分享）、音乐、日历、联系人等等，可在PC和服务器上运行。简单来说就是一个基于Php的自建网盘。\n\n下面就跟着我使用ownCloud一步一步搭建自己的私人网盘。\n\n### 准备工作\n\n因为要把ownCloud搭建在服务器上，因此你需要有一个VPS，内存至少128M，越大越好，我这里使用的是[搬运工VPS](https://bandwagonhost.com/clientarea.php?action=products)，如何购买VPS可以看我的[这篇博客](http://liujinlongxa.com/2016/06/11/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BF%BB%E5%A2%99VPS:%E6%90%AC%E8%BF%90%E5%B7%A5VPS%E8%B4%AD%E4%B9%B0%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%E5%85%A8%E8%AE%B0%E5%BD%95/)。\n\n### 1. 安装PHP和MySQL环境\n\n由于ownCloud使用php实现的，所以需要在你服务器上安装PHP和MySQL环境，这个网上有很多教程，也可以参考ownCloud给出的[官方教程](https://doc.owncloud.org/server/9.1/admin_manual/installation/php_54_installation.html)。\n\n### 2. 下载服务器源码\n\n在任一文件夹下输入命令：\n\n```shell\nwget https://download.owncloud.org/community/owncloud-9.1.0.tar.bz2\ntar xvf owncloud-9.1.0.tar.bz2\n```\n\n然后改变owncloud这个文件的权限，命令如下：\n\n```shell\nchmod 777 owncloud\n```\n\n### 3. 添加管理员账号\n\n使用浏览器访问地址http://serveraddress/owncloud/ (serveraddress即你服务器的ip地址)就可以看到如下页面：\n\n![2](http://7xn88v.com1.z0.glb.clouddn.com/5de5eb45600b86bae8e2c0cfdaadb319.png)\n\n在这里自定义一个管理员的账号和密码，然后点击FinishSetup，这样一个ownCloud就搭建完成了。\n\n## 使用ownCloud作为OmniFocus的同步服务器\n\nownCloud搭建完成后，就可以把它作为Omni的同步服务器了，具体方法如下：\n\n打开OmniFocus的同步设置页面，选择WebDAV方式同步，然后在Address中填入如下地址：\n\n> http://<serveraddress>/owncloud/remote.php/dav/files/<adminname>\n\n<serveraddress>和<adminname>分别替换为你的服务器地址和刚才填的管理员用户名，如下图：\n\n![3](http://7xn88v.com1.z0.glb.clouddn.com/264b1ec833e6078643e9c2f40b2bf7aa.png)\n\n然后点击“Sync Now”进行同步，会提示输入密码，输入刚才添加的管理员密码，然后就可以同步成功了。\n\n使用浏览器访问http://serveraddress/owncloud/ ，就可以看到刚刚同步上去的文件了，如下图：\n\n![4](http://7xn88v.com1.z0.glb.clouddn.com/0da7c4ef259b48e8f608540c27091cbd.png)\n\n## ownCloud的一些其他应用\n\nownCloud还提供了多平台的客户端，包括iOS，Android，Mac，Windows等，你可以下载一个Mac客户端，然后设置一个同步文件夹，凡是放在这个文件夹里的文件，都会被自动同步到服务器上。如下图：\n\n![5](http://7xn88v.com1.z0.glb.clouddn.com/d7b6c828536bab1e8fa5a69a12332ebf.png)\n\n我把Quiver的笔记数据也同步到了服务器上。\n\n## 结语\n\n其实ownCloud的功能还远不止这些，还有很多功能还待以后慢慢探索。\n\n类似ownCloud的还有一个叫[seafile](https://www.seafile.com/home/)的服务，两者的区别和优劣可以参考[这里](http://www.zhihu.com/question/23929945)。\n\n## 参考资料\n\n[ownCloud官方文档](https://doc.owncloud.org/server/9.1/admin_manual/contents.html)\n[ownCloud关于WebDAV使用的文档](https://doc.owncloud.org/server/9.1/user_manual/files/access_webdav.html)\n[使用OwnCloud创建私有云](http://jjliu.blog.ustc.edu.cn/198/)\n","source":"_posts/2016-08-24-使用ownCloud作为OmniFocus的云同步服务器.md","raw":"---\ntitle: 使用ownCloud作为OmniFocus的云同步服务器\ncategories: 其他\ntags:\n  - 其他\n  - WebDAV\n  - ownCloud\ndate: 2016-08-24 22:47:22\n---\n\n平时一直使用OmniFocus作为自己的时间管理工具，但是由于我使用的是破解版的（正版太贵，买不起啊），同步就变成了一件很麻烦的事。OmniFocus提供了两种同步方式，如下图：\n\n![1](http://7xn88v.com1.z0.glb.clouddn.com/901f5c4cb502f3fc557e3c3cfa79ad2f.png)\n\n一种是使用Omni官方的服务器同步，这种方式需要注册Omni官方账号，应该只有正版能用吧，我没有尝试；另一种方式是使用WebDAV进行同步，这里着重介绍第二种方式。\n\n本文主要分为以下几个部分：\n\n1. WebDAV简介\n2. ownCloud简介以及搭建方法\n3. 使用ownCloud作为OmniFocus的同步服务器\n4. ownCloud的一些其他应用\n\n## WebDAV简介\n\n[WebDAV](http://baike.baidu.com/link?url=pXeqnwgtPiYSKdYGX9YjBH_XeAJsH-aRkQqEYPsbkQwf9hlbnF9RSuAHvCMLboSuENx55T8J9Pd27E6ybo7Aba)是一种基于 HTTP 1.1协议的通讯协议，可以实现文件的同步。通俗来讲，我们可以利用WebDAV来实现类似百度云一样的网盘功能。\n\n[这里](http://blog.sina.com.cn/s/blog_4834fe810101fw17.html)有几个支持WebDAV协议的网盘，但是都是国外的，国内据我了解目前只有[坚果云](http://www.jianguoyun.com/s/campaign/cpclanding/main?sch=bdcpc_nutstore_off&bdtj=1)一家支持WebDAV。至于国内的各大网盘为什么都不支持WebDAV，可以看[这里](http://www.zhihu.com/question/21511143)。\n\n最初我也本来打算使用国外的网盘来实现WebDAV，但是担心速度不理想，而且国外网盘的免费空间都很小，所以就放弃了。至于坚果云，我也没有去尝试。\n\n进一步Google，于是就找到了ownCloud。\n\n## ownCloud简介以及搭建方法\n\n[ownCloud](https://owncloud.org/)是一个来自KDE社区开发的免费软件，提供私人的Web服务。当前主要功能包括文件管理（内建文件分享）、音乐、日历、联系人等等，可在PC和服务器上运行。简单来说就是一个基于Php的自建网盘。\n\n下面就跟着我使用ownCloud一步一步搭建自己的私人网盘。\n\n### 准备工作\n\n因为要把ownCloud搭建在服务器上，因此你需要有一个VPS，内存至少128M，越大越好，我这里使用的是[搬运工VPS](https://bandwagonhost.com/clientarea.php?action=products)，如何购买VPS可以看我的[这篇博客](http://liujinlongxa.com/2016/06/11/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BF%BB%E5%A2%99VPS:%E6%90%AC%E8%BF%90%E5%B7%A5VPS%E8%B4%AD%E4%B9%B0%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%E5%85%A8%E8%AE%B0%E5%BD%95/)。\n\n### 1. 安装PHP和MySQL环境\n\n由于ownCloud使用php实现的，所以需要在你服务器上安装PHP和MySQL环境，这个网上有很多教程，也可以参考ownCloud给出的[官方教程](https://doc.owncloud.org/server/9.1/admin_manual/installation/php_54_installation.html)。\n\n### 2. 下载服务器源码\n\n在任一文件夹下输入命令：\n\n```shell\nwget https://download.owncloud.org/community/owncloud-9.1.0.tar.bz2\ntar xvf owncloud-9.1.0.tar.bz2\n```\n\n然后改变owncloud这个文件的权限，命令如下：\n\n```shell\nchmod 777 owncloud\n```\n\n### 3. 添加管理员账号\n\n使用浏览器访问地址http://serveraddress/owncloud/ (serveraddress即你服务器的ip地址)就可以看到如下页面：\n\n![2](http://7xn88v.com1.z0.glb.clouddn.com/5de5eb45600b86bae8e2c0cfdaadb319.png)\n\n在这里自定义一个管理员的账号和密码，然后点击FinishSetup，这样一个ownCloud就搭建完成了。\n\n## 使用ownCloud作为OmniFocus的同步服务器\n\nownCloud搭建完成后，就可以把它作为Omni的同步服务器了，具体方法如下：\n\n打开OmniFocus的同步设置页面，选择WebDAV方式同步，然后在Address中填入如下地址：\n\n> http://<serveraddress>/owncloud/remote.php/dav/files/<adminname>\n\n<serveraddress>和<adminname>分别替换为你的服务器地址和刚才填的管理员用户名，如下图：\n\n![3](http://7xn88v.com1.z0.glb.clouddn.com/264b1ec833e6078643e9c2f40b2bf7aa.png)\n\n然后点击“Sync Now”进行同步，会提示输入密码，输入刚才添加的管理员密码，然后就可以同步成功了。\n\n使用浏览器访问http://serveraddress/owncloud/ ，就可以看到刚刚同步上去的文件了，如下图：\n\n![4](http://7xn88v.com1.z0.glb.clouddn.com/0da7c4ef259b48e8f608540c27091cbd.png)\n\n## ownCloud的一些其他应用\n\nownCloud还提供了多平台的客户端，包括iOS，Android，Mac，Windows等，你可以下载一个Mac客户端，然后设置一个同步文件夹，凡是放在这个文件夹里的文件，都会被自动同步到服务器上。如下图：\n\n![5](http://7xn88v.com1.z0.glb.clouddn.com/d7b6c828536bab1e8fa5a69a12332ebf.png)\n\n我把Quiver的笔记数据也同步到了服务器上。\n\n## 结语\n\n其实ownCloud的功能还远不止这些，还有很多功能还待以后慢慢探索。\n\n类似ownCloud的还有一个叫[seafile](https://www.seafile.com/home/)的服务，两者的区别和优劣可以参考[这里](http://www.zhihu.com/question/23929945)。\n\n## 参考资料\n\n[ownCloud官方文档](https://doc.owncloud.org/server/9.1/admin_manual/contents.html)\n[ownCloud关于WebDAV使用的文档](https://doc.owncloud.org/server/9.1/user_manual/files/access_webdav.html)\n[使用OwnCloud创建私有云](http://jjliu.blog.ustc.edu.cn/198/)\n","slug":"使用ownCloud作为OmniFocus的云同步服务器","published":1,"updated":"2016-08-24T16:34:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis94oaci002kzrm0f975chf9","content":"<p>平时一直使用OmniFocus作为自己的时间管理工具，但是由于我使用的是破解版的（正版太贵，买不起啊），同步就变成了一件很麻烦的事。OmniFocus提供了两种同步方式，如下图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/901f5c4cb502f3fc557e3c3cfa79ad2f.png\" alt=\"1\"></p>\n<p>一种是使用Omni官方的服务器同步，这种方式需要注册Omni官方账号，应该只有正版能用吧，我没有尝试；另一种方式是使用WebDAV进行同步，这里着重介绍第二种方式。</p>\n<p>本文主要分为以下几个部分：</p>\n<ol>\n<li>WebDAV简介</li>\n<li>ownCloud简介以及搭建方法</li>\n<li>使用ownCloud作为OmniFocus的同步服务器</li>\n<li>ownCloud的一些其他应用</li>\n</ol>\n<h2 id=\"WebDAV简介\"><a href=\"#WebDAV简介\" class=\"headerlink\" title=\"WebDAV简介\"></a>WebDAV简介</h2><p><a href=\"http://baike.baidu.com/link?url=pXeqnwgtPiYSKdYGX9YjBH_XeAJsH-aRkQqEYPsbkQwf9hlbnF9RSuAHvCMLboSuENx55T8J9Pd27E6ybo7Aba\" target=\"_blank\" rel=\"external\">WebDAV</a>是一种基于 HTTP 1.1协议的通讯协议，可以实现文件的同步。通俗来讲，我们可以利用WebDAV来实现类似百度云一样的网盘功能。</p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_4834fe810101fw17.html\" target=\"_blank\" rel=\"external\">这里</a>有几个支持WebDAV协议的网盘，但是都是国外的，国内据我了解目前只有<a href=\"http://www.jianguoyun.com/s/campaign/cpclanding/main?sch=bdcpc_nutstore_off&amp;bdtj=1\" target=\"_blank\" rel=\"external\">坚果云</a>一家支持WebDAV。至于国内的各大网盘为什么都不支持WebDAV，可以看<a href=\"http://www.zhihu.com/question/21511143\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<p>最初我也本来打算使用国外的网盘来实现WebDAV，但是担心速度不理想，而且国外网盘的免费空间都很小，所以就放弃了。至于坚果云，我也没有去尝试。</p>\n<p>进一步Google，于是就找到了ownCloud。</p>\n<h2 id=\"ownCloud简介以及搭建方法\"><a href=\"#ownCloud简介以及搭建方法\" class=\"headerlink\" title=\"ownCloud简介以及搭建方法\"></a>ownCloud简介以及搭建方法</h2><p><a href=\"https://owncloud.org/\" target=\"_blank\" rel=\"external\">ownCloud</a>是一个来自KDE社区开发的免费软件，提供私人的Web服务。当前主要功能包括文件管理（内建文件分享）、音乐、日历、联系人等等，可在PC和服务器上运行。简单来说就是一个基于Php的自建网盘。</p>\n<p>下面就跟着我使用ownCloud一步一步搭建自己的私人网盘。</p>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>因为要把ownCloud搭建在服务器上，因此你需要有一个VPS，内存至少128M，越大越好，我这里使用的是<a href=\"https://bandwagonhost.com/clientarea.php?action=products\" target=\"_blank\" rel=\"external\">搬运工VPS</a>，如何购买VPS可以看我的<a href=\"http://liujinlongxa.com/2016/06/11/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BF%BB%E5%A2%99VPS:%E6%90%AC%E8%BF%90%E5%B7%A5VPS%E8%B4%AD%E4%B9%B0%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%E5%85%A8%E8%AE%B0%E5%BD%95/\" target=\"_blank\" rel=\"external\">这篇博客</a>。</p>\n<h3 id=\"1-安装PHP和MySQL环境\"><a href=\"#1-安装PHP和MySQL环境\" class=\"headerlink\" title=\"1. 安装PHP和MySQL环境\"></a>1. 安装PHP和MySQL环境</h3><p>由于ownCloud使用php实现的，所以需要在你服务器上安装PHP和MySQL环境，这个网上有很多教程，也可以参考ownCloud给出的<a href=\"https://doc.owncloud.org/server/9.1/admin_manual/installation/php_54_installation.html\" target=\"_blank\" rel=\"external\">官方教程</a>。</p>\n<h3 id=\"2-下载服务器源码\"><a href=\"#2-下载服务器源码\" class=\"headerlink\" title=\"2. 下载服务器源码\"></a>2. 下载服务器源码</h3><p>在任一文件夹下输入命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget https://download.owncloud.org/community/owncloud-9.1.0.tar.bz2</div><div class=\"line\">tar xvf owncloud-9.1.0.tar.bz2</div></pre></td></tr></table></figure>\n<p>然后改变owncloud这个文件的权限，命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod 777 owncloud</div></pre></td></tr></table></figure>\n<h3 id=\"3-添加管理员账号\"><a href=\"#3-添加管理员账号\" class=\"headerlink\" title=\"3. 添加管理员账号\"></a>3. 添加管理员账号</h3><p>使用浏览器访问地址<a href=\"http://serveraddress/owncloud/\" target=\"_blank\" rel=\"external\">http://serveraddress/owncloud/</a> (serveraddress即你服务器的ip地址)就可以看到如下页面：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/5de5eb45600b86bae8e2c0cfdaadb319.png\" alt=\"2\"></p>\n<p>在这里自定义一个管理员的账号和密码，然后点击FinishSetup，这样一个ownCloud就搭建完成了。</p>\n<h2 id=\"使用ownCloud作为OmniFocus的同步服务器\"><a href=\"#使用ownCloud作为OmniFocus的同步服务器\" class=\"headerlink\" title=\"使用ownCloud作为OmniFocus的同步服务器\"></a>使用ownCloud作为OmniFocus的同步服务器</h2><p>ownCloud搭建完成后，就可以把它作为Omni的同步服务器了，具体方法如下：</p>\n<p>打开OmniFocus的同步设置页面，选择WebDAV方式同步，然后在Address中填入如下地址：</p>\n<blockquote>\n<p>http://<serveraddress>/owncloud/remote.php/dav/files/<adminname></adminname></serveraddress></p>\n</blockquote>\n<p><serveraddress>和<adminname>分别替换为你的服务器地址和刚才填的管理员用户名，如下图：</adminname></serveraddress></p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/264b1ec833e6078643e9c2f40b2bf7aa.png\" alt=\"3\"></p>\n<p>然后点击“Sync Now”进行同步，会提示输入密码，输入刚才添加的管理员密码，然后就可以同步成功了。</p>\n<p>使用浏览器访问<a href=\"http://serveraddress/owncloud/\" target=\"_blank\" rel=\"external\">http://serveraddress/owncloud/</a> ，就可以看到刚刚同步上去的文件了，如下图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/0da7c4ef259b48e8f608540c27091cbd.png\" alt=\"4\"></p>\n<h2 id=\"ownCloud的一些其他应用\"><a href=\"#ownCloud的一些其他应用\" class=\"headerlink\" title=\"ownCloud的一些其他应用\"></a>ownCloud的一些其他应用</h2><p>ownCloud还提供了多平台的客户端，包括iOS，Android，Mac，Windows等，你可以下载一个Mac客户端，然后设置一个同步文件夹，凡是放在这个文件夹里的文件，都会被自动同步到服务器上。如下图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/d7b6c828536bab1e8fa5a69a12332ebf.png\" alt=\"5\"></p>\n<p>我把Quiver的笔记数据也同步到了服务器上。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>其实ownCloud的功能还远不止这些，还有很多功能还待以后慢慢探索。</p>\n<p>类似ownCloud的还有一个叫<a href=\"https://www.seafile.com/home/\" target=\"_blank\" rel=\"external\">seafile</a>的服务，两者的区别和优劣可以参考<a href=\"http://www.zhihu.com/question/23929945\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://doc.owncloud.org/server/9.1/admin_manual/contents.html\" target=\"_blank\" rel=\"external\">ownCloud官方文档</a><br><a href=\"https://doc.owncloud.org/server/9.1/user_manual/files/access_webdav.html\" target=\"_blank\" rel=\"external\">ownCloud关于WebDAV使用的文档</a><br><a href=\"http://jjliu.blog.ustc.edu.cn/198/\" target=\"_blank\" rel=\"external\">使用OwnCloud创建私有云</a></p>\n","excerpt":"","more":"<p>平时一直使用OmniFocus作为自己的时间管理工具，但是由于我使用的是破解版的（正版太贵，买不起啊），同步就变成了一件很麻烦的事。OmniFocus提供了两种同步方式，如下图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/901f5c4cb502f3fc557e3c3cfa79ad2f.png\" alt=\"1\"></p>\n<p>一种是使用Omni官方的服务器同步，这种方式需要注册Omni官方账号，应该只有正版能用吧，我没有尝试；另一种方式是使用WebDAV进行同步，这里着重介绍第二种方式。</p>\n<p>本文主要分为以下几个部分：</p>\n<ol>\n<li>WebDAV简介</li>\n<li>ownCloud简介以及搭建方法</li>\n<li>使用ownCloud作为OmniFocus的同步服务器</li>\n<li>ownCloud的一些其他应用</li>\n</ol>\n<h2 id=\"WebDAV简介\"><a href=\"#WebDAV简介\" class=\"headerlink\" title=\"WebDAV简介\"></a>WebDAV简介</h2><p><a href=\"http://baike.baidu.com/link?url=pXeqnwgtPiYSKdYGX9YjBH_XeAJsH-aRkQqEYPsbkQwf9hlbnF9RSuAHvCMLboSuENx55T8J9Pd27E6ybo7Aba\">WebDAV</a>是一种基于 HTTP 1.1协议的通讯协议，可以实现文件的同步。通俗来讲，我们可以利用WebDAV来实现类似百度云一样的网盘功能。</p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_4834fe810101fw17.html\">这里</a>有几个支持WebDAV协议的网盘，但是都是国外的，国内据我了解目前只有<a href=\"http://www.jianguoyun.com/s/campaign/cpclanding/main?sch=bdcpc_nutstore_off&amp;bdtj=1\">坚果云</a>一家支持WebDAV。至于国内的各大网盘为什么都不支持WebDAV，可以看<a href=\"http://www.zhihu.com/question/21511143\">这里</a>。</p>\n<p>最初我也本来打算使用国外的网盘来实现WebDAV，但是担心速度不理想，而且国外网盘的免费空间都很小，所以就放弃了。至于坚果云，我也没有去尝试。</p>\n<p>进一步Google，于是就找到了ownCloud。</p>\n<h2 id=\"ownCloud简介以及搭建方法\"><a href=\"#ownCloud简介以及搭建方法\" class=\"headerlink\" title=\"ownCloud简介以及搭建方法\"></a>ownCloud简介以及搭建方法</h2><p><a href=\"https://owncloud.org/\">ownCloud</a>是一个来自KDE社区开发的免费软件，提供私人的Web服务。当前主要功能包括文件管理（内建文件分享）、音乐、日历、联系人等等，可在PC和服务器上运行。简单来说就是一个基于Php的自建网盘。</p>\n<p>下面就跟着我使用ownCloud一步一步搭建自己的私人网盘。</p>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>因为要把ownCloud搭建在服务器上，因此你需要有一个VPS，内存至少128M，越大越好，我这里使用的是<a href=\"https://bandwagonhost.com/clientarea.php?action=products\">搬运工VPS</a>，如何购买VPS可以看我的<a href=\"http://liujinlongxa.com/2016/06/11/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BF%BB%E5%A2%99VPS:%E6%90%AC%E8%BF%90%E5%B7%A5VPS%E8%B4%AD%E4%B9%B0%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%E5%85%A8%E8%AE%B0%E5%BD%95/\">这篇博客</a>。</p>\n<h3 id=\"1-安装PHP和MySQL环境\"><a href=\"#1-安装PHP和MySQL环境\" class=\"headerlink\" title=\"1. 安装PHP和MySQL环境\"></a>1. 安装PHP和MySQL环境</h3><p>由于ownCloud使用php实现的，所以需要在你服务器上安装PHP和MySQL环境，这个网上有很多教程，也可以参考ownCloud给出的<a href=\"https://doc.owncloud.org/server/9.1/admin_manual/installation/php_54_installation.html\">官方教程</a>。</p>\n<h3 id=\"2-下载服务器源码\"><a href=\"#2-下载服务器源码\" class=\"headerlink\" title=\"2. 下载服务器源码\"></a>2. 下载服务器源码</h3><p>在任一文件夹下输入命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget https://download.owncloud.org/community/owncloud-9.1.0.tar.bz2</div><div class=\"line\">tar xvf owncloud-9.1.0.tar.bz2</div></pre></td></tr></table></figure>\n<p>然后改变owncloud这个文件的权限，命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod 777 owncloud</div></pre></td></tr></table></figure>\n<h3 id=\"3-添加管理员账号\"><a href=\"#3-添加管理员账号\" class=\"headerlink\" title=\"3. 添加管理员账号\"></a>3. 添加管理员账号</h3><p>使用浏览器访问地址<a href=\"http://serveraddress/owncloud/\">http://serveraddress/owncloud/</a> (serveraddress即你服务器的ip地址)就可以看到如下页面：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/5de5eb45600b86bae8e2c0cfdaadb319.png\" alt=\"2\"></p>\n<p>在这里自定义一个管理员的账号和密码，然后点击FinishSetup，这样一个ownCloud就搭建完成了。</p>\n<h2 id=\"使用ownCloud作为OmniFocus的同步服务器\"><a href=\"#使用ownCloud作为OmniFocus的同步服务器\" class=\"headerlink\" title=\"使用ownCloud作为OmniFocus的同步服务器\"></a>使用ownCloud作为OmniFocus的同步服务器</h2><p>ownCloud搭建完成后，就可以把它作为Omni的同步服务器了，具体方法如下：</p>\n<p>打开OmniFocus的同步设置页面，选择WebDAV方式同步，然后在Address中填入如下地址：</p>\n<blockquote>\n<p>http://<serveraddress>/owncloud/remote.php/dav/files/<adminname></p>\n</blockquote>\n<p><serveraddress>和<adminname>分别替换为你的服务器地址和刚才填的管理员用户名，如下图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/264b1ec833e6078643e9c2f40b2bf7aa.png\" alt=\"3\"></p>\n<p>然后点击“Sync Now”进行同步，会提示输入密码，输入刚才添加的管理员密码，然后就可以同步成功了。</p>\n<p>使用浏览器访问<a href=\"http://serveraddress/owncloud/\">http://serveraddress/owncloud/</a> ，就可以看到刚刚同步上去的文件了，如下图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/0da7c4ef259b48e8f608540c27091cbd.png\" alt=\"4\"></p>\n<h2 id=\"ownCloud的一些其他应用\"><a href=\"#ownCloud的一些其他应用\" class=\"headerlink\" title=\"ownCloud的一些其他应用\"></a>ownCloud的一些其他应用</h2><p>ownCloud还提供了多平台的客户端，包括iOS，Android，Mac，Windows等，你可以下载一个Mac客户端，然后设置一个同步文件夹，凡是放在这个文件夹里的文件，都会被自动同步到服务器上。如下图：</p>\n<p><img src=\"http://7xn88v.com1.z0.glb.clouddn.com/d7b6c828536bab1e8fa5a69a12332ebf.png\" alt=\"5\"></p>\n<p>我把Quiver的笔记数据也同步到了服务器上。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>其实ownCloud的功能还远不止这些，还有很多功能还待以后慢慢探索。</p>\n<p>类似ownCloud的还有一个叫<a href=\"https://www.seafile.com/home/\">seafile</a>的服务，两者的区别和优劣可以参考<a href=\"http://www.zhihu.com/question/23929945\">这里</a>。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://doc.owncloud.org/server/9.1/admin_manual/contents.html\">ownCloud官方文档</a><br><a href=\"https://doc.owncloud.org/server/9.1/user_manual/files/access_webdav.html\">ownCloud关于WebDAV使用的文档</a><br><a href=\"http://jjliu.blog.ustc.edu.cn/198/\">使用OwnCloud创建私有云</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cis94oa9d0000zrm0zpcnt0np","category_id":"cis94oa9r0004zrm02ijvrmd0","_id":"cis94oaa6000czrm0ca8zjsjt"},{"post_id":"cis94oaa4000azrm0byz3ofdd","category_id":"cis94oaa30009zrm0gi3u9z7a","_id":"cis94oaac000gzrm0yu2limbs"},{"post_id":"cis94oa9m0002zrm0xp5rj3ju","category_id":"cis94oaa30009zrm0gi3u9z7a","_id":"cis94oaah000jzrm0ap2u9rpo"},{"post_id":"cis94oaa6000dzrm02ltvaumm","category_id":"cis94oaa30009zrm0gi3u9z7a","_id":"cis94oaaj000mzrm0m1xq77g2"},{"post_id":"cis94oaaa000fzrm0hyfb4zzl","category_id":"cis94oa9r0004zrm02ijvrmd0","_id":"cis94oaal000qzrm0hvyjtieb"},{"post_id":"cis94oa9v0005zrm0eeqes0ah","category_id":"cis94oaa30009zrm0gi3u9z7a","_id":"cis94oaap000szrm0gopufv34"},{"post_id":"cis94oaah000lzrm0bf9gfmsh","category_id":"cis94oaa30009zrm0gi3u9z7a","_id":"cis94oaar000vzrm04ws2huhf"},{"post_id":"cis94oa9y0006zrm0g4hwyup3","category_id":"cis94oaa30009zrm0gi3u9z7a","_id":"cis94oaat000xzrm0zhvuv857"},{"post_id":"cis94oaa00008zrm0eq8rvu3m","category_id":"cis94oaa30009zrm0gi3u9z7a","_id":"cis94oaav0010zrm0ew07wfpp"},{"post_id":"cis94oaap000tzrm0xcn38j1e","category_id":"cis94oaa30009zrm0gi3u9z7a","_id":"cis94oaaz0012zrm0gpvpe7ww"},{"post_id":"cis94oaar000wzrm0a33zjgot","category_id":"cis94oaa30009zrm0gi3u9z7a","_id":"cis94oab20015zrm0bx9n14w8"},{"post_id":"cis94oaad000hzrm0veaso4ym","category_id":"cis94oaaq000uzrm0pe62umv7","_id":"cis94oab40017zrm0ouv1fsau"},{"post_id":"cis94oaat000yzrm08kymdii6","category_id":"cis94oaa30009zrm0gi3u9z7a","_id":"cis94oab60019zrm05cdll6rm"},{"post_id":"cis94oaax0011zrm05t5fvh5p","category_id":"cis94oaaq000uzrm0pe62umv7","_id":"cis94oab9001bzrm0x9op9gm0"},{"post_id":"cis94oaaj000ozrm0wugshho6","category_id":"cis94oaaq000uzrm0pe62umv7","_id":"cis94oabc001dzrm0ioiavt2j"},{"post_id":"cis94oaaz0013zrm0s2h8pj5n","category_id":"cis94oaaq000uzrm0pe62umv7","_id":"cis94oabe001fzrm0ajm94lfa"},{"post_id":"cis94oab20016zrm0r7jylpgh","category_id":"cis94oaa30009zrm0gi3u9z7a","_id":"cis94oabf001hzrm01l7kqsac"},{"post_id":"cis94oaam000rzrm06wjsvsdf","category_id":"cis94oaaq000uzrm0pe62umv7","_id":"cis94oabh001jzrm0d9up661y"},{"post_id":"cis94oab40018zrm073yjy2sv","category_id":"cis94oaaq000uzrm0pe62umv7","_id":"cis94oabj001mzrm0z3ooe92k"},{"post_id":"cis94oab6001azrm0jea2i8oy","category_id":"cis94oaaq000uzrm0pe62umv7","_id":"cis94oabk001ozrm0ih37tw7i"},{"post_id":"cis94oaba001czrm0kr7i1xyx","category_id":"cis94oaaq000uzrm0pe62umv7","_id":"cis94oabn001qzrm0tlcp8ot8"},{"post_id":"cis94oabc001ezrm06kmh07a9","category_id":"cis94oaa30009zrm0gi3u9z7a","_id":"cis94oabr001szrm06akz6a8e"},{"post_id":"cis94oabe001gzrm0fbnje7xv","category_id":"cis94oaa30009zrm0gi3u9z7a","_id":"cis94oabu001uzrm0xsvg8d8r"},{"post_id":"cis94oabh001kzrm03q5yfmaa","category_id":"cis94oaa30009zrm0gi3u9z7a","_id":"cis94oaby001wzrm0faztbkxn"},{"post_id":"cis94oabj001nzrm0vkgrh1dm","category_id":"cis94oaa30009zrm0gi3u9z7a","_id":"cis94oac1001zzrm0d05g28nx"},{"post_id":"cis94oabl001pzrm086ggpdy6","category_id":"cis94oabi001lzrm0efe9rjlg","_id":"cis94oac30021zrm0voudiu80"},{"post_id":"cis94oabf001izrm07t41z7pp","category_id":"cis94oabi001lzrm0efe9rjlg","_id":"cis94oac50024zrm0lwnkn74o"},{"post_id":"cis94oabn001rzrm00dmwmd7z","category_id":"cis94oa9r0004zrm02ijvrmd0","_id":"cis94oac60027zrm0so2a8zdn"},{"post_id":"cis94oabr001tzrm0dhp8w9fn","category_id":"cis94oa9r0004zrm02ijvrmd0","_id":"cis94oac90029zrm071d2v0lb"},{"post_id":"cis94oabu001vzrm03leo5bga","category_id":"cis94oa9r0004zrm02ijvrmd0","_id":"cis94oacd002dzrm0o9fi53gy"},{"post_id":"cis94oabz001xzrm0dxetnjdo","category_id":"cis94oabi001lzrm0efe9rjlg","_id":"cis94oacf002fzrm0o7yus1hr"},{"post_id":"cis94oac10020zrm0apfyavyg","category_id":"cis94oabi001lzrm0efe9rjlg","_id":"cis94oach002jzrm09zwwd913"},{"post_id":"cis94oac30022zrm0mapidjiw","category_id":"cis94oabi001lzrm0efe9rjlg","_id":"cis94oack002mzrm0odvn6jzj"},{"post_id":"cis94oac50025zrm0bbtzw6ga","category_id":"cis94oabi001lzrm0efe9rjlg","_id":"cis94oacl002ozrm0qc9maso0"},{"post_id":"cis94oac70028zrm0wyc59x16","category_id":"cis94oaa30009zrm0gi3u9z7a","_id":"cis94oacm002rzrm03w05kr8l"},{"post_id":"cis94oaca002azrm0xcvvxg9h","category_id":"cis94oabi001lzrm0efe9rjlg","_id":"cis94oacm002tzrm0syyqpnyk"},{"post_id":"cis94oaci002kzrm0f975chf9","category_id":"cis94oa9r0004zrm02ijvrmd0","_id":"cis94oacn002uzrm06tpsifll"},{"post_id":"cis94oacd002ezrm0fpd0but5","category_id":"cis94oach002izrm057yfxoxq","_id":"cis94oacn002wzrm0fhkxx7s8"},{"post_id":"cis94oacg002gzrm012ojca3m","category_id":"cis94oach002izrm057yfxoxq","_id":"cis94oaco002yzrm0zzkz2q9d"}],"PostTag":[{"post_id":"cis94oa9v0005zrm0eeqes0ah","tag_id":"cis94oa9z0007zrm0em4qq5qo","_id":"cis94oaah000kzrm00owfg1lc"},{"post_id":"cis94oa9v0005zrm0eeqes0ah","tag_id":"cis94oaa6000bzrm0o8g3h77b","_id":"cis94oaaj000nzrm0exq6qee0"},{"post_id":"cis94oabu001vzrm03leo5bga","tag_id":"cis94oac0001yzrm0tq00vntc","_id":"cis94oac60026zrm0docvt3cq"},{"post_id":"cis94oabz001xzrm0dxetnjdo","tag_id":"cis94oac40023zrm0lr7k2kh8","_id":"cis94oacd002czrm0azq1cdx6"},{"post_id":"cis94oac10020zrm0apfyavyg","tag_id":"cis94oacc002bzrm0zpk4zsra","_id":"cis94oacj002lzrm0eh1numrv"},{"post_id":"cis94oac30022zrm0mapidjiw","tag_id":"cis94oac40023zrm0lr7k2kh8","_id":"cis94oacl002qzrm04sbj40ct"},{"post_id":"cis94oac50025zrm0bbtzw6ga","tag_id":"cis94oacc002bzrm0zpk4zsra","_id":"cis94oacn002xzrm0twi3gsq2"},{"post_id":"cis94oac50025zrm0bbtzw6ga","tag_id":"cis94oacm002szrm0k7vtco7o","_id":"cis94oaco002zzrm01uav7jmp"},{"post_id":"cis94oac70028zrm0wyc59x16","tag_id":"cis94oacn002vzrm0ud8b3nur","_id":"cis94oaco0031zrm0menxgbon"},{"post_id":"cis94oaca002azrm0xcvvxg9h","tag_id":"cis94oaco0030zrm0qcidpwyw","_id":"cis94oacp0033zrm0xvs5ju1l"},{"post_id":"cis94oacd002ezrm0fpd0but5","tag_id":"cis94oacp0032zrm0sizgg3hh","_id":"cis94oacq0035zrm081r87v5i"},{"post_id":"cis94oacg002gzrm012ojca3m","tag_id":"cis94oacp0032zrm0sizgg3hh","_id":"cis94oacq0037zrm0ft8lfigz"},{"post_id":"cis94oaci002kzrm0f975chf9","tag_id":"cis94oac40023zrm0lr7k2kh8","_id":"cis94oacs0039zrm08qdgl5kh"},{"post_id":"cis94oaci002kzrm0f975chf9","tag_id":"cis94oacq0036zrm066tmsi22","_id":"cis94oacs003azrm0s69ml1ha"},{"post_id":"cis94oaci002kzrm0f975chf9","tag_id":"cis94oacr0038zrm0e8vx91hn","_id":"cis94oacs003bzrm099ge5zga"}],"Tag":[{"name":"iOS开发","_id":"cis94oa9z0007zrm0em4qq5qo"},{"name":"Emoji表情","_id":"cis94oaa6000bzrm0o8g3h77b"},{"name":"Hexo","_id":"cis94oac0001yzrm0tq00vntc"},{"name":"其他","_id":"cis94oac40023zrm0lr7k2kh8"},{"name":"UILabel","_id":"cis94oacc002bzrm0zpk4zsra"},{"name":"NSAttributedString","_id":"cis94oacm002szrm0k7vtco7o"},{"name":"CoreAnimation","_id":"cis94oacn002vzrm0ud8b3nur"},{"name":"UIButton","_id":"cis94oaco0030zrm0qcidpwyw"},{"name":"Git","_id":"cis94oacp0032zrm0sizgg3hh"},{"name":"WebDAV","_id":"cis94oacq0036zrm066tmsi22"},{"name":"ownCloud","_id":"cis94oacr0038zrm0e8vx91hn"}]}}